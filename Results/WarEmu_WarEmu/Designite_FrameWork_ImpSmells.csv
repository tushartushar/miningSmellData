Implementation smell,Namespace,Class,File,Method,Description
Long Method,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The method has 222 lines of code.
Long Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillLazyObjectRelations,The method has 105 lines of code.
Long Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The method has 103 lines of code.
Long Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_fast,The method has 115 lines of code.
Long Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The method has 147 lines of code.
Long Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The method has 169 lines of code.
Long Method,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The method has 494 lines of code.
Long Method,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The method has 349 lines of code.
Long Method,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The method has 232 lines of code.
Long Method,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The method has 196 lines of code.
Long Method,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The method has 214 lines of code.
Complex Method,FrameWork,ConfigMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Config\ConfigMgr.cs,LoadConfigs,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,ConsoleMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Console\ConsoleMgr.cs,ExecuteCommand,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,Cyclomatic complexity of the method is 33
Complex Method,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,PrintDatasetErrors,Cyclomatic complexity of the method is 10
Complex Method,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,AddObjectImpl,Cyclomatic complexity of the method is 9
Complex Method,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,ConvertVal,Cyclomatic complexity of the method is 21
Complex Method,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,GetVal,Cyclomatic complexity of the method is 24
Complex Method,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SaveObjectImpl,Cyclomatic complexity of the method is 10
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillObjectWithRow,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillRowWithObject,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,RegisterDataObject,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,SaveObjectRelations,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,DeleteObjectRelations,Cyclomatic complexity of the method is 16
Complex Method,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,FillLazyObjectRelations,Cyclomatic complexity of the method is 19
Complex Method,FrameWork,LoaderMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,Start,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,Cyclomatic complexity of the method is 20
Complex Method,FrameWork,BaseClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,Crypt,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WritePacketLength,Cyclomatic complexity of the method is 10
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 14
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 14
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 27
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 15
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 16
Complex Method,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,Cyclomatic complexity of the method is 13
Complex Method,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,Cyclomatic complexity of the method is 12
Complex Method,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,HandlePacket,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,RpcObject,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcObject.cs,RegisterHandlers,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,RpcServer,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcServer.cs,Ping,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 18
Complex Method,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 26
Complex Method,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,Cyclomatic complexity of the method is 52
Complex Method,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,Cyclomatic complexity of the method is 43
Complex Method,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,Cyclomatic complexity of the method is 36
Complex Method,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,FrameWork,BindingInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,BindingInfo,The method has 5 parameters. Parameters: member' primaryKey' hasRelation' readOnly' attrib
Long Parameter List,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Tcp,The method has 5 parameters. Parameters: name' dump' start' len' Force
Long Parameter List,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Dump,The method has 5 parameters. Parameters: name' dump' start' len' Force
Long Parameter List,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The method has 5 parameters. Parameters: Value' P1' P2' P3' P4
Long Parameter List,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,FrameWork,Config,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,FrameWork,StaticTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,FrameWork,AuthSessionTokenReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReply__Descriptor is 62.
Long Identifier,FrameWork,AuthSessionTokenReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReply__FieldAccessorTable is 70.
Long Identifier,FrameWork,AuthSessionTokenReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter _authSessionTokenReplyFieldNames is 32.
Long Identifier,FrameWork,AuthSessionTokenReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,,The length of the parameter _authSessionTokenReplyFieldTags is 31.
Long Identifier,FrameWork,AuthSessionTokenReqProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReq__Descriptor is 60.
Long Identifier,FrameWork,AuthSessionTokenReqProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter internal__static_login_proto_AuthSessionTokenReq__FieldAccessorTable is 68.
Long Identifier,FrameWork,AuthSessionTokenReq,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReqProto.cs,,The length of the parameter _authSessionTokenReqFieldNames is 30.
Long Identifier,FrameWork,GetAcctPropListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply__Descriptor is 61.
Long Identifier,FrameWork,GetAcctPropListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply__FieldAccessorTable is 69.
Long Identifier,FrameWork,GetAcctPropListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply_AcctProp__Descriptor is 70.
Long Identifier,FrameWork,GetAcctPropListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetAcctPropListReply_AcctProp__FieldAccessorTable is 78.
Long Identifier,FrameWork,GetAcctPropListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter _getAcctPropListReplyFieldNames is 31.
Long Identifier,FrameWork,GetAcctPropListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,,The length of the parameter _getAcctPropListReplyFieldTags is 30.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply__Descriptor is 64.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply__FieldAccessorTable is 72.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply_CharSummary__Descriptor is 76.
Long Identifier,FrameWork,GetCharSummaryListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetCharSummaryListReply_CharSummary__FieldAccessorTable is 84.
Long Identifier,FrameWork,GetCharSummaryListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter _getCharSummaryListReplyFieldNames is 34.
Long Identifier,FrameWork,GetCharSummaryListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,,The length of the parameter _getCharSummaryListReplyFieldTags is 33.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ServerInfo__Descriptor is 51.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ServerInfo__FieldAccessorTable is 59.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterProp__Descriptor is 52.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterProp__FieldAccessorTable is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterInfo__Descriptor is 52.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_ClusterInfo__FieldAccessorTable is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetClusterListReply__Descriptor is 60.
Long Identifier,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter internal__static_login_proto_GetClusterListReply__FieldAccessorTable is 68.
Long Identifier,FrameWork,GetClusterListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,,The length of the parameter _getClusterListReplyFieldNames is 30.
Long Identifier,FrameWork,VerifyProtocolReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReply__Descriptor is 60.
Long Identifier,FrameWork,VerifyProtocolReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReply__FieldAccessorTable is 68.
Long Identifier,FrameWork,VerifyProtocolReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,,The length of the parameter _verifyProtocolReplyFieldNames is 30.
Long Identifier,FrameWork,VerifyProtocolReqProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReq__Descriptor is 58.
Long Identifier,FrameWork,VerifyProtocolReqProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,,The length of the parameter internal__static_login_proto_VerifyProtocolReq__FieldAccessorTable is 66.
Long Statement,FrameWork,ConsoleMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Console\ConsoleMgr.cs,ExecuteCommand,The length of the statement  "            var consoleHandlerAttribs = (ConsoleHandlerAttribute[])Handler.GetType().GetCustomAttributes(typeof(ConsoleHandlerAttribute)' true); " is 132.
Long Statement,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The length of the statement  "                Log.Notice("DataConnection"'string.Format("Socket exception: ({0}) {1}; repeat: {2}"' socketException.ErrorCode' socketException.Message' ret)); " is 144.
Long Statement,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteSelect,The length of the statement  "                            Log.Notice("DataConnecion"' "SQL Select (" + isolation + ") took " + (Environment.TickCount - start) + "ms!\n" + sqlcommand); " is 125.
Long Statement,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The length of the statement  "                            if (reader.GetString(0).ToLower() != (table.TableName + "_ID").ToLower() && !table.Columns.Contains(reader.GetString(0).ToLower())) " is 131.
Long Statement,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SaveObjectImpl,The length of the statement  "                    Log.Error("MysqlObject"' "Modify error : " + dataObject.TableName + " ID=" + dataObject.ObjectId + " --- keyvalue changed? " + sql + " " + Environment.StackTrace); " is 163.
Long Statement,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,DeleteObjectImpl,The length of the statement  "                    Log.Error("MysqlObject"' "Delete Object : " + dataObject.TableName + " failed! ID=" + dataObject.ObjectId + " " + Environment.StackTrace); " is 138.
Long Statement,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,InitInstance,The length of the statement  "                BackDir += "/" + Config.PreFileName + "." + DateTime.Now.Hour + "h." + DateTime.Now.Minute + "m." + DateTime.Now.Second + "s" + Config.FileName; " is 144.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 139.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_authSessionTokenReqFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "                int field_ordinal = global::System.Array.BinarySearch(_acctPropFieldNames' field_name' global::System.StringComparer.Ordinal); " is 126.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getAcctPropListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 138.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry); " is 148.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "                int field_ordinal = global::System.Array.BinarySearch(_charSummaryFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getCharSummaryListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 141.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry); " is 157.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_serverInfoFieldNames' field_name' global::System.StringComparer.Ordinal); " is 128.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_clusterPropFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_clusterInfoFieldNames' field_name' global::System.StringComparer.Ordinal); " is 129.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry); " is 125.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry); " is 128.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_getClusterListReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "              input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry); " is 127.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReplyFieldNames' field_name' global::System.StringComparer.Ordinal); " is 137.
Long Statement,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The length of the statement  "            int field_ordinal = global::System.Array.BinarySearch(_verifyProtocolReqFieldNames' field_name' global::System.StringComparer.Ordinal); " is 135.
Long Statement,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,HandlePacket,The length of the statement  "                PacketHandlerAttribute[] packethandlerattribs = (PacketHandlerAttribute[])packetHandler.GetType().GetCustomAttributes(typeof(PacketHandlerAttribute)' true); " is 156.
Long Statement,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,HandlePacket,The length of the statement  "                        Log.Error("TCPManager"' "Can not handle packet ("+Packet.Opcode.ToString("X8")+")' Invalid client state ("+client.GetIp+")"); " is 125.
Long Statement,FrameWork,RpcClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcClient.cs,Connect,The length of the statement  "                Log.Success("RpcClient"' "Connected to : " + ServerIp + ":" + RpcServerPort + "' Listen on : " + Info.Ip + ":" + Info.Port); " is 124.
Long Statement,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The length of the statement  "				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The length of the statement  "				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The length of the statement  "			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The length of the statement  "			if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)) " is 123.
Long Statement,FrameWork,ZStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The length of the statement  "			if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)) " is 191.
Long Statement,FrameWork,ZStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The length of the statement  "				//System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,CheckOrCreateTable,The conditional expression  "primaryKeys.ContainsKey(table.Columns[i].ColumnName) ||                              table.Columns[i].ExtendedProperties.ContainsKey("INDEX") ||                              table.Columns[i].ExtendedProperties.ContainsKey("VARCHAR") ||                              table.Columns[i].Unique"  is complex.
Complex Conditional,FrameWork,ObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\ObjectDatabase.cs,GetBindingInfo,The conditional expression  "attrib.Length > 0 || keyAttrib.Length > 0 || relAttrib.Length > 0 || readonlyAttrib.Length > 0"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,FrameWork,ZStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16R".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt16R".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32R".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt32R".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64R".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64".
Virtual Method Call from Constructor,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,PacketOut,The constructor "PacketOut" calls a virtual method "WriteUInt64R".
Empty Catch Block,FrameWork,ConfigMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Config\ConfigMgr.cs,LoadConfigs,The method has an empty catch block.
Empty Catch Block,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,InitInstance,The method has an empty catch block.
Empty Catch Block,FrameWork,BaseClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,CloseConnections,The method has an empty catch block.
Empty Catch Block,FrameWork,BaseClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,CloseConnections,The method has an empty catch block.
Empty Catch Block,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,ConnectingThread,The method has an empty catch block.
Empty Catch Block,FrameWork,RpcClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcClient.cs,Connect,The method has an empty catch block.
Empty Catch Block,FrameWork,ZOutputStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,FrameWork,ZOutputStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,FrameWork,ConsoleMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Console\ConsoleMgr.cs,GetInt,The following statement contains a magic number: return -999;
Magic Number,FrameWork,DataElement,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Attributes\DataElement.cs,DataElement,The following statement contains a magic number: Decimal = 10;
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteNonQuery,The following statement contains a magic number: Environment.TickCount - start > 500
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following statement contains a magic number: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteSelect,The following statement contains a magic number: Environment.TickCount - start > 500
Magic Number,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,ExecuteScalar,The following statement contains a magic number: Environment.TickCount - start > 500
Magic Number,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SelectObjectsImpl,The following statement contains a magic number: var dataObjects = new List<DataObject>(64);
Magic Number,FrameWork,MySQLObjectDatabase,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Handler\MysqlObjectDatabase.cs,SelectObjectsImpl,The following statement contains a magic number: var dataObjects = new List<TObject>(64);
Magic Number,FrameWork,LoaderMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,InitLoad,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,FrameWork,LoaderMgr,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Loader\LoaderMgr.cs,Wait,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Texte,The following statement contains a magic number: Console.BufferHeight = Console.WindowWidth - 20;
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j < 16
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Compare,The following statement contains a magic number: j < 16
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: j == 3 || j == 7 || j == 11
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: val >= 32 && val <= 127
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: val >= 32 && val <= 127
Magic Number,FrameWork,Log,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Logs\Log.cs,Hex,The following statement contains a magic number: j < 16
Magic Number,FrameWork,BaseClient,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\BaseClient.cs,SendTCP,The following statement contains a magic number: took > 100
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetUint64,The following statement contains a magic number: UInt64 value = (GetUint32() << 24) + (GetUint32());
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetUint64R,The following statement contains a magic number: UInt64 value = (GetUint32()) + (GetUint32() << 24);
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetInt64,The following statement contains a magic number: byte[] tmp = Read(8);
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetInt64R,The following statement contains a magic number: byte[] tmp = Read(8);
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: b[2] = (byte)ReadByte();
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,GetFloat,The following statement contains a magic number: b[3] = (byte)ReadByte();
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,ReadPs,The following statement contains a magic number: Length >= Position + 2
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeMythicSize,The following statement contains a magic number: mSize = (mSize | (mByte << (7 * mByteCount)));
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeMythicSize,The following statement contains a magic number: mSize = (mSize | (mByte << (7 * mByteCount)));
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: midpoint = Packet.Length / 2;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: x = (x + 1) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: y = (y + Key[x]) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: tmp = (byte)(( Key[x] + Key[y] ) & 255);
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: y = (y + Packet[pos]) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: x = (x + 1) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: y = (y + Key[x]) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: tmp = (byte)((Key[x] + Key[y]) & 255);
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecryptMythicRC4,The following statement contains a magic number: y = (y + Packet[pos]) & 255;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: Size += ((GetUint8() - 1) * 128) + 2;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: Size += ((GetUint8() - 1) * 128) + 2;
Magic Number,FrameWork,PacketIn,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketIn.cs,DecodeGamebryoSize,The following statement contains a magic number: Size >= 128
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt16,The following statement contains a magic number: WriteByte((byte)(val >> 8));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt16R,The following statement contains a magic number: WriteByte((byte)(val >> 8));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)(val >> 24));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32,The following statement contains a magic number: WriteByte((byte)((val & 0xffff) >> 8));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)((val & 0xffff) >> 8));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt32R,The following statement contains a magic number: WriteByte((byte)(val >> 24));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)(val >> 56));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 48) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 40) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 32) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 24) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64,The following statement contains a magic number: WriteByte((byte)((val >> 8) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 8) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 16) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 24) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 32) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 40) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)((val >> 48) & 0xff));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteUInt64R,The following statement contains a magic number: WriteByte((byte)(val >> 56));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,GetChecksum,The following statement contains a magic number: val += buf[i + 8];
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,GetChecksum,The following statement contains a magic number: i < Position - 6
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: int length = hexString.Length / 2;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: WriteByte(Convert.ToByte(hexString.Substring(i * 2' 2)' 16));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WriteHexStringBytes,The following statement contains a magic number: (hexString.Length % 2) == 0
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WritePacketString,The following statement contains a magic number: WriteHexStringBytes(Line.Substring(1' Line.IndexOf("|"' 2)-1));
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: midpoint = Packet.Length / 2;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: x = (x + 1) & 255;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: y = (y + Key[x]) & 255;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: tmp = (byte)((Key[x] + Key[y]) & 255);
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: y = (y + Packet[pos]) & 255;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: x = (x + 1) & 255;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: y = (y + Key[x]) & 255;
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: tmp = (byte)((Key[x] + Key[y]) & 255);
Magic Number,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,EncryptMythicRC4,The following statement contains a magic number: y = (y + Packet[pos]) & 255;
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ConvertToInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ConvertToInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt32,The following statement contains a magic number: return ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return ConvertToUInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return ConvertToUInt32(val[startIndex]' val[startIndex + 1]' val[startIndex + 2]' val[startIndex + 3]);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt32,The following statement contains a magic number: return (uint) ((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToFloat,The following statement contains a magic number: return (float)((v1 << 24) | (v2 << 16) | (v3 << 8) | v4);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToInt16,The following statement contains a magic number: return (short) ((v1 << 8) | v2);
Magic Number,FrameWork,Marshal,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Marshal.cs,ConvertToUInt16,The following statement contains a magic number: return (ushort) (v2 | (v1 << 8));
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasSessionToken = input.ReadBytes(ref result.sessionToken_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasPropertyId = input.ReadUInt32(ref result.propertyId_);                    break;                  }                  case 16: {                    result.hasPropertyValue = input.ReadInt32(ref result.propertyValue_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasPropertyId = input.ReadUInt32(ref result.propertyId_);                    break;                  }                  case 16: {                    result.hasPropertyValue = input.ReadInt32(ref result.propertyValue_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.propList_' global::FrameWork.GetAcctPropListReply.Types.AcctProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {                  case 0: {                    throw pb::InvalidProtocolBufferException.InvalidTag();                  }                  default: {                    if (pb::WireFormat.IsEndGroupTag(tag)) {                      if (unknownFields != null) {                        this.UnknownFields = unknownFields.Build();                      }                      return this;                    }                    if (unknownFields == null) {                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                    }                    ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                    break;                  }                  case 8: {                    result.hasServerId = input.ReadUInt32(ref result.serverId_);                    break;                  }                  case 16: {                    result.hasCharacterId = input.ReadUInt32(ref result.characterId_);                    break;                  }                  case 24: {                    result.hasLastPlayedTime = input.ReadInt64(ref result.lastPlayedTime_);                    break;                  }                  case 34: {                    result.hasXmlData = input.ReadString(ref result.xmlData_);                    break;                  }                }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.summaryList_' global::FrameWork.GetCharSummaryListReply.Types.CharSummary.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasServerId = input.ReadUInt32(ref result.serverId_);                break;              }              case 18: {                result.hasServerName = input.ReadString(ref result.serverName_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasServerId = input.ReadUInt32(ref result.serverId_);                break;              }              case 18: {                result.hasServerName = input.ReadString(ref result.serverName_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasPropName = input.ReadString(ref result.propName_);                break;              }              case 18: {                result.hasPropValue = input.ReadString(ref result.propValue_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 10: {                result.hasPropName = input.ReadString(ref result.propName_);                break;              }              case 18: {                result.hasPropValue = input.ReadString(ref result.propValue_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasClusterId = input.ReadUInt32(ref result.clusterId_);                break;              }              case 18: {                result.hasClusterName = input.ReadString(ref result.clusterName_);                break;              }              case 26: {                result.hasLobbyHost = input.ReadString(ref result.lobbyHost_);                break;              }              case 32: {                result.hasLobbyPort = input.ReadUInt32(ref result.lobbyPort_);                break;              }              case 40: {                result.hasClusterPop = input.ReadUInt32(ref result.clusterPop_);                break;              }              case 48: {                result.hasMaxClusterPop = input.ReadUInt32(ref result.maxClusterPop_);                break;              }              case 56: {                object unknown;                if(input.ReadEnum(ref result.clusterPopStatus_' out unknown)) {                  result.hasClusterPopStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(7' (ulong)(int)unknown);                }                break;              }              case 64: {                result.hasLanguageId = input.ReadUInt32(ref result.languageId_);                break;              }              case 72: {                object unknown;                if(input.ReadEnum(ref result.clusterStatus_' out unknown)) {                  result.hasClusterStatus = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(9' (ulong)(int)unknown);                }                break;              }              case 82: {                input.ReadMessageArray(tag' field_name' result.serverList_' global::FrameWork.ServerInfo.DefaultInstance' extensionRegistry);                break;              }              case 90: {                input.ReadMessageArray(tag' field_name' result.propertyList_' global::FrameWork.ClusterProp.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                input.ReadMessageArray(tag' field_name' result.clusterList_' global::FrameWork.ClusterInfo.DefaultInstance' extensionRegistry);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                object unknown;                if(input.ReadEnum(ref result.resultCode_' out unknown)) {                  result.hasResultCode = true;                } else if(unknown is int) {                  if (unknownFields == null) {                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                  }                  unknownFields.MergeVarintField(1' (ulong)(int)unknown);                }                break;              }              case 18: {                result.hasIv1 = input.ReadBytes(ref result.iv1_);                break;              }              case 26: {                result.hasIv2 = input.ReadBytes(ref result.iv2_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }
Magic Number,FrameWork,Builder,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\AuthSessionTokenReplyProto.cs,MergeFrom,The following statement contains a magic number: switch (tag) {              case 0: {                throw pb::InvalidProtocolBufferException.InvalidTag();              }              default: {                if (pb::WireFormat.IsEndGroupTag(tag)) {                  if (unknownFields != null) {                    this.UnknownFields = unknownFields.Build();                  }                  return this;                }                if (unknownFields == null) {                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);                }                ParseUnknownField(input' unknownFields' extensionRegistry' tag' field_name);                break;              }              case 8: {                result.hasProtocolVersion = input.ReadUInt32(ref result.protocolVersion_);                break;              }              case 16: {                result.hasProductId = input.ReadUInt32(ref result.productId_);                break;              }              case 26: {                result.hasClientPublicKey = input.ReadBytes(ref result.clientPublicKey_);                break;              }            }
Magic Number,FrameWork,GetAcctPropListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(2' field_names[0]' propList_);
Magic Number,FrameWork,AcctProp,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetAcctPropListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteInt32(2' field_names[1]' PropertyValue);
Magic Number,FrameWork,GetCharSummaryListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(2' field_names[1]' summaryList_);
Magic Number,FrameWork,CharSummary,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(1' field_names[2]' ServerId);
Magic Number,FrameWork,CharSummary,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(2' field_names[0]' CharacterId);
Magic Number,FrameWork,CharSummary,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteInt64(3' field_names[1]' LastPlayedTime);
Magic Number,FrameWork,CharSummary,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(4' field_names[3]' XmlData);
Magic Number,FrameWork,CharSummary,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetCharSummaryListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(4' field_names[3]' XmlData);
Magic Number,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,GetClusterListReplyProto,The following statement contains a magic number: pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {          descriptor = root;          internal__static_login_proto_ServerInfo__Descriptor = Descriptor.MessageTypes[0];          internal__static_login_proto_ServerInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ServerInfo' global::FrameWork.ServerInfo.Builder>(internal__static_login_proto_ServerInfo__Descriptor'                  new string[] { "ServerId"' "ServerName"' });          internal__static_login_proto_ClusterProp__Descriptor = Descriptor.MessageTypes[1];          internal__static_login_proto_ClusterProp__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterProp' global::FrameWork.ClusterProp.Builder>(internal__static_login_proto_ClusterProp__Descriptor'                  new string[] { "PropName"' "PropValue"' });          internal__static_login_proto_ClusterInfo__Descriptor = Descriptor.MessageTypes[2];          internal__static_login_proto_ClusterInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterInfo' global::FrameWork.ClusterInfo.Builder>(internal__static_login_proto_ClusterInfo__Descriptor'                  new string[] { "ClusterId"' "ClusterName"' "LobbyHost"' "LobbyPort"' "ClusterPop"' "MaxClusterPop"' "ClusterPopStatus"' "LanguageId"' "ClusterStatus"' "ServerList"' "PropertyList"' });          internal__static_login_proto_GetClusterListReply__Descriptor = Descriptor.MessageTypes[3];          internal__static_login_proto_GetClusterListReply__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.GetClusterListReply' global::FrameWork.GetClusterListReply.Builder>(internal__static_login_proto_GetClusterListReply__Descriptor'                  new string[] { "ResultCode"' "ClusterList"' });          pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();          RegisterAllExtensions(registry);          global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.RegisterAllExtensions(registry);          return registry;        };
Magic Number,FrameWork,GetClusterListReplyProto,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,GetClusterListReplyProto,The following statement contains a magic number: pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {          descriptor = root;          internal__static_login_proto_ServerInfo__Descriptor = Descriptor.MessageTypes[0];          internal__static_login_proto_ServerInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ServerInfo' global::FrameWork.ServerInfo.Builder>(internal__static_login_proto_ServerInfo__Descriptor'                  new string[] { "ServerId"' "ServerName"' });          internal__static_login_proto_ClusterProp__Descriptor = Descriptor.MessageTypes[1];          internal__static_login_proto_ClusterProp__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterProp' global::FrameWork.ClusterProp.Builder>(internal__static_login_proto_ClusterProp__Descriptor'                  new string[] { "PropName"' "PropValue"' });          internal__static_login_proto_ClusterInfo__Descriptor = Descriptor.MessageTypes[2];          internal__static_login_proto_ClusterInfo__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.ClusterInfo' global::FrameWork.ClusterInfo.Builder>(internal__static_login_proto_ClusterInfo__Descriptor'                  new string[] { "ClusterId"' "ClusterName"' "LobbyHost"' "LobbyPort"' "ClusterPop"' "MaxClusterPop"' "ClusterPopStatus"' "LanguageId"' "ClusterStatus"' "ServerList"' "PropertyList"' });          internal__static_login_proto_GetClusterListReply__Descriptor = Descriptor.MessageTypes[3];          internal__static_login_proto_GetClusterListReply__FieldAccessorTable =               new pb::FieldAccess.FieldAccessorTable<global::FrameWork.GetClusterListReply' global::FrameWork.GetClusterListReply.Builder>(internal__static_login_proto_GetClusterListReply__Descriptor'                  new string[] { "ResultCode"' "ClusterList"' });          pb::ExtensionRegistry registry = pb::ExtensionRegistry.CreateInstance();          RegisterAllExtensions(registry);          global::Google.ProtocolBuffers.DescriptorProtos.CSharpOptions.RegisterAllExtensions(registry);          return registry;        };
Magic Number,FrameWork,ServerInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(2' field_names[1]' ServerName);
Magic Number,FrameWork,ClusterProp,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(2' field_names[1]' PropValue);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(2' field_names[1]' ClusterName);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(3' field_names[6]' LobbyHost);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteString(3' field_names[6]' LobbyHost);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(4' field_names[7]' LobbyPort);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(4' field_names[7]' LobbyPort);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(5' field_names[2]' ClusterPop);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(5' field_names[2]' ClusterPop);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(6' field_names[8]' MaxClusterPop);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(6' field_names[8]' MaxClusterPop);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteEnum(7' field_names[3]' (int) ClusterPopStatus' ClusterPopStatus);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteEnum(7' field_names[3]' (int) ClusterPopStatus' ClusterPopStatus);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(8' field_names[5]' LanguageId);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(8' field_names[5]' LanguageId);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteEnum(9' field_names[4]' (int) ClusterStatus' ClusterStatus);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteEnum(9' field_names[4]' (int) ClusterStatus' ClusterStatus);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(10' field_names[10]' serverList_);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(10' field_names[10]' serverList_);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(11' field_names[9]' propertyList_);
Magic Number,FrameWork,ClusterInfo,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(11' field_names[9]' propertyList_);
Magic Number,FrameWork,GetClusterListReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\GetClusterListReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteMessageArray(2' field_names[0]' clusterList_);
Magic Number,FrameWork,VerifyProtocolReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteEnum(1' field_names[2]' (int) ResultCode' ResultCode);
Magic Number,FrameWork,VerifyProtocolReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteBytes(2' field_names[0]' Iv1);
Magic Number,FrameWork,VerifyProtocolReply,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReplyProto.cs,WriteTo,The following statement contains a magic number: output.WriteBytes(3' field_names[1]' Iv2);
Magic Number,FrameWork,VerifyProtocolReq,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(1' field_names[2]' ProtocolVersion);
Magic Number,FrameWork,VerifyProtocolReq,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: output.WriteUInt32(2' field_names[1]' ProductId);
Magic Number,FrameWork,VerifyProtocolReq,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ProtocolBuffers\VerifyProtocolReqProto.cs,WriteTo,The following statement contains a magic number: output.WriteBytes(3' field_names[0]' ClientPublicKey);
Magic Number,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,GetTimeStamp,The following statement contains a magic number: return (int)(DateTime.UtcNow - new DateTime(1970' 1' 1)).TotalSeconds;
Magic Number,FrameWork,TCPManager,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\TCPManager.cs,GetTimeStampMS,The following statement contains a magic number: return (long)(DateTime.UtcNow - new DateTime(1970' 1' 1)).TotalMilliseconds;
Magic Number,FrameWork,RpcObject,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Remoting\RpcObject.cs,RegisterHandlers,The following statement contains a magic number: List<Type>[] Registered = new List<Type>[2] { new List<Type>()' new List<Type>() };
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToVector,The following statement contains a magic number: return new Vector3(Value[0]' Value[1]' Value[2]);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToPosition,The following statement contains a magic number: float[] Result = new float[3] { 0' 0' 0 };
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToColor,The following statement contains a magic number: Col.B = float.Parse(Bytes[2]);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,StringToColor,The following statement contains a magic number: Col.A = float.Parse(Bytes[3]);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (long)(P1 << 32 + P2);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (int)(Value >> 32);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (int)(P1 << 16 + P2);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (ushort)(Value >> 16);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode2Values,The following statement contains a magic number: return (ushort)((P1 << 8) + P2);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode2Values,The following statement contains a magic number: P1 = (byte)(Value >> 8);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Encode4Values,The following statement contains a magic number: return (int)((P1 << 24) + (P2 << 16) + (P3 << 8) + P4);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P1 = (byte)(Value >> 24);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P2 = (byte)(Value >> 16);
Magic Number,FrameWork,Utils,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Utils\Utils.cs,Decode4Values,The following statement contains a magic number: P3 = (byte)(Value >> 8);
Magic Number,FrameWork,Adler32,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,FrameWork,Adler32,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: k -= 16;
Magic Number,FrameWork,Adler32,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: k >= 16
Magic Number,FrameWork,Adler32,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short) SupportClass.Identity(0xffff);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte) (SupportClass.URShift(w' 8)));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte) (b >> 8));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) (SupportClass.URShift(dist' 8));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte) dist;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit * 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int) (out_length + (int) dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = SupportClass.URShift(out_length' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && level > 2
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte) (bin_freq > (SupportClass.URShift(ascii_freq' 2))?Z_BINARY:Z_ASCII);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = pending_buf_size - 5;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size > pending_buf_size - 5
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof?1:0)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != - 1
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: prev_length -= 2;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: level = 6;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: _level = 6;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: level_flags > 3
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) (SupportClass.URShift(strm.adler' 16)));
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Config[10];
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,FrameWork,Deflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < (3))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = (int) (b & 7);  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < (32))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if (((SupportClass.URShift((~ b)' 16)) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = (b & 0xffff);  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = (int) (q < read?read - q - 1:end - q);  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = (int) (q < read?read - q - 1:end - q);  								if (q == end && read != 0)  								{  									q = 0; m = (int) (q < read?read - q - 1:end - q);  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < (14))  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = (b & 0x3fff);  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' (14)); k -= (14);  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + (SupportClass.URShift(table' 10)))  						{  							while (k < (3))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' (3)); k -= (3);  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < (t))  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' (t)); k -= (t);  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < (t + i))  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' (t)); k -= (t);  								  								j += (b & inflate_mask[i]);  								  								b = SupportClass.URShift(b' (i)); k -= (i);  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							int[] bl = new int[1];  							int[] bd = new int[1];  							int[] tl = new int[1];  							int[] td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = (int) (q < read?read - q - 1:end - q);  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = (int) (q < read?read - q - 1:end - q);  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' (tree[tindex + 1]));  						k -= (tree[tindex + 1]);  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = (tree[tindex]);  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < (j))  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += (b & inflate_mask[j]);  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < (20)
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + ((int) b & inflate_mask[e]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < (15)
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp[(tp_index + t) * 3];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 64) == 0
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c?k >> 3:c;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c?k >> 3:c;
Magic Number,FrameWork,InfCodes,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = (z.next_in[z.next_in_index++]) & 0xff;  						  						if ((((z.istate.method << 8) + b) % 31) != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);  						  						if (((int) (z.istate.was[0])) != ((int) (z.istate.need)))  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,FrameWork,Inflate,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: m != 4
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: int[] r = new int[3];
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int) (q - u[h - 1] - j);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int[] v = new int[19];
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: int[] v = new int[288];
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,FrameWork,InfTree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256?_dist_code[dist]:_dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short) bits;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + ((long) bits - (long) tree[m * 2 + 1]) * (long) tree[m * 2]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short) bits;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2?++max_code:0);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,FrameWork,Tree,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] = (short) (bi_reverse(next_code[len]++' len));
Magic Number,FrameWork,ZInputStream,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\ZInputStream.cs,skip,The following statement contains a magic number: int len = 512;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt16)(              ((0xFF00 & input) >> 8) |              ((0x00FF & input) << 8)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt16)(              ((0xFF00 & input) >> 8) |              ((0x00FF & input) << 8)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: return ((UInt32)(              ((0xFF000000 & input) >> 24) |              ((0x00FF0000 & input) >> 8) |              ((0x0000FF00 & input) << 8) |              ((0x000000FF & input) << 24)));
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: byte[] tmpOut = new byte[4];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[0] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[1] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[1];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[0];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: byte[] tmpOut = new byte[8];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[0] = tmpIn[7];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[1] = tmpIn[6];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[5];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[2] = tmpIn[5];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[4];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[3] = tmpIn[4];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[4] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[4] = tmpIn[3];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[5] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[5] = tmpIn[2];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[6] = tmpIn[1];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,Swap,The following statement contains a magic number: tmpOut[7] = tmpIn[0];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[0] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[1] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[2] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[3] = (byte)(n);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[off] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[++off] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_BE,The following statement contains a magic number: bs[++off] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: uint n = (uint)bs[0] << 24;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[1] << 16;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 8;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 8;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3];
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: uint n = (uint)bs[off] << 24;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 16;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 8;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: uint lo = BE_To_UInt32(bs' off + 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,BE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n >> 32)' bs' off);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_BE,The following statement contains a magic number: UInt32_To_BE((uint)(n)' bs' off + 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[1] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[2] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[3] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 8);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 16);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt32_To_LE,The following statement contains a magic number: bs[++off] = (byte)(n >> 24);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[1] << 8;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 16;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[2] << 16;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3] << 24;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[3] << 24;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 8;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 16;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt32,The following statement contains a magic number: n |= (uint)bs[++off] << 24;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: uint hi = LE_To_UInt32(bs' off + 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,LE_To_UInt64,The following statement contains a magic number: return ((ulong)hi << 32) | (ulong)lo;
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Magic Number,ByteOperations,ByteSwap,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\ByteSwap.cs,UInt64_To_LE,The following statement contains a magic number: UInt32_To_LE((uint)(n >> 32)' bs' off + 4);
Duplicate Code,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,SaveDataSet,The method contains a code clone-set at the following line numbers (starting from the method definition): ((44' 65)' (80' 101))
Missing Default,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,HandleException,The following switch statement is missing a default case: switch (socketException.ErrorCode)                  {                      case 10052:                      case 10053:                      case 10054:                      case 10057:                      case 10058:                          {                              ret = true;                              break;                          }                  }
Missing Default,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,GetDBDateFormat,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MYSQL:                      return "yyyy-MM-dd HH:mm:ss";              }
Missing Default,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,LoadDataSet,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MSSQL:                      {                          try                          {                              var conn = new SqlConnection(connString);                              var adapter = new SqlDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_ODBC:                      {                          try                          {                              var conn = new OdbcConnection(connString);                              var adapter = new OdbcDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_OLEDB:                      {                          try                          {                              var conn = new OleDbConnection(connString);                              var adapter = new OleDbDataAdapter("SELECT * from " + tableName' conn);                                adapter.Fill(dataSet.Tables[tableName]);                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not load table "' ex);                          }                          break;                      }              }
Missing Default,FrameWork,DataConnection,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\Database\Connection\DataConnection.cs,SaveDataSet,The following switch statement is missing a default case: switch (connType)              {                  case ConnectionType.DATABASE_MSSQL:                      {                          try                          {                              var conn = new SqlConnection(connString);                              var adapter = new SqlDataAdapter("SELECT * from " + tableName' conn);                              var builder = new SqlCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  DataSet changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  PrintDatasetErrors(changes);                                  dataSet.AcceptChanges();                              }                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table " + tableName' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_ODBC:                      {                          try                          {                              var conn = new OdbcConnection(connString);                              var adapter = new OdbcDataAdapter("SELECT * from " + tableName' conn);                              var builder = new OdbcCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                DataSet changes;                              lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  dataSet.AcceptChanges();                              }                                PrintDatasetErrors(changes);                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table "' ex);                          }                            break;                      }                  case ConnectionType.DATABASE_MYSQL:                      {                          return;                      }                  case ConnectionType.DATABASE_OLEDB:                      {                          try                          {                              var conn = new OleDbConnection(connString);                              var adapter = new OleDbDataAdapter("SELECT * from " + tableName' conn);                              var builder = new OleDbCommandBuilder(adapter);                                adapter.DeleteCommand = builder.GetDeleteCommand();                              adapter.UpdateCommand = builder.GetUpdateCommand();                              adapter.InsertCommand = builder.GetInsertCommand();                                DataSet changes;                              lock (dataSet) // lock dataset to prevent changes to it                              {                                  adapter.ContinueUpdateOnError = true;                                  changes = dataSet.GetChanges();                                  adapter.Update(changes' tableName);                                  dataSet.AcceptChanges();                              }                                PrintDatasetErrors(changes);                                conn.Close();                          }                          catch (Exception ex)                          {                              throw new DatabaseException("Can not save table"' ex);                          }                          break;                      }              }
Missing Default,FrameWork,PacketOut,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\NetWork\Clients\PacketOut.cs,WritePacketLength,The following switch statement is missing a default case: switch (SizeLen)              {                  case sizeof(byte):                      WriteByte((byte)(size));                      break;                    case sizeof(UInt16):                      if (!SizeReverse) WriteUInt16((UInt16)(size));                      else WriteUInt16R((UInt16)size);                      break;                    case sizeof(UInt32):                      if (!SizeReverse) WriteUInt32((UInt16)(size));                      else WriteUInt32R((UInt16)size);                      break;                    case sizeof(UInt64):                      if (!SizeReverse) WriteUInt32((UInt16)(size));                      else WriteUInt32R((UInt16)size);                      break;              }
Missing Default,FrameWork,InfBlocks,D:\research\architectureSmells\repos\WarEmu_WarEmu\FrameWork\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' (t)); k -= (t);  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									int[] bl = new int[1];  									int[] bd = new int[1];  									int[][] tl = new int[1][];  									int[][] td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' (3)); k -= (3);  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}
