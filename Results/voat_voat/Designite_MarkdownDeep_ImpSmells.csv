Implementation smell,Namespace,Class,File,Method,Description
Long Method,MarkdownDeep,Block,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,Render,The method has 191 lines of code.
Long Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The method has 260 lines of code.
Long Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The method has 272 lines of code.
Long Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,The method has 169 lines of code.
Long Method,MarkdownDeep,LinkDefinition,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,The method has 122 lines of code.
Long Method,MarkdownDeep,Markdown,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,Transform,The method has 112 lines of code.
Long Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Render,The method has 114 lines of code.
Long Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The method has 184 lines of code.
Long Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessLinkOrImageOrFootnote,The method has 126 lines of code.
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,Cyclomatic complexity of the method is 11
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,Cyclomatic complexity of the method is 44
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessMarkdownEnabledHtml,Cyclomatic complexity of the method is 11
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,Cyclomatic complexity of the method is 27
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,Cyclomatic complexity of the method is 8
Complex Method,MarkdownDeep,HtmlTag,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,IsSafe,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,HtmlTag,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,Cyclomatic complexity of the method is 14
Complex Method,MarkdownDeep,LinkDefinition,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,Cyclomatic complexity of the method is 14
Complex Method,MarkdownDeep,Markdown,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,OnQualifyUrl,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,CreateEmphasisMark,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,Cyclomatic complexity of the method is 17
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessAutoLink,Cyclomatic complexity of the method is 8
Complex Method,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessLinkOrImageOrFootnote,Cyclomatic complexity of the method is 20
Complex Method,MarkdownDeep,TableSpec,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\TableSpec.cs,Parse,Cyclomatic complexity of the method is 12
Complex Method,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipHtmlEntity,Cyclomatic complexity of the method is 10
Long Statement,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The length of the statement  "                                if (prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd) " is 144.
Long Statement,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The length of the statement  "                    (lines[i - 1].blockType == BlockType.p || lines[i - 1].blockType == BlockType.ul_li || lines[i - 1].blockType == BlockType.ol_li)) " is 130.
Long Statement,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The length of the statement  "                while (end_of_li < lines.Count - 1 && lines[end_of_li + 1].blockType != BlockType.ul_li && lines[end_of_li + 1].blockType != BlockType.ol_li) " is 141.
Complex Conditional,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The conditional expression  "prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The conditional expression  "(ch == '*' || ch == '+' || ch == '-') && IsLineSpace(CharAtOffset(1))"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,The conditional expression  "!bHeadBlock && !tag.closing && m_markdown.ExtraMode && !bHasUnsafeContent"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The conditional expression  "(lines[i].blockType == BlockType.p) &&                      (lines[i - 1].blockType == BlockType.p || lines[i - 1].blockType == BlockType.ul_li || lines[i - 1].blockType == BlockType.ol_li)"  is complex.
Complex Conditional,MarkdownDeep,HtmlTag,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,The conditional expression  "!p.eof && !char.IsWhiteSpace(p.current) && p.current != '>' && p.current != '/'"  is complex.
Complex Conditional,MarkdownDeep,LinkDefinition,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,The conditional expression  "(id == null && p.current != ')') ||                              (id != null && !p.eol)"  is complex.
Complex Conditional,MarkdownDeep,Markdown,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,OnPrepareLink,The conditional expression  "(NewWindowForExternalLinks && Utils.IsUrlFullyQualified(url)) ||                   (NewWindowForLocalLinks && !Utils.IsUrlFullyQualified(url))"  is complex.
Complex Conditional,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,MakeID,The conditional expression  "char.IsLetterOrDigit(ch) || ch == '_' || ch == '-' || ch == '.'"  is complex.
Complex Conditional,MarkdownDeep,StringScanner,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\StringScanner.cs,SkipFootnoteID,The conditional expression  "char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == ':' || ch == '.' || ch == ' '"  is complex.
Complex Conditional,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,ParseIdentifier,The conditional expression  "pos < str.Length && (char.IsDigit(str[pos]) || char.IsLetter(str[pos]) || str[pos] == '_')"  is complex.
Complex Conditional,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipHtmlEntity,The conditional expression  "!(char.IsDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'))"  is complex.
Complex Conditional,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,IsValidHtmlID,The conditional expression  "Char.IsLetterOrDigit(ch) || ch == '_' || ch == '-' || ch == ':' || ch == '.'"  is complex.
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The following statement contains a magic number: while (!eof)              {                  // Remember if the previous line was blank                  bool bPreviousBlank = PrevBlockType == BlockType.Blank;                    // Get the next block                  var b = EvaluateLine();                  PrevBlockType = b.blockType;                    // For dd blocks' we need to know if it was preceeded by a blank line                  // so store that fact as the block's data.                  if (b.blockType == BlockType.dd)                  {                      b.data = bPreviousBlank;                  }                    // SetExt header?                  if (b.blockType == BlockType.post_h1 || b.blockType == BlockType.post_h2)                  {                      if (lines.Count > 0)                      {                          // Remove the previous line and collapse the current paragraph                          var prevline = lines.Pop();                          CollapseLines(blocks' lines);                            // If previous line was blank'                          if (prevline.blockType != BlockType.Blank)                          {                              // Convert the previous line to a heading and add to block list                              prevline.RevertToPlain();                              prevline.blockType = b.blockType == BlockType.post_h1 ? BlockType.h1 : BlockType.h2;                              blocks.Add(prevline);                              continue;                          }                      }                        // Couldn't apply setext header to a previous line                        if (b.blockType == BlockType.post_h1)                      {                          // `===` gets converted to normal paragraph                          b.RevertToPlain();                          lines.Add(b);                      }                      else                      {                          // `---` gets converted to hr                          if (b.contentLen >= 3)                          {                              b.blockType = BlockType.hr;                              blocks.Add(b);                          }                          else                          {                              b.RevertToPlain();                              lines.Add(b);                          }                      }                        continue;                  }                    // Work out the current paragraph type                  BlockType currentBlockType = lines.Count > 0 ? lines[0].blockType : BlockType.Blank;                    // Starting a table?                  if (b.blockType == BlockType.table_spec)                  {                      // Get the table spec' save position                      TableSpec spec = (TableSpec)b.data;                      int savepos = position;                      if (!StartTable(spec' lines))                      {                          // Not a table' revert the tablespec row to plain'                          // fast forward back to where we were up to and continue                          // on as if nothing happened                          position = savepos;                          b.RevertToPlain();                      }                      else                      {                          blocks.Add(b);                          continue;                      }                  }                    // Process this line                  switch (b.blockType)                  {                      case BlockType.Blank:                          switch (currentBlockType)                          {                              case BlockType.Blank:                                  FreeBlock(b);                                  break;                                case BlockType.p:                                  CollapseLines(blocks' lines);                                  FreeBlock(b);                                  break;                                case BlockType.quote:                              case BlockType.ol_li:                              case BlockType.ul_li:                              case BlockType.dd:                              case BlockType.footnote:                              case BlockType.indent:                                  lines.Add(b);                                  break;                                default:                                  System.Diagnostics.Debug.Assert(false);                                  break;                          }                          break;                        case BlockType.p:                          switch (currentBlockType)                          {                              case BlockType.Blank:                              case BlockType.p:                                  lines.Add(b);                                  break;                                case BlockType.quote:                              case BlockType.ol_li:                              case BlockType.ul_li:                              case BlockType.dd:                              case BlockType.footnote:                                  var prevline = lines.Last();                                  if (prevline.blockType == BlockType.Blank)                                  {                                      CollapseLines(blocks' lines);                                      lines.Add(b);                                  }                                  else                                  {                                      lines.Add(b);                                  }                                  break;                                case BlockType.indent:                                  CollapseLines(blocks' lines);                                  lines.Add(b);                                  break;                                default:                                  System.Diagnostics.Debug.Assert(false);                                  break;                          }                          break;                        case BlockType.indent:                          switch (currentBlockType)                          {                              case BlockType.Blank:                                  // Start a code block                                  lines.Add(b);                                  break;                                case BlockType.p:                              case BlockType.quote:                                  var prevline = lines.Last();                                  if (prevline.blockType == BlockType.Blank)                                  {                                      // Start a code block after a paragraph                                      CollapseLines(blocks' lines);                                      lines.Add(b);                                  }                                  else                                  {                                      // indented line in paragraph' just continue it                                      b.RevertToPlain();                                      lines.Add(b);                                  }                                  break;                                case BlockType.ol_li:                              case BlockType.ul_li:                              case BlockType.dd:                              case BlockType.footnote:                              case BlockType.indent:                                  lines.Add(b);                                  break;                                default:                                  System.Diagnostics.Debug.Assert(false);                                  break;                          }                          break;                        case BlockType.quote:                          if (currentBlockType != BlockType.quote)                          {                              CollapseLines(blocks' lines);                          }                          lines.Add(b);                          break;                        case BlockType.ol_li:                      case BlockType.ul_li:                          switch (currentBlockType)                          {                              case BlockType.Blank:                                  lines.Add(b);                                  break;                                case BlockType.p:                              case BlockType.quote:                                  var prevline = lines.Last();                                  if (prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd)                                  {                                      // List starting after blank line after paragraph or quote                                      CollapseLines(blocks' lines);                                      lines.Add(b);                                  }                                  else                                  {                                      // List's can't start in middle of a paragraph                                      b.RevertToPlain();                                      lines.Add(b);                                  }                                  break;                                case BlockType.ol_li:                              case BlockType.ul_li:                                  if (b.blockType != BlockType.ol_li && b.blockType != BlockType.ul_li)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.dd:                              case BlockType.footnote:                                  if (b.blockType != currentBlockType)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.indent:                                  // List after code block                                  CollapseLines(blocks' lines);                                  lines.Add(b);                                  break;                          }                          break;                        case BlockType.dd:                      case BlockType.footnote:                          switch (currentBlockType)                          {                              case BlockType.Blank:                              case BlockType.p:                              case BlockType.dd:                              case BlockType.footnote:                                  CollapseLines(blocks' lines);                                  lines.Add(b);                                  break;                                default:                                  b.RevertToPlain();                                  lines.Add(b);                                  break;                          }                          break;                        default:                          CollapseLines(blocks' lines);                          blocks.Add(b);                          break;                  }              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (ch == '#')              {                  // Work out heading level                  int level = 1;                  SkipForward(1);                  while (current == '#')                  {                      level++;                      SkipForward(1);                  }                    // Limit of 6                  if (level > 6)                      level = 6;                    // Skip any whitespace                  SkipLinespace();                    // Save start position                  b.contentStart = position;                    // Jump to end                  SkipToEol();                    // In extra mode' check for a trailing HTML ID                  if (m_markdown.ExtraMode && !m_markdown.SafeMode)                  {                      int end = position;                      string strID = Utils.StripHtmlID(input' b.contentStart' ref end);                      if (strID != null)                      {                          b.data = strID;                          position = end;                      }                  }                    // Rewind over trailing hashes                  while (position > b.contentStart && CharAtOffset(-1) == '#')                  {                      SkipForward(-1);                  }                    // Rewind over trailing spaces                  while (position > b.contentStart && char.IsWhiteSpace(CharAtOffset(-1)))                  {                      SkipForward(-1);                  }                    // Create the heading block                  b.contentEnd = position;                    SkipToEol();                  return BlockType.h1 + (level - 1);              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (ch == '#')              {                  // Work out heading level                  int level = 1;                  SkipForward(1);                  while (current == '#')                  {                      level++;                      SkipForward(1);                  }                    // Limit of 6                  if (level > 6)                      level = 6;                    // Skip any whitespace                  SkipLinespace();                    // Save start position                  b.contentStart = position;                    // Jump to end                  SkipToEol();                    // In extra mode' check for a trailing HTML ID                  if (m_markdown.ExtraMode && !m_markdown.SafeMode)                  {                      int end = position;                      string strID = Utils.StripHtmlID(input' b.contentStart' ref end);                      if (strID != null)                      {                          b.data = strID;                          position = end;                      }                  }                    // Rewind over trailing hashes                  while (position > b.contentStart && CharAtOffset(-1) == '#')                  {                      SkipForward(-1);                  }                    // Rewind over trailing spaces                  while (position > b.contentStart && char.IsWhiteSpace(CharAtOffset(-1)))                  {                      SkipForward(-1);                  }                    // Create the heading block                  b.contentEnd = position;                    SkipToEol();                  return BlockType.h1 + (level - 1);              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (leadingSpaces >= 4)              {                  b.contentStart = line_start + 4;                  return BlockType.indent;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (leadingSpaces >= 4)              {                  b.contentStart = line_start + 4;                  return BlockType.indent;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (tabPos >= 0 && tabPos - line_start < 4)              {                  b.contentStart = tabPos + 1;                  return BlockType.indent;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (ch == '>')              {                  // Block quote followed by space                  if (IsLineSpace(CharAtOffset(1)))                  {                      // Skip it and create quote block                      SkipForward(2);                      b.contentStart = position;                      return BlockType.quote;                  }                    SkipForward(1);                  b.contentStart = position;                  return BlockType.quote;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (ch == '-' || ch == '_' || ch == '*')              {                  int count = 0;                  while (!eol)                  {                      char chType = current;                      if (current == ch)                      {                          count++;                          SkipForward(1);                          continue;                      }                        if (IsLineSpace(current))                      {                          SkipForward(1);                          continue;                      }                        break;                  }                    if (eol && count >= 3)                  {                      if (m_markdown.UserBreaks)                          return BlockType.user_break;                      else                          return BlockType.hr;                  }                    // Rewind                  position = b.contentStart;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (m_markdown.ExtraMode && ch == '*' && CharAtOffset(1) == '[')              {                  SkipForward(2);                  SkipLinespace();                    Mark();                  while (!eol && current != ']')                  {                      SkipForward(1);                  }                    var abbr = Extract().Trim();                  if (current == ']' && CharAtOffset(1) == ':' && !string.IsNullOrEmpty(abbr))                  {                      SkipForward(2);                      SkipLinespace();                        Mark();                        SkipToEol();                        var title = Extract();                        m_markdown.AddAbbreviation(abbr' title);                        return BlockType.Blank;                  }                    position = b.contentStart;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (m_markdown.ExtraMode && ch == '*' && CharAtOffset(1) == '[')              {                  SkipForward(2);                  SkipLinespace();                    Mark();                  while (!eol && current != ']')                  {                      SkipForward(1);                  }                    var abbr = Extract().Trim();                  if (current == ']' && CharAtOffset(1) == ':' && !string.IsNullOrEmpty(abbr))                  {                      SkipForward(2);                      SkipLinespace();                        Mark();                        SkipToEol();                        var title = Extract();                        m_markdown.AddAbbreviation(abbr' title);                        return BlockType.Blank;                  }                    position = b.contentStart;              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: if (ch == '[')              {                  // Footnote definition?                  if (m_markdown.ExtraMode && CharAtOffset(1) == '^')                  {                      var savepos = position;                        SkipForward(2);                        string id;                      if (SkipFootnoteID(out id) && SkipChar(']') && SkipChar(':'))                      {                          SkipLinespace();                          b.contentStart = position;                          b.data = id;                          return BlockType.footnote;                      }                        position = savepos;                  }                    // Parse a link definition                  LinkDefinition l = LinkDefinition.ParseLinkDefinition(this' m_markdown.ExtraMode);                  if (l != null)                  {                      m_markdown.AddLinkDefinition(l);                      return BlockType.Blank;                  }              }
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: if (strFence.Length < 3)                  return false;
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: if (input[endCode - 1] == '\r' && input[endCode - 2] == '\n')                  endCode -= 2;              else if (input[endCode - 1] == '\n' && input[endCode - 2] == '\r')                  endCode -= 2;              else                  endCode--;
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: if (input[endCode - 1] == '\r' && input[endCode - 2] == '\n')                  endCode -= 2;              else if (input[endCode - 1] == '\n' && input[endCode - 2] == '\r')                  endCode -= 2;              else                  endCode--;
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: if (input[endCode - 1] == '\r' && input[endCode - 2] == '\n')                  endCode -= 2;              else if (input[endCode - 1] == '\n' && input[endCode - 2] == '\r')                  endCode -= 2;              else                  endCode--;
Magic Number,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: if (input[endCode - 1] == '\r' && input[endCode - 2] == '\n')                  endCode -= 2;              else if (input[endCode - 1] == '\n' && input[endCode - 2] == '\r')                  endCode -= 2;              else                  endCode--;
Magic Number,MarkdownDeep,HtmlTag,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,The following statement contains a magic number: if (p.SkipString("!--"))              {                  p.Mark();                    if (p.Find("-->"))                  {                      var t = new HtmlTag("!");                      t.m_attributes.Add("content"' p.Extract());                      t.m_closed = true;                      p.SkipForward(3);                      return t;                  }              }
Magic Number,MarkdownDeep,Markdown,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,OnQualifyUrl,The following statement contains a magic number: if (url.StartsWith("/"))              {                  if (!string.IsNullOrEmpty(UrlRootLocation))                  {                      return UrlRootLocation + url;                  }                    // Need to find domain root                  int pos = UrlBaseLocation.IndexOf("://");                  if (pos == -1)                      pos = 0;                  else                      pos += 3;                    // Find the first slash after the protocol separator                  pos = UrlBaseLocation.IndexOf('/'' pos);                    // Get the domain name                  string strDomain = pos < 0 ? UrlBaseLocation : UrlBaseLocation.Substring(0' pos);                    // Join em                  return strDomain + url;              }              else              {                  if (!UrlBaseLocation.EndsWith("/"))                      return UrlBaseLocation + "/" + url;                  else                      return UrlBaseLocation + url;              }
Magic Number,MarkdownDeep,Markdown,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,HtmlEncodeAndConvertTabsToSpaces,The following statement contains a magic number: while (!p.eof)              {                  char ch = p.current;                  switch (ch)                  {                      case '\t':                          dest.Append(' ');                          pos++;                          while ((pos % 4) != 0)                          {                              dest.Append(' ');                              pos++;                          }                          pos--;      // Compensate for the pos++ below                          break;                        case '\r':                      case '\n':                          dest.Append('\n');                          pos = 0;                          p.SkipEol();                          continue;                        case '&':                          dest.Append("&amp;");                          break;                        case '<':                          dest.Append("&lt;");                          break;                        case '>':                          dest.Append("&gt;");                          break;                        case '\"':                          dest.Append("&quot;");                          break;                        default:                          dest.Append(ch);                          break;                  }                  p.SkipForward(1);                  pos++;              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: while (!eof)              {                  int end_text_token = position;                    // Work out token                  Token token = null;                  switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }                    // Look for abbreviations.                  if (token == null && Abbreviations != null && !Char.IsLetterOrDigit(CharAtOffset(-1)))                  {                      var savepos = position;                      foreach (var abbr in Abbreviations)                      {                          if (SkipString(abbr.Abbr) && !Char.IsLetterOrDigit(current))                          {                              token = CreateToken(TokenType.abbreviation' abbr);                              break;                          }                            position = savepos;                      }                  }                    // If token found' append any preceeding text and the new token to the token list                  if (token != null)                  {                      // Create a token for everything up to the special character                      if (end_text_token > start_text_token)                      {                          m_Tokens.Add(CreateToken(TokenType.Text' start_text_token' end_text_token - start_text_token));                      }                        // Add the new token                      m_Tokens.Add(token);                        // Remember where the next text token starts                      start_text_token = position;                  }                  else                  {                      // Skip a single character and keep looking                      SkipForward(1);                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: while (!eof)              {                  int end_text_token = position;                    // Work out token                  Token token = null;                  switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }                    // Look for abbreviations.                  if (token == null && Abbreviations != null && !Char.IsLetterOrDigit(CharAtOffset(-1)))                  {                      var savepos = position;                      foreach (var abbr in Abbreviations)                      {                          if (SkipString(abbr.Abbr) && !Char.IsLetterOrDigit(current))                          {                              token = CreateToken(TokenType.abbreviation' abbr);                              break;                          }                            position = savepos;                      }                  }                    // If token found' append any preceeding text and the new token to the token list                  if (token != null)                  {                      // Create a token for everything up to the special character                      if (end_text_token > start_text_token)                      {                          m_Tokens.Add(CreateToken(TokenType.Text' start_text_token' end_text_token - start_text_token));                      }                        // Add the new token                      m_Tokens.Add(token);                        // Remember where the next text token starts                      start_text_token = position;                  }                  else                  {                      // Skip a single character and keep looking                      SkipForward(1);                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: while (!eof)              {                  int end_text_token = position;                    // Work out token                  Token token = null;                  switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }                    // Look for abbreviations.                  if (token == null && Abbreviations != null && !Char.IsLetterOrDigit(CharAtOffset(-1)))                  {                      var savepos = position;                      foreach (var abbr in Abbreviations)                      {                          if (SkipString(abbr.Abbr) && !Char.IsLetterOrDigit(current))                          {                              token = CreateToken(TokenType.abbreviation' abbr);                              break;                          }                            position = savepos;                      }                  }                    // If token found' append any preceeding text and the new token to the token list                  if (token != null)                  {                      // Create a token for everything up to the special character                      if (end_text_token > start_text_token)                      {                          m_Tokens.Add(CreateToken(TokenType.Text' start_text_token' end_text_token - start_text_token));                      }                        // Add the new token                      m_Tokens.Add(token);                        // Remember where the next text token starts                      start_text_token = position;                  }                  else                  {                      // Skip a single character and keep looking                      SkipForward(1);                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: while (bContinue)              {                  bContinue = false;                  for (int i = 0; i < marks.Count; i++)                  {                      // Get the next opening or internal mark                      Token opening_mark = marks[i];                      if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                          continue;                        // Look for a matching closing mark                      for (int j = i + 1; j < marks.Count; j++)                      {                          // Get the next closing or internal mark                          Token closing_mark = marks[j];                          if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                              break;                            // Ignore if different type (ie: `*` vs `_`)                          if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                              continue;                            // strong or em?                          int style = Math.Min(opening_mark.length' closing_mark.length);                            // Triple or more on both ends?                          if (style >= 3)                          {                              style = (style % 2) == 1 ? 1 : 2;                          }                            // Split the opening mark' keeping the RHS                          if (opening_mark.length > style)                          {                              opening_mark = SplitMarkToken(tokens' marks' opening_mark' opening_mark.length - style);                              i--;                          }                            // Split the closing mark' keeping the LHS                          if (closing_mark.length > style)                          {                              SplitMarkToken(tokens' marks' closing_mark' style);                          }                            // Connect them                          opening_mark.type = style == 1 ? TokenType.open_em : TokenType.open_strong;                          closing_mark.type = style == 1 ? TokenType.close_em : TokenType.close_strong;                            // Remove the matched marks                          marks.Remove(opening_mark);                          marks.Remove(closing_mark);                          bContinue = true;                            break;                      }                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: while (bContinue)              {                  bContinue = false;                  for (int i = 0; i < marks.Count; i++)                  {                      // Get the next opening or internal mark                      Token opening_mark = marks[i];                      if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                          continue;                        // Look for a matching closing mark                      for (int j = i + 1; j < marks.Count; j++)                      {                          // Get the next closing or internal mark                          Token closing_mark = marks[j];                          if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                              break;                            // Ignore if different type (ie: `*` vs `_`)                          if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                              continue;                            // strong or em?                          int style = Math.Min(opening_mark.length' closing_mark.length);                            // Triple or more on both ends?                          if (style >= 3)                          {                              style = (style % 2) == 1 ? 1 : 2;                          }                            // Split the opening mark' keeping the RHS                          if (opening_mark.length > style)                          {                              opening_mark = SplitMarkToken(tokens' marks' opening_mark' opening_mark.length - style);                              i--;                          }                            // Split the closing mark' keeping the LHS                          if (closing_mark.length > style)                          {                              SplitMarkToken(tokens' marks' closing_mark' style);                          }                            // Connect them                          opening_mark.type = style == 1 ? TokenType.open_em : TokenType.open_strong;                          closing_mark.type = style == 1 ? TokenType.close_em : TokenType.close_strong;                            // Remove the matched marks                          marks.Remove(opening_mark);                          marks.Remove(closing_mark);                          bContinue = true;                            break;                      }                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: while (bContinue)              {                  bContinue = false;                  for (int i = 0; i < marks.Count; i++)                  {                      // Get the next opening or internal mark                      Token opening_mark = marks[i];                      if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                          continue;                        // Look for a matching closing mark                      for (int j = i + 1; j < marks.Count; j++)                      {                          // Get the next closing or internal mark                          Token closing_mark = marks[j];                          if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                              break;                            // Ignore if different type (ie: `*` vs `_`)                          if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                              continue;                            // strong or em?                          int style = Math.Min(opening_mark.length' closing_mark.length);                            // Triple or more on both ends?                          if (style >= 3)                          {                              style = (style % 2) == 1 ? 1 : 2;                          }                            // Split the opening mark' keeping the RHS                          if (opening_mark.length > style)                          {                              opening_mark = SplitMarkToken(tokens' marks' opening_mark' opening_mark.length - style);                              i--;                          }                            // Split the closing mark' keeping the LHS                          if (closing_mark.length > style)                          {                              SplitMarkToken(tokens' marks' closing_mark' style);                          }                            // Connect them                          opening_mark.type = style == 1 ? TokenType.open_em : TokenType.open_strong;                          closing_mark.type = style == 1 ? TokenType.close_em : TokenType.close_strong;                            // Remove the matched marks                          marks.Remove(opening_mark);                          marks.Remove(closing_mark);                          bContinue = true;                            break;                      }                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: for (int i = 0; i < marks.Count; i++)              {                  // Get the next opening or internal mark                  Token opening_mark = marks[i];                  if (opening_mark.type != TokenType.opening_mark && opening_mark.type != TokenType.internal_mark)                      continue;                  if (opening_mark.length < 2)                      continue;                    // Look for a matching closing mark                  for (int j = i + 1; j < marks.Count; j++)                  {                      // Get the next closing or internal mark                      Token closing_mark = marks[j];                      if (closing_mark.type != TokenType.closing_mark && closing_mark.type != TokenType.internal_mark)                          continue;                        // Ignore if different type (ie: `*` vs `_`)                      if (input[opening_mark.startOffset] != input[closing_mark.startOffset])                          continue;                        // Must be at least two                      if (closing_mark.length < 2)                          continue;                        // Split the opening mark' keeping the LHS                      if (opening_mark.length > 2)                      {                          SplitMarkToken(tokens' marks' opening_mark' 2);                      }                        // Split the closing mark' keeping the RHS                      if (closing_mark.length > 2)                      {                          closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);                      }                        // Connect them                      opening_mark.type = TokenType.open_strong;                      closing_mark.type = TokenType.close_strong;                        // Continue after the closing mark                      i = marks.IndexOf(closing_mark);                      break;                  }              }
Magic Number,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessAutoLink,The following statement contains a magic number: while (!eof)              {                  char ch = current;                    // No whitespace allowed                  if (char.IsWhiteSpace(ch))                      break;                    // End found?                  if (ch == '>')                  {                      string url = Utils.UnescapeString(Extract()' ExtraMode);                        LinkInfo li = null;                      if (Utils.IsEmailAddress(url))                      {                          string link_text;                          if (url.StartsWith("mailto:"))                          {                              link_text = url.Substring(7);                          }                          else                          {                              link_text = url;                              url = "mailto:" + url;                          }                            li = new LinkInfo(new LinkDefinition("auto"' url' null)' link_text);                      }                      else if (Utils.IsWebAddress(url))                      {                          li = new LinkInfo(new LinkDefinition("auto"' url' null)' url);                      }                        if (li != null)                      {                          SkipForward(1);                          return CreateToken(TokenType.link' li);                      }                        return null;                  }                    this.SkipEscapableChar(ExtraMode);              }
Magic Number,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,HtmlRandomize,The following statement contains a magic number: foreach (char ch in str)              {                  int x = r.Next() % 100;                  if (x > 90 && ch != '@')                  {                      dest.Append(ch);                  }                  else if (x > 45)                  {                      dest.Append("&#");                      dest.Append(((int)ch).ToString());                      dest.Append(";");                  }                  else                  {                      dest.Append("&#x");                      dest.Append(((int)ch).ToString("x"));                      dest.Append(";");                  }              }
Magic Number,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,HtmlRandomize,The following statement contains a magic number: foreach (char ch in str)              {                  int x = r.Next() % 100;                  if (x > 90 && ch != '@')                  {                      dest.Append(ch);                  }                  else if (x > 45)                  {                      dest.Append("&#");                      dest.Append(((int)ch).ToString());                      dest.Append(";");                  }                  else                  {                      dest.Append("&#x");                      dest.Append(((int)ch).ToString("x"));                      dest.Append(";");                  }              }
Magic Number,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,HtmlRandomize,The following statement contains a magic number: foreach (char ch in str)              {                  int x = r.Next() % 100;                  if (x > 90 && ch != '@')                  {                      dest.Append(ch);                  }                  else if (x > 45)                  {                      dest.Append("&#");                      dest.Append(((int)ch).ToString());                      dest.Append(";");                  }                  else                  {                      dest.Append("&#x");                      dest.Append(((int)ch).ToString("x"));                      dest.Append(";");                  }              }
Magic Number,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipEscapableChar,The following statement contains a magic number: if (p.current == '\\' && IsEscapableChar(p.CharAtOffset(1)' ExtraMode))              {                  p.SkipForward(2);              }              else              {                  p.SkipForward(1);              }
Magic Number,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,StripHtmlID,The following statement contains a magic number: int startId = pos + 2;
Missing Default,MarkdownDeep,Block,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,RenderPlain,The following switch statement is missing a default case: switch (blockType)              {                  case BlockType.Blank:                      return;                    case BlockType.p:                  case BlockType.span:                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" ");                      break;                    case BlockType.h1:                  case BlockType.h2:                  case BlockType.h3:                  case BlockType.h4:                  case BlockType.h5:                  case BlockType.h6:                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" - ");                      break;                    case BlockType.ol_li:                  case BlockType.ul_li:                      b.Append("* ");                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" ");                      break;                    case BlockType.dd:                      if (children != null)                      {                          b.Append("\n");                          RenderChildrenPlain(m' b);                      }                      else                          m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      break;                    case BlockType.dt:                      {                          if (children == null)                          {                              foreach (var l in Content.Split('\n'))                              {                                  var str = l.Trim();                                  m.SpanFormatter.FormatPlain(b' str' 0' str.Length);                              }                          }                          else                          {                              RenderChildrenPlain(m' b);                          }                          break;                      }                    case BlockType.dl:                      RenderChildrenPlain(m' b);                      return;                    case BlockType.codeblock:                      foreach (var line in children)                      {                          b.Append(line.buf' line.contentStart' line.contentLen);                          b.Append(" ");                      }                      return;                    case BlockType.quote:                  case BlockType.li:                  case BlockType.ol:                  case BlockType.ul:                  case BlockType.HtmlTag:                      RenderChildrenPlain(m' b);                      return;              }
Missing Default,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The following switch statement is missing a default case: switch (currentBlockType)                          {                              case BlockType.Blank:                                  lines.Add(b);                                  break;                                case BlockType.p:                              case BlockType.quote:                                  var prevline = lines.Last();                                  if (prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd)                                  {                                      // List starting after blank line after paragraph or quote                                      CollapseLines(blocks' lines);                                      lines.Add(b);                                  }                                  else                                  {                                      // List's can't start in middle of a paragraph                                      b.RevertToPlain();                                      lines.Add(b);                                  }                                  break;                                case BlockType.ol_li:                              case BlockType.ul_li:                                  if (b.blockType != BlockType.ol_li && b.blockType != BlockType.ul_li)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.dd:                              case BlockType.footnote:                                  if (b.blockType != currentBlockType)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.indent:                                  // List after code block                                  CollapseLines(blocks' lines);                                  lines.Add(b);                                  break;                          }
Missing Default,MarkdownDeep,BlockProcessor,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessMarkdownEnabledHtml,The following switch statement is missing a default case: switch (mode)                              {                                  case MarkdownInHtmlMode.Span:                                      {                                          Block span = this.CreateBlock();                                          span.buf = input;                                          span.blockType = BlockType.span;                                          span.contentStart = inner_pos;                                          span.contentLen = tagpos - inner_pos;                                            b.children = new List<Block>();                                          b.children.Add(span);                                          break;                                      }                                    case MarkdownInHtmlMode.Block:                                  case MarkdownInHtmlMode.Deep:                                      {                                          // Scan the internal content                                          var bp = new BlockProcessor(m_markdown' mode == MarkdownInHtmlMode.Deep);                                          b.children = bp.ScanLines(input' inner_pos' tagpos - inner_pos);                                          break;                                      }                                    case MarkdownInHtmlMode.Off:                                      {                                          if (bHasUnsafeContent)                                          {                                              b.blockType = BlockType.unsafe_html;                                              b.contentEnd = position;                                          }                                          else                                          {                                              Block span = this.CreateBlock();                                              span.buf = input;                                              span.blockType = BlockType.html;                                              span.contentStart = inner_pos;                                              span.contentLen = tagpos - inner_pos;                                                b.children = new List<Block>();                                              b.children.Add(span);                                          }                                          break;                                      }                              }
Missing Default,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,MakeID,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.link:                          LinkInfo li = (LinkInfo)t.data;                          sb.Append(li.link_text);                          break;                  }
Missing Default,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Render,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          // Append encoded text                          m_Markdown.HtmlEncode(sb' str' t.startOffset' t.length);                          break;                        case TokenType.HtmlTag:                          // Append html as is                          var tag = str.Substring(t.startOffset' t.length);                          var mtag = reg.Match(tag).Groups[1].Value;                          var mtag_l = mtag.ToLower();                          if (mtag.StartsWith("/"))                          {                              while (tags.Count() > 0)                              {                                  var ptag = tags.Pop();                                  if (ptag.ToLower() == mtag_l)                                  {                                      Utils.SmartHtmlEncodeAmps(sb' str' t.startOffset' t.length);                                      break;                                  }                                  else                                  {                                      sb.Append("<" + ptag + ">");                                  }                              }                          }                          else                          {                              tags.Push("/" + mtag);                              Utils.SmartHtmlEncodeAmps(sb' str' t.startOffset' t.length);                          }                          break;                        case TokenType.Html:                      case TokenType.opening_mark:                      case TokenType.closing_mark:                      case TokenType.internal_mark:                          // Append html as is                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.br:                          sb.Append("<br />\n");                          break;                        case TokenType.open_em:                          sb.Append("<em>");                          break;                        case TokenType.close_em:                          sb.Append("</em>");                          break;                        case TokenType.open_strong:                          sb.Append("<strong>");                          break;                        case TokenType.close_strong:                          sb.Append("</strong>");                          break;                        case TokenType.code_span:                          sb.Append("<code>");                          m_Markdown.HtmlEncode(sb' str' t.startOffset' t.length);                          sb.Append("</code>");                          break;                        case TokenType.link:                          {                              LinkInfo li = (LinkInfo)t.data;                              var sf = new SpanFormatter(m_Markdown);                              sf.DisableLinks = true;                                li.def.RenderLink(m_Markdown' sb' sf.Format(li.link_text));                              break;                          }                        case TokenType.img:                          {                              LinkInfo li = (LinkInfo)t.data;                              li.def.RenderImg(m_Markdown' sb' li.link_text);                              break;                          }                        case TokenType.footnote:                          {                              FootnoteReference r = (FootnoteReference)t.data;                              sb.Append("<sup id=\"fnref:");                              sb.Append(r.id);                              sb.Append("\"><a href=\"#fn:");                              sb.Append(r.id);                              sb.Append("\" rel=\"footnote\">");                              sb.Append(r.index + 1);                              sb.Append("</a></sup>");                              break;                          }                        case TokenType.abbreviation:                          {                              Abbreviation a = (Abbreviation)t.data;                              sb.Append("<abbr");                              if (!String.IsNullOrEmpty(a.Title))                              {                                  sb.Append(" title=\"");                                  m_Markdown.HtmlEncode(sb' a.Title' 0' a.Title.Length);                                  sb.Append("\"");                              }                              sb.Append(">");                              m_Markdown.HtmlEncode(sb' a.Abbr' 0' a.Abbr.Length);                              sb.Append("</abbr>");                              break;                          }                  }
Missing Default,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,RenderPlain,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.HtmlTag:                          break;                        case TokenType.Html:                      case TokenType.opening_mark:                      case TokenType.closing_mark:                      case TokenType.internal_mark:                          break;                        case TokenType.br:                          break;                        case TokenType.open_em:                      case TokenType.close_em:                      case TokenType.open_strong:                      case TokenType.close_strong:                          break;                        case TokenType.code_span:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.link:                          {                              LinkInfo li = (LinkInfo)t.data;                              sb.Append(li.link_text);                              break;                          }                        case TokenType.img:                          {                              LinkInfo li = (LinkInfo)t.data;                              sb.Append(li.link_text);                              break;                          }                        case TokenType.footnote:                      case TokenType.abbreviation:                          break;                  }
Missing Default,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following switch statement is missing a default case: switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }
Missing Default,MarkdownDeep,SpanFormatter,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following switch statement is missing a default case: switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }
Missing Default,MarkdownDeep,TableSpec,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\TableSpec.cs,RenderRow,The following switch statement is missing a default case: switch (Columns[i])                      {                          case ColumnAlignment.Left:                              b.Append(" align=\"left\"");                              break;                            case ColumnAlignment.Right:                              b.Append(" align=\"right\"");                              break;                            case ColumnAlignment.Center:                              b.Append(" align=\"center\"");                              break;                      }
Missing Default,MarkdownDeep,Utils,C:\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,IsEscapableChar,The following switch statement is missing a default case: switch (ch)              {                  case '\\':                  case '`':                  case '*':                  case '_':                  case '{':                  case '}':                  case '[':                  case ']':                  case '(':                  case ')':                  case '>':       // Not in markdown documentation' but is in markdown.pl                  case '#':                  case '+':                  case '-':                  case '.':                  case '!':                      return true;                    case ':':                  case '|':                  case '=':       // Added for escaping Setext H1                  case '<':                      return ExtraMode;              }
