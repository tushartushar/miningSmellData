Implementation smell,Namespace,Class,File,Method,Description
Long Method,MarkdownDeep,Block,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,Render,The method has 191 lines of code.
Long Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The method has 260 lines of code.
Long Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The method has 272 lines of code.
Long Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,The method has 169 lines of code.
Long Method,MarkdownDeep,LinkDefinition,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,The method has 122 lines of code.
Long Method,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,Transform,The method has 112 lines of code.
Long Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Render,The method has 114 lines of code.
Long Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The method has 184 lines of code.
Long Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessLinkOrImageOrFootnote,The method has 126 lines of code.
Complex Method,MarkdownDeep,Block,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,Render,Cyclomatic complexity of the method is 36
Complex Method,MarkdownDeep,Block,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,RenderPlain,Cyclomatic complexity of the method is 13
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,Cyclomatic complexity of the method is 37
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,CollapseLines,Cyclomatic complexity of the method is 11
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,Cyclomatic complexity of the method is 46
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessMarkdownEnabledHtml,Cyclomatic complexity of the method is 13
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,Cyclomatic complexity of the method is 27
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,Cyclomatic complexity of the method is 14
Complex Method,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,HtmlTag,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,IsSafe,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,HtmlTag,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,Cyclomatic complexity of the method is 16
Complex Method,MarkdownDeep,LinkDefinition,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,Cyclomatic complexity of the method is 22
Complex Method,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,Transform,Cyclomatic complexity of the method is 13
Complex Method,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,OnQualifyUrl,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,HtmlEncodeAndConvertTabsToSpaces,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,MakeID,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Render,Cyclomatic complexity of the method is 19
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,RenderPlain,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,Cyclomatic complexity of the method is 25
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,CreateEmphasisMark,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,Cyclomatic complexity of the method is 10
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,Cyclomatic complexity of the method is 17
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessAutoLink,Cyclomatic complexity of the method is 9
Complex Method,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessLinkOrImageOrFootnote,Cyclomatic complexity of the method is 22
Complex Method,MarkdownDeep,TableSpec,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\TableSpec.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipHtmlEntity,Cyclomatic complexity of the method is 13
Complex Method,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SmartHtmlEncodeAmpsAndAngles,Cyclomatic complexity of the method is 8
Long Statement,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The length of the statement  "                                if (prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd) " is 144.
Long Statement,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The length of the statement  "                    (lines[i - 1].blockType == BlockType.p || lines[i - 1].blockType == BlockType.ul_li || lines[i - 1].blockType == BlockType.ol_li)) " is 130.
Long Statement,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The length of the statement  "                while (end_of_li < lines.Count - 1 && lines[end_of_li + 1].blockType != BlockType.ul_li && lines[end_of_li + 1].blockType != BlockType.ol_li) " is 141.
Complex Conditional,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The conditional expression  "prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The conditional expression  "(ch == '*' || ch == '+' || ch == '-') && IsLineSpace(CharAtOffset(1))"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanHtml,The conditional expression  "!bHeadBlock && !tag.closing && m_markdown.ExtraMode && !bHasUnsafeContent"  is complex.
Complex Conditional,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,BuildList,The conditional expression  "(lines[i].blockType == BlockType.p) &&                      (lines[i - 1].blockType == BlockType.p || lines[i - 1].blockType == BlockType.ul_li || lines[i - 1].blockType == BlockType.ol_li)"  is complex.
Complex Conditional,MarkdownDeep,HtmlTag,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,The conditional expression  "!p.eof && !char.IsWhiteSpace(p.current) && p.current != '>' && p.current != '/'"  is complex.
Complex Conditional,MarkdownDeep,LinkDefinition,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\LinkDefinition.cs,ParseLinkTarget,The conditional expression  "(id == null && p.current != ')') ||                              (id != null && !p.eol)"  is complex.
Complex Conditional,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,OnPrepareLink,The conditional expression  "(NewWindowForExternalLinks && Utils.IsUrlFullyQualified(url)) ||                   (NewWindowForLocalLinks && !Utils.IsUrlFullyQualified(url))"  is complex.
Complex Conditional,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,MakeID,The conditional expression  "char.IsLetterOrDigit(ch) || ch == '_' || ch == '-' || ch == '.'"  is complex.
Complex Conditional,MarkdownDeep,StringScanner,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\StringScanner.cs,SkipFootnoteID,The conditional expression  "char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == ':' || ch == '.' || ch == ' '"  is complex.
Complex Conditional,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,ParseIdentifier,The conditional expression  "pos < str.Length && (char.IsDigit(str[pos]) || char.IsLetter(str[pos]) || str[pos] == '_')"  is complex.
Complex Conditional,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipHtmlEntity,The conditional expression  "!(char.IsDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F'))"  is complex.
Complex Conditional,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,IsValidHtmlID,The conditional expression  "Char.IsLetterOrDigit(ch) || ch == '_' || ch == '-' || ch == ':' || ch == '.'"  is complex.
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: level = 6;
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: level > 6
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: b.contentStart = line_start + 4;
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: leadingSpaces >= 4
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: tabPos >= 0 && tabPos - line_start < 4
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: SkipForward(2);
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: eol && count >= 3
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: SkipForward(2);
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: SkipForward(2);
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,EvaluateLine,The following statement contains a magic number: SkipForward(2);
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: strFence.Length < 3
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: endCode -= 2;
Magic Number,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessFencedCodeBlock,The following statement contains a magic number: input[endCode - 1] == '\r' && input[endCode - 2] == '\n'
Magic Number,MarkdownDeep,HtmlTag,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\HtmlTag.cs,ParseHelper,The following statement contains a magic number: p.SkipForward(3);
Magic Number,MarkdownDeep,Markdown,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\MardownDeep.cs,HtmlEncodeAndConvertTabsToSpaces,The following statement contains a magic number: switch (ch)                  {                      case '\t':                          dest.Append(' ');                          pos++;                          while ((pos % 4) != 0)                          {                              dest.Append(' ');                              pos++;                          }                          pos--;      // Compensate for the pos++ below                          break;                        case '\r':                      case '\n':                          dest.Append('\n');                          pos = 0;                          p.SkipEol();                          continue;                        case '&':                          dest.Append("&amp;");                          break;                        case '<':                          dest.Append("&lt;");                          break;                        case '>':                          dest.Append("&gt;");                          break;                        case '\"':                          dest.Append("&quot;");                          break;                        default:                          dest.Append(ch);                          break;                  }
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following statement contains a magic number: switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: style = (style % 2) == 1 ? 1 : 2;
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: style = (style % 2) == 1 ? 1 : 2;
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks,The following statement contains a magic number: style >= 3
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: opening_mark.length < 2
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: closing_mark.length < 2
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: SplitMarkToken(tokens' marks' opening_mark' 2);
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: opening_mark.length > 2
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: closing_mark = SplitMarkToken(tokens' marks' closing_mark' closing_mark.length - 2);
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ResolveEmphasisMarks_classic,The following statement contains a magic number: closing_mark.length > 2
Magic Number,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,ProcessAutoLink,The following statement contains a magic number: link_text = url.Substring(7);
Magic Number,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,HtmlRandomize,The following statement contains a magic number: int x = r.Next() % 100;
Magic Number,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,HtmlRandomize,The following statement contains a magic number: x > 90 && ch != '@'
Magic Number,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,SkipEscapableChar,The following statement contains a magic number: p.SkipForward(2);
Magic Number,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,StripHtmlID,The following statement contains a magic number: int startId = pos + 2;
Missing Default,MarkdownDeep,Block,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Block.cs,RenderPlain,The following switch statement is missing a default case: switch (blockType)              {                  case BlockType.Blank:                      return;                    case BlockType.p:                  case BlockType.span:                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" ");                      break;                    case BlockType.h1:                  case BlockType.h2:                  case BlockType.h3:                  case BlockType.h4:                  case BlockType.h5:                  case BlockType.h6:                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" - ");                      break;                    case BlockType.ol_li:                  case BlockType.ul_li:                      b.Append("* ");                      m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      b.Append(" ");                      break;                    case BlockType.dd:                      if (children != null)                      {                          b.Append("\n");                          RenderChildrenPlain(m' b);                      }                      else                          m.SpanFormatter.FormatPlain(b' buf' contentStart' contentLen);                      break;                    case BlockType.dt:                      {                          if (children == null)                          {                              foreach (var l in Content.Split('\n'))                              {                                  var str = l.Trim();                                  m.SpanFormatter.FormatPlain(b' str' 0' str.Length);                              }                          }                          else                          {                              RenderChildrenPlain(m' b);                          }                          break;                      }                    case BlockType.dl:                      RenderChildrenPlain(m' b);                      return;                    case BlockType.codeblock:                      foreach (var line in children)                      {                          b.Append(line.buf' line.contentStart' line.contentLen);                          b.Append(" ");                      }                      return;                    case BlockType.quote:                  case BlockType.li:                  case BlockType.ol:                  case BlockType.ul:                  case BlockType.HtmlTag:                      RenderChildrenPlain(m' b);                      return;              }
Missing Default,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ScanLines,The following switch statement is missing a default case: switch (currentBlockType)                          {                              case BlockType.Blank:                                  lines.Add(b);                                  break;                                case BlockType.p:                              case BlockType.quote:                                  var prevline = lines.Last();                                  if (prevline.blockType == BlockType.Blank || m_parentType == BlockType.ol_li || m_parentType == BlockType.ul_li || m_parentType == BlockType.dd)                                  {                                      // List starting after blank line after paragraph or quote                                      CollapseLines(blocks' lines);                                      lines.Add(b);                                  }                                  else                                  {                                      // List's can't start in middle of a paragraph                                      b.RevertToPlain();                                      lines.Add(b);                                  }                                  break;                                case BlockType.ol_li:                              case BlockType.ul_li:                                  if (b.blockType != BlockType.ol_li && b.blockType != BlockType.ul_li)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.dd:                              case BlockType.footnote:                                  if (b.blockType != currentBlockType)                                  {                                      CollapseLines(blocks' lines);                                  }                                  lines.Add(b);                                  break;                                case BlockType.indent:                                  // List after code block                                  CollapseLines(blocks' lines);                                  lines.Add(b);                                  break;                          }
Missing Default,MarkdownDeep,BlockProcessor,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\BlockProcessor.cs,ProcessMarkdownEnabledHtml,The following switch statement is missing a default case: switch (mode)                              {                                  case MarkdownInHtmlMode.Span:                                      {                                          Block span = this.CreateBlock();                                          span.buf = input;                                          span.blockType = BlockType.span;                                          span.contentStart = inner_pos;                                          span.contentLen = tagpos - inner_pos;                                            b.children = new List<Block>();                                          b.children.Add(span);                                          break;                                      }                                    case MarkdownInHtmlMode.Block:                                  case MarkdownInHtmlMode.Deep:                                      {                                          // Scan the internal content                                          var bp = new BlockProcessor(m_markdown' mode == MarkdownInHtmlMode.Deep);                                          b.children = bp.ScanLines(input' inner_pos' tagpos - inner_pos);                                          break;                                      }                                    case MarkdownInHtmlMode.Off:                                      {                                          if (bHasUnsafeContent)                                          {                                              b.blockType = BlockType.unsafe_html;                                              b.contentEnd = position;                                          }                                          else                                          {                                              Block span = this.CreateBlock();                                              span.buf = input;                                              span.blockType = BlockType.html;                                              span.contentStart = inner_pos;                                              span.contentLen = tagpos - inner_pos;                                                b.children = new List<Block>();                                              b.children.Add(span);                                          }                                          break;                                      }                              }
Missing Default,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,MakeID,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.link:                          LinkInfo li = (LinkInfo)t.data;                          sb.Append(li.link_text);                          break;                  }
Missing Default,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Render,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          // Append encoded text                          m_Markdown.HtmlEncode(sb' str' t.startOffset' t.length);                          break;                        case TokenType.HtmlTag:                          // Append html as is                          var tag = str.Substring(t.startOffset' t.length);                          var mtag = reg.Match(tag).Groups[1].Value;                          var mtag_l = mtag.ToLower();                          if (mtag.StartsWith("/"))                          {                              while (tags.Count() > 0)                              {                                  var ptag = tags.Pop();                                  if (ptag.ToLower() == mtag_l)                                  {                                      Utils.SmartHtmlEncodeAmps(sb' str' t.startOffset' t.length);                                      break;                                  }                                  else                                  {                                      sb.Append("<" + ptag + ">");                                  }                              }                          }                          else                          {                              tags.Push("/" + mtag);                              Utils.SmartHtmlEncodeAmps(sb' str' t.startOffset' t.length);                          }                          break;                        case TokenType.Html:                      case TokenType.opening_mark:                      case TokenType.closing_mark:                      case TokenType.internal_mark:                          // Append html as is                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.br:                          sb.Append("<br />\n");                          break;                        case TokenType.open_em:                          sb.Append("<em>");                          break;                        case TokenType.close_em:                          sb.Append("</em>");                          break;                        case TokenType.open_strong:                          sb.Append("<strong>");                          break;                        case TokenType.close_strong:                          sb.Append("</strong>");                          break;                        case TokenType.code_span:                          sb.Append("<code>");                          m_Markdown.HtmlEncode(sb' str' t.startOffset' t.length);                          sb.Append("</code>");                          break;                        case TokenType.link:                          {                              LinkInfo li = (LinkInfo)t.data;                              var sf = new SpanFormatter(m_Markdown);                              sf.DisableLinks = true;                                li.def.RenderLink(m_Markdown' sb' sf.Format(li.link_text));                              break;                          }                        case TokenType.img:                          {                              LinkInfo li = (LinkInfo)t.data;                              li.def.RenderImg(m_Markdown' sb' li.link_text);                              break;                          }                        case TokenType.footnote:                          {                              FootnoteReference r = (FootnoteReference)t.data;                              sb.Append("<sup id=\"fnref:");                              sb.Append(r.id);                              sb.Append("\"><a href=\"#fn:");                              sb.Append(r.id);                              sb.Append("\" rel=\"footnote\">");                              sb.Append(r.index + 1);                              sb.Append("</a></sup>");                              break;                          }                        case TokenType.abbreviation:                          {                              Abbreviation a = (Abbreviation)t.data;                              sb.Append("<abbr");                              if (!String.IsNullOrEmpty(a.Title))                              {                                  sb.Append(" title=\"");                                  m_Markdown.HtmlEncode(sb' a.Title' 0' a.Title.Length);                                  sb.Append("\"");                              }                              sb.Append(">");                              m_Markdown.HtmlEncode(sb' a.Abbr' 0' a.Abbr.Length);                              sb.Append("</abbr>");                              break;                          }                  }
Missing Default,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,RenderPlain,The following switch statement is missing a default case: switch (t.type)                  {                      case TokenType.Text:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.HtmlTag:                          break;                        case TokenType.Html:                      case TokenType.opening_mark:                      case TokenType.closing_mark:                      case TokenType.internal_mark:                          break;                        case TokenType.br:                          break;                        case TokenType.open_em:                      case TokenType.close_em:                      case TokenType.open_strong:                      case TokenType.close_strong:                          break;                        case TokenType.code_span:                          sb.Append(str' t.startOffset' t.length);                          break;                        case TokenType.link:                          {                              LinkInfo li = (LinkInfo)t.data;                              sb.Append(li.link_text);                              break;                          }                        case TokenType.img:                          {                              LinkInfo li = (LinkInfo)t.data;                              sb.Append(li.link_text);                              break;                          }                        case TokenType.footnote:                      case TokenType.abbreviation:                          break;                  }
Missing Default,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following switch statement is missing a default case: switch (current)                  {                      case '*':                      case '_':                            // Create emphasis mark                          token = CreateEmphasisMark();                            if (token != null)                          {                              // Store marks in a separate list the we'll resolve later                              switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }                          }                          break;                        case '`':                          token = ProcessCodeSpan();                          break;                        case '[':                      case '!':                          {                              // Process link reference                              int linkpos = position;                              token = ProcessLinkOrImageOrFootnote();                                // Rewind if invalid syntax                              // (the '[' or '!' will be treated as a regular character and processed below)                              if (token == null)                                  position = linkpos;                              break;                          }                        case '<':                          {                              // Is it a valid html tag?                              int save = position;                              HtmlTag tag = HtmlTag.Parse(this);                              if (tag != null)                              {                                  if (!m_Markdown.SafeMode || tag.IsSafe())                                  {                                      // Yes' create a token for it                                      token = CreateToken(TokenType.HtmlTag' save' position - save);                                  }                                  else                                  {                                      // No' rewrite and encode it                                      position = save;                                  }                              }                              else                              {                                  // No' rewind and check if it's a valid autolink eg: <google.com>                                  position = save;                                  token = ProcessAutoLink();                                    if (token == null)                                      position = save;                              }                              break;                          }                        case '&':                          {                              // Is it a valid html entity                              int save = position;                              string unused = null;                              if (SkipHtmlEntity(ref unused))                              {                                  // Yes' create a token for it                                  token = CreateToken(TokenType.Html' save' position - save);                              }                                break;                          }                        case ' ':                          {                              // Check for double space at end of a line                              if (CharAtOffset(1) == ' ' && IsLineEnd(CharAtOffset(2)))                              {                                  // Yes' skip it                                  SkipForward(2);                                    // Don't put br's at the end of a paragraph                                  if (!eof)                                  {                                      SkipEol();                                      token = CreateToken(TokenType.br' end_text_token' 0);                                  }                              }                              break;                          }                        case '\\':                          {                              // Special handling for escaping <autolinks>                              /*                              if (CharAtOffset(1) == '<')                              {                                  // Is it an autolink?                                  int savepos = position;                                  SkipForward(1);                                  bool AutoLink = ProcessAutoLink() != null;                                  position = savepos;                                    if (AutoLink)                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              else                               */                              {                                  // Check followed by an escapable character                                  if (Utils.IsEscapableChar(CharAtOffset(1)' ExtraMode))                                  {                                      token = CreateToken(TokenType.Text' position + 1' 1);                                      SkipForward(2);                                  }                              }                              break;                          }                  }
Missing Default,MarkdownDeep,SpanFormatter,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\SpanFormatter.cs,Tokenize,The following switch statement is missing a default case: switch (token.type)                              {                                  case TokenType.internal_mark:                                  case TokenType.opening_mark:                                  case TokenType.closing_mark:                                      if (emphasis_marks == null)                                      {                                          emphasis_marks = new List<Token>();                                      }                                      emphasis_marks.Add(token);                                      break;                              }
Missing Default,MarkdownDeep,TableSpec,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\TableSpec.cs,RenderRow,The following switch statement is missing a default case: switch (Columns[i])                      {                          case ColumnAlignment.Left:                              b.Append(" align=\"left\"");                              break;                            case ColumnAlignment.Right:                              b.Append(" align=\"right\"");                              break;                            case ColumnAlignment.Center:                              b.Append(" align=\"center\"");                              break;                      }
Missing Default,MarkdownDeep,Utils,D:\research\architectureSmells\repos\voat_voat\src\external\Source\toptensoftware\MarkdownDeep\Utils.cs,IsEscapableChar,The following switch statement is missing a default case: switch (ch)              {                  case '\\':                  case '`':                  case '*':                  case '_':                  case '{':                  case '}':                  case '[':                  case ']':                  case '(':                  case ')':                  case '>':       // Not in markdown documentation' but is in markdown.pl                  case '#':                  case '+':                  case '-':                  case '.':                  case '!':                      return true;                    case ':':                  case '|':                  case '=':       // Added for escaping Setext H1                  case '<':                      return ExtraMode;              }
