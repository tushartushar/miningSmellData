Implementation smell,Namespace,Class,File,Method,Description
Long Method,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The method has 669 lines of code.
Complex Method,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,Cyclomatic complexity of the method is 76
Complex Method,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,Cyclomatic complexity of the method is 29
Complex Method,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,Get,Cyclomatic complexity of the method is 24
Long Statement,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The length of the statement  "		Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"); " is 128.
Long Statement,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,IsValidEmail,The length of the statement  "	// Regex regex = new Regex(@"^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$"' RegexOptions.Compiled | RegexOptions.IgnoreCase); " is 986.
Long Statement,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,EstimationToString,The length of the statement  "	return estimation >= 0 ? estimation.ToString () : ResourceStrings.GetGlobalResource (GlobalResources.SharedResources' "Empty"' "Empty").ToLower (); " is 147.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*head([^>])*>"' "<head>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 150.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<( )*(/)( )*head( )*>)"' "</head>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 157.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<head>).*(</head>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 156.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*script([^>])*>"' "<script>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 154.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<( )*(/)( )*script( )*>)"' "</script>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 161.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<script>).*(</script>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 160.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*style([^>])*>"' "<style>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 152.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<( )*(/)( )*style( )*>)"' "</style>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 159.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(<style>).*(</style>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 158.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*td([^>])*>"' "\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 144.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*br( )*>"' "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*br([^>])*>"' "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 146.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*li( )*>"' "\n" + " * "' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 149.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*div([^>])*>"' "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 147.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*tr([^>])*>"' "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 146.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<( )*p([^>])*>"' "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 145.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<[^>]*>"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 144.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' " "' " "' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' " * "' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 131.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' "<"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' ">"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' "(tm)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 132.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "/"' "/"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "<"' "<"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' ">"' ">"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 129.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' "(c)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 131.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "?"' "(r)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 131.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "&(.{2'6});"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 147.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	// Prepare first to remove any whitespaces inbetween the escaped characters and remove redundant tabs inbetween linebreaks " is 122.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)( )+(\r)"' "\n\r" + "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 152.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\t)( )+(\t)"' "\t" + "\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 148.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\t)( )+(\r)"' "\t" + "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 150.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)( )+(\t)"' "\n\r" + "\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 150.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)(\t)+(\r)"' "\n\r" + "\n\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 153.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML,The length of the statement  "	result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)(\t)+"' "\n\r" + "\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 147.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*head([^>])*>"' "<head>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 151.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"(<( )*(/)( )*head( )*>)"' "</head>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 158.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(<head>).*(</head>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 156.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*script([^>])*>"' "<script>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 155.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"(<( )*(/)( )*script( )*>)"' "</script>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 162.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"(<script>).*(</script>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 161.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*style([^>])*>"' "<style>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 153.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"(<( )*(/)( )*style( )*>)"' "</style>"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 160.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(<style>).*(</style>)"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 158.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*td([^>])*>"' "\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 145.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*br( )*>"' "\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 142.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*li( )*>"' "\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 142.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*div([^>])*>"' "\r\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 148.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*tr([^>])*>"' "\r\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 147.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<( )*p([^>])*>"' "\r\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 146.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"<[^>]*>"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 145.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @" "' " "' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 130.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&bull;"' " * "' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 137.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&lsaquo;"' "<"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 137.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&rsaquo;"' ">"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 137.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&trade;"' "(tm)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 139.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&frasl;"' "/"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 136.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&lt;"' "<"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 133.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&gt;"' ">"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 133.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&copy;"' "(c)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 137.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&reg;"' "(r)"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 136.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' @"&(.{2'6});"' string.Empty' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 148.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)( )+(\r)"' "\r\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\t)( )+(\t)"' "\t\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\t)( )+(\r)"' "\t\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)( )+(\t)"' "\r\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)(\t)+(\r)"' "\r\r"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 144.
Long Statement,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,StripHTML2,The length of the statement  "		result = System.Text.RegularExpressions.Regex.Replace (result' "(\r)(\t)+"' "\r\t"' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 140.
Empty Catch Block,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,Is,The method has an empty catch block.
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (emailLength > 254) {  	this.ResultInfo.Add (@" Email is too long.  The maximum total length of a reverse-path or forward-path is 256 characters (including the punctuation and element separators) (http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3) ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: foreach (String element in dotArray) {  	string working_element = element;  	// for use in our for loop' can't work on a foreach target SCO-04152011  	// Remove any leading or trailing FWS  	Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  	String new_element = repRegex.Replace (working_element' string.Empty);  	if (!working_element.Equals (new_element)) {  		// FWS is unlikely in the real world  		this.ResultInfo.Add (@"                 Folding White Space  		        local-part = dot-atom / quoted-string / obs-local-part 		        obs-local-part = word *(""."" word) (http://tools.ietf.org/html/rfc5322#section-3.4.1)             ");  	}  	working_element = new_element;  	// version 2.3: Warning condition added  	int elementLength = new_element.Length;  	if (elementLength == 0) {  		// Can't have empty element (consecutive dots or  		// dots at the start or end)  		this.ResultInfo.Add (@" 				Can't have empty element (consecutive dots or 				dots at the start or end)                 (http://tools.ietf.org/html/rfc5322#section-3.4.1)             ");  		return false;  	}  	// revision 1.15: Speed up the test and get rid of  	// "uninitialized string offset" notices from PHP  	// We need to remove any valid comments (i.e. those at the start or  	// end of the element)  	if (working_element.Substring (0) == "(") {  		// Comments are unlikely in the real world  		// return_status = IsEMailResult.ISEMAIL_COMMENTS;  		// version 2.0: Warning condition added  		int indexBrace = working_element.IndexOf (")");  		if (indexBrace != -1) {  			Regex pregMatch = new Regex ("(?<!\\\\)[\\(\\)]");  			if (pregMatch.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  				// Illegal characters in comment  				this.ResultInfo.Add (@" 				            Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  			elementLength = working_element.Length;  		}  	}  	if (working_element.Substring (elementLength - 1) == ")") {  		// Comments are unlikely in the real world  		// return_status = IsEMailResult.ISEMAIL_COMMENTS;  		// version 2.0: Warning condition added  		int indexBrace = working_element.LastIndexOf ("(");  		if (indexBrace != -1) {  			Regex pregMatch = new Regex ("(?<!\\\\)(?:[\\(\\)])");  			if (pregMatch.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  				// Illegal characters in comment						  				this.ResultInfo.Add (@" 				            Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (0' indexBrace);  			elementLength = working_element.Length;  		}  	}  	// Remove any remaining leading or trailing FWS around the element  	// (having removed any comments)  	Regex fwsRegex = new Regex ("^" + FWS + "|" + FWS + "$");  	new_element = fwsRegex.Replace (working_element' string.Empty);  	//// FWS is unlikely in the real world  	//if (!working_element.equals(new_element))  	//    return_status = IsEMailResult.ISEMAIL_FWS;  	working_element = new_element;  	// version 2.0: Warning condition added  	// What's left counts towards the maximum length for this part  	if (partLength > 0)  		partLength++;  	// for the dot  	partLength += working_element.Length;  	// Each dot-delimited component can be an atom or a quoted string  	// (because of the obs-local-part provision)  	Regex quotRegex = new Regex ("(?s)^\"(?:.)*\"$");  	if (quotRegex.Matches (working_element).Count > 0) {  		// Quoted-string tests:  		// Quoted string is unlikely in the real world  		// return_status = IsEMailResult.ISEMAIL_QUOTEDSTRING;  		// version 2.0: Warning condition added  		// Remove any FWS  		// A warning condition' but we've already raised  		// ISEMAIL_QUOTEDSTRING  		Regex newRepRegex = new Regex ("(?<!\\\\)" + FWS);  		working_element = newRepRegex.Replace (working_element' string.Empty);  		// My regular expression skills aren't up to distinguishing  		// between \" \\" \\\" \\\\" etc.  		// So remove all \\ from the string first...  		Regex slashRegex = new Regex ("\\\\\\\\");  		working_element = slashRegex.Replace (working_element' string.Empty);  		Regex quot2Regex = new Regex ("(?<!\\\\|^)[\"\\r\\n\\x00](?!$)|\\\\\"$|\"\"");  		if (quot2Regex.Matches (working_element).Count > 0) {  			// "' CR' LF and NUL must be escaped  			// version 2.0: allow ""@example.com because it's  			// technically valid					  			this.ResultInfo.Add (@" 				            ""' CR' LF and NUL must be escaped                         ");  			return false;  		}  	} else {  		// Unquoted string tests:  		//  		// Period (".") may...appear' but may not be used to start or  		// end the  		// local part' nor may two or more consecutive periods appear.  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (string.IsNullOrEmpty (working_element)) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				        A zero-length element implies a period at the beginning or 				        end of the local part' or two periods together. Either way it's not 				        allowed.                     ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex quot3Regex = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]");  		if (quot3Regex.Matches (working_element).Count > 0) {  			// These characters must be in a quoted string  			this.ResultInfo.Add (@" 				         Any ASCII graphic (printing) character other than the 				         at-sign (""@"")' backslash' double quote' comma' or square 				         brackets may appear without quoting. If any of that list of excluded 				         characters are to appear' they must be quoted 				         (http://tools.ietf.org/html/rfc3696#section-3)                         ");  			return false;  		}  		//Regex quot4Regex = new Regex("^\\w+");  		//if (quot4Regex.Matches(working_element).Count == 0)   		//{  		//    // First character is an odd one  		//    return_status = IsEMailResult.ISEMAIL_UNLIKELYINITIAL;  		//}  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (working_element.Substring (elementLength - 1) == ")") {  	// Comments are unlikely in the real world  	// return_status = IsEMailResult.ISEMAIL_COMMENTS;  	// version 2.0: Warning condition added  	int indexBrace = working_element.LastIndexOf ("(");  	if (indexBrace != -1) {  		Regex pregMatch = new Regex ("(?<!\\\\)(?:[\\(\\)])");  		if (pregMatch.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  			// Illegal characters in comment						  			this.ResultInfo.Add (@" 				            Illegal characters in comment                         ");  			return false;  		}  		working_element = working_element.Substring (0' indexBrace);  		elementLength = working_element.Length;  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (indexBrace != -1) {  	Regex pregMatch = new Regex ("(?<!\\\\)(?:[\\(\\)])");  	if (pregMatch.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  		// Illegal characters in comment						  		this.ResultInfo.Add (@" 				            Illegal characters in comment                         ");  		return false;  	}  	working_element = working_element.Substring (0' indexBrace);  	elementLength = working_element.Length;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (pregMatch.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  	// Illegal characters in comment						  	this.ResultInfo.Add (@" 				            Illegal characters in comment                         ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (partLength > 64) {  	// Local part must be 64 characters or less  	this.ResultInfo.Add (@" 				Local part must be 64 characters or less             ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (new Regex ("^\\[(.)+]$").Matches (domain).Count == 1) {  	//// It's an address-literal  	//// Quoted string is unlikely in the real world  	//return_status = IsEMailResult.ISEMAIL_ADDRESSLITERAL;  	// version 2.0: Warning condition added  	String addressLiteral = domain.Substring (1' domain.Length - 2);  	String IPv6;  	int groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  	String colon = ":";  	// Revision 2.7: Daniel Marschall's new  	// IPv6 testing strategy  	String double_colon = "::";  	String IPv6tag = "IPv6:";  	// Extract IPv4 part from the end of the address-literal (if there  	// is one)  	Regex splitRegex = new Regex ("\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$");  	MatchCollection matchesIP1 = splitRegex.Matches (addressLiteral);  	if (matchesIP1.Count > 0) {  		int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  		if (index == 0) {  			// Nothing there except a valid IPv4 address' so...  			return true;  			// version 2.0: return warning if one is set  		} else {  			// - // Assume it's an attempt at a mixed address (IPv6 +  			// IPv4)  			// - if ($addressLiteral[$index - 1] !== ':') return  			// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  			// preceding IPv4 address must be ':'  			// revision 2.1: new IPv6 testing strategy  			if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  				// RFC5321 section 4.1.3		  				this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  				return false;  			}  			// -  			// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  			// $index - 6);  			// - $groupMax = 6;  			// revision 2.1: new IPv6 testing strategy  			IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  			// Convert IPv4 part to IPv6 format  		}  	} else {  		// It must be an attempt at pure IPv6  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		IPv6 = addressLiteral.Substring (5);  		// - $groupMax = 8;  		// revision 2.1: new IPv6 testing strategy  	}  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	Regex split2Regex = new Regex (colon);  	string[] matchesIP = split2Regex.Split (IPv6);  	int groupCount = matchesIP.Length;  	int currIndex = IPv6.IndexOf (double_colon);  	if (currIndex == -1) {  		// We need exactly the right number of groups  		if (groupCount != groupMax) {  			// RFC5321 section 4.1.3  			this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  	} else {  		if (currIndex != IPv6.LastIndexOf (double_colon)) {  			// More than one '::'  			this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  			groupMax++;  			// RFC 4291 allows :: at the start or end of an  		}  		// address with 7 other groups in addition  		if (groupCount > groupMax) {  			// Too many IPv6 groups in address  			this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		if (groupCount == groupMax) {  			// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  			// & 5952  			this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  		}  	}  	// Check for single : at start and end of address  	// Revision 2.7: Daniel Marschall's new IPv6 testing strategy  	if (IPv6.StartsWith (colon) && (!IPv6.StartsWith (double_colon))) {  		// Address starts with a single colon  		this.ResultInfo.Add (@"                     IPV6 must start with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (IPv6.EndsWith (colon) && (!IPv6.EndsWith (double_colon))) {  		// Address ends with a single colon  		this.ResultInfo.Add (@"                     IPV6 must end with a single colon 				    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// Check for unmatched characters  	foreach (String s in matchesIP) {  		Regex goodStuff = new Regex ("^[0-9A-Fa-f]{0'4}$");  		if (goodStuff.Matches (s).Count == 0) {  			this.ResultInfo.Add (@"                     IPV6 address contains bad characters 				    RFC5321 section 4.1.3	                         ");  			return false;  		}  	}  	// It's a valid IPv6 address' so...  	return true;  	// revision 2.1: bug fix: now correctly return warning status  } else {  	// It's a domain name...  	// The syntax of a legal Internet host name was specified in RFC-952  	// One aspect of host name syntax is hereby changed: the  	// restriction on the first character is relaxed to allow either a  	// letter or a digit.  	// (http://tools.ietf.org/html/rfc1123#section-2.1)  	//  	// NB RFC 1123 updates RFC 1035' but this is not currently apparent  	// from reading RFC 1035.  	//  	// Most common applications' including email and the Web' will  	// generally not  	// permit...escaped strings  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// the better strategy has now become to make the  	// "at least one period" test'  	// to verify LDH conformance (including verification that the  	// apparent TLD name  	// is not all-numeric)  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Characters outside the set of alphabetic characters' digits' and  	// hyphen MUST NOT appear in domain name  	// labels for SMTP clients or servers  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	//  	// RFC5321 precludes the use of a trailing dot in a domain name for  	// SMTP purposes  	// (http://tools.ietf.org/html/rfc5321#section-4.1.2)  	Regex split2Regex = new Regex ("(?m)\\.(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))");  	dotArray = split2Regex.Split (domain);  	partLength = 0;  	// Since we use 'element' after the foreach  	// loop let's make sure it has a value  	String lastElement = "";  	// revision 1.13: Line above added because PHPLint now checks for  	// Definitely Assigned Variables  	if (dotArray.Length == 1) {  		this.ResultInfo.Add (@"The mail host probably isn't a TLD");  	}  	// version 2.0: downgraded to a warning  	foreach (String element in dotArray) {  		string working_element = element;  		lastElement = element;  		// Remove any leading or trailing FWS  		Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  		String new_element = newReg.Replace (working_element' string.Empty);  		if (!element.Equals (new_element)) {  			this.ResultInfo.Add (@"FWS is unlikely in the real world");  		}  		working_element = new_element;  		// version 2.0: Warning condition added  		int elementLength = working_element.Length;  		// Each dot-delimited component must be of type atext  		// A zero-length element implies a period at the beginning or  		// end of the  		// local part' or two periods together. Either way it's not  		// allowed.  		if (elementLength == 0) {  			// Dots in wrong place  			this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  			return false;  		}  		// revision 1.15: Speed up the test and get rid of  		// "uninitialized string offset" notices from PHP  		// Then we need to remove all valid comments (i.e. those at the  		// start or end of the element  		if (working_element.Substring (0' 1) == "(") {  			this.ResultInfo.Add (@"Comments are unlikely in the real world");  			// version 2.0: Warning condition added  			int indexBrace = working_element.IndexOf (")");  			if (indexBrace != -1) {  				Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  				if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  				elementLength = working_element.Length;  			}  		}  		if (working_element.Substring (elementLength - 1' 1) == ")") {  			// Comments are unlikely in the real world  			// return_status = IsEMailResult.ISEMAIL_COMMENTS;  			// version 2.0: Warning condition added  			int indexBrace = working_element.LastIndexOf ("(");  			if (indexBrace != -1) {  				Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  				if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  					// revision 1.17: Fixed name of constant (also  					// spotted by turboflash - thanks!)  					// Illegal characters in comment  					this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  					return false;  				}  				working_element = working_element.Substring (0' indexBrace);  				elementLength = working_element.Length;  			}  		}  		// Remove any leading or trailing FWS around the element (inside  		// any comments)  		Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  		new_element = repRegex.Replace (working_element' string.Empty);  		//if (!element.equals(new_element))   		//{  		//    // FWS is unlikely in the real world  		//    return_status = IsEMailResult.ISEMAIL_FWS;  		//}  		working_element = new_element;  		// version 2.0: Warning condition added  		// What's left counts towards the maximum length for this part  		if (partLength > 0) {  			partLength++;  			// for the dot  		}  		partLength += working_element.Length;  		// The DNS defines domain name syntax very generally -- a  		// string of labels each containing up to 63 8-bit octets'  		// separated by dots' and with a maximum total of 255  		// octets.  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		if (elementLength > 63) {  			// Label must be 63 characters or less  			this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  			return false;  		}  		// Any ASCII graphic (printing) character other than the  		// at-sign ("@")' backslash' double quote' comma' or square  		// brackets may  		// appear without quoting. If any of that list of excluded  		// characters  		// are to appear' they must be quoted  		// (http://tools.ietf.org/html/rfc3696#section-3)  		//  		// If the hyphen is used' it is not permitted to appear at  		// either the beginning or end of a label.  		// (http://tools.ietf.org/html/rfc3696#section-2)  		//  		// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  		// ;' @' \' comma' period' "  		Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  		if (badChars.Matches (working_element).Count > 0) {  			// Illegal character in domain name  			this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  			return false;  		}  	}  	if (partLength > 255) {  		// Domain part must be 255 characters or less  		// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  		this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	Regex foo = new Regex ("^[0-9]+$");  	if (foo.Matches (lastElement).Count > 0) {  		this.ResultInfo.Add (@"TLD probably isn't all-numeric                 (http://www.apps.ietf.org/rfc/rfc3696.html#sec-2)                 ");  		// version 2.0: Downgraded to a warning  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (matchesIP1.Count > 0) {  	int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  	if (index == 0) {  		// Nothing there except a valid IPv4 address' so...  		return true;  		// version 2.0: return warning if one is set  	} else {  		// - // Assume it's an attempt at a mixed address (IPv6 +  		// IPv4)  		// - if ($addressLiteral[$index - 1] !== ':') return  		// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  		// preceding IPv4 address must be ':'  		// revision 2.1: new IPv6 testing strategy  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3		  			this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		// -  		// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  		// $index - 6);  		// - $groupMax = 6;  		// revision 2.1: new IPv6 testing strategy  		IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  		// Convert IPv4 part to IPv6 format  	}  } else {  	// It must be an attempt at pure IPv6  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	IPv6 = addressLiteral.Substring (5);  	// - $groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (matchesIP1.Count > 0) {  	int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  	if (index == 0) {  		// Nothing there except a valid IPv4 address' so...  		return true;  		// version 2.0: return warning if one is set  	} else {  		// - // Assume it's an attempt at a mixed address (IPv6 +  		// IPv4)  		// - if ($addressLiteral[$index - 1] !== ':') return  		// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  		// preceding IPv4 address must be ':'  		// revision 2.1: new IPv6 testing strategy  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3		  			this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		// -  		// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  		// $index - 6);  		// - $groupMax = 6;  		// revision 2.1: new IPv6 testing strategy  		IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  		// Convert IPv4 part to IPv6 format  	}  } else {  	// It must be an attempt at pure IPv6  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	IPv6 = addressLiteral.Substring (5);  	// - $groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (matchesIP1.Count > 0) {  	int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  	if (index == 0) {  		// Nothing there except a valid IPv4 address' so...  		return true;  		// version 2.0: return warning if one is set  	} else {  		// - // Assume it's an attempt at a mixed address (IPv6 +  		// IPv4)  		// - if ($addressLiteral[$index - 1] !== ':') return  		// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  		// preceding IPv4 address must be ':'  		// revision 2.1: new IPv6 testing strategy  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3		  			this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		// -  		// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  		// $index - 6);  		// - $groupMax = 6;  		// revision 2.1: new IPv6 testing strategy  		IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  		// Convert IPv4 part to IPv6 format  	}  } else {  	// It must be an attempt at pure IPv6  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	IPv6 = addressLiteral.Substring (5);  	// - $groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (matchesIP1.Count > 0) {  	int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  	if (index == 0) {  		// Nothing there except a valid IPv4 address' so...  		return true;  		// version 2.0: return warning if one is set  	} else {  		// - // Assume it's an attempt at a mixed address (IPv6 +  		// IPv4)  		// - if ($addressLiteral[$index - 1] !== ':') return  		// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  		// preceding IPv4 address must be ':'  		// revision 2.1: new IPv6 testing strategy  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3		  			this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		// -  		// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  		// $index - 6);  		// - $groupMax = 6;  		// revision 2.1: new IPv6 testing strategy  		IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  		// Convert IPv4 part to IPv6 format  	}  } else {  	// It must be an attempt at pure IPv6  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	IPv6 = addressLiteral.Substring (5);  	// - $groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (matchesIP1.Count > 0) {  	int index = addressLiteral.LastIndexOf (matchesIP1 [0].Value);  	if (index == 0) {  		// Nothing there except a valid IPv4 address' so...  		return true;  		// version 2.0: return warning if one is set  	} else {  		// - // Assume it's an attempt at a mixed address (IPv6 +  		// IPv4)  		// - if ($addressLiteral[$index - 1] !== ':') return  		// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  		// preceding IPv4 address must be ':'  		// revision 2.1: new IPv6 testing strategy  		if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  			// RFC5321 section 4.1.3		  			this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  			return false;  		}  		// -  		// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  		// $index - 6);  		// - $groupMax = 6;  		// revision 2.1: new IPv6 testing strategy  		IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  		// Convert IPv4 part to IPv6 format  	}  } else {  	// It must be an attempt at pure IPv6  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	IPv6 = addressLiteral.Substring (5);  	// - $groupMax = 8;  	// revision 2.1: new IPv6 testing strategy  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (index == 0) {  	// Nothing there except a valid IPv4 address' so...  	return true;  	// version 2.0: return warning if one is set  } else {  	// - // Assume it's an attempt at a mixed address (IPv6 +  	// IPv4)  	// - if ($addressLiteral[$index - 1] !== ':') return  	// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  	// preceding IPv4 address must be ':'  	// revision 2.1: new IPv6 testing strategy  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3		  		this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// -  	// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  	// $index - 6);  	// - $groupMax = 6;  	// revision 2.1: new IPv6 testing strategy  	IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  	// Convert IPv4 part to IPv6 format  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (index == 0) {  	// Nothing there except a valid IPv4 address' so...  	return true;  	// version 2.0: return warning if one is set  } else {  	// - // Assume it's an attempt at a mixed address (IPv6 +  	// IPv4)  	// - if ($addressLiteral[$index - 1] !== ':') return  	// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  	// preceding IPv4 address must be ':'  	// revision 2.1: new IPv6 testing strategy  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3		  		this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// -  	// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  	// $index - 6);  	// - $groupMax = 6;  	// revision 2.1: new IPv6 testing strategy  	IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  	// Convert IPv4 part to IPv6 format  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (index == 0) {  	// Nothing there except a valid IPv4 address' so...  	return true;  	// version 2.0: return warning if one is set  } else {  	// - // Assume it's an attempt at a mixed address (IPv6 +  	// IPv4)  	// - if ($addressLiteral[$index - 1] !== ':') return  	// IsEMailResult.ISEMAIL_IPV4BADPREFIX; // Character  	// preceding IPv4 address must be ':'  	// revision 2.1: new IPv6 testing strategy  	if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  		// RFC5321 section 4.1.3		  		this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	// -  	// - $IPv6 = substr($addressLiteral' 5' ($index === 7) ? 2 :  	// $index - 6);  	// - $groupMax = 6;  	// revision 2.1: new IPv6 testing strategy  	IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  	// Convert IPv4 part to IPv6 format  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  	// RFC5321 section 4.1.3		  	this.ResultInfo.Add (@"                             Character preceding IPv4 address must be ':' 						    RFC5321 section 4.1.3	                         ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: IPv6 = addressLiteral.Substring (5' index - 5) + "0000:0000";  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (!addressLiteral.Substring (0' 5).Equals (IPv6tag)) {  	// RFC5321 section 4.1.3  	this.ResultInfo.Add (@"                             Invalid IPV6 address 						    RFC5321 section 4.1.3	                         ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: IPv6 = addressLiteral.Substring (5);  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (currIndex == -1) {  	// We need exactly the right number of groups  	if (groupCount != groupMax) {  		// RFC5321 section 4.1.3  		this.ResultInfo.Add (@"                             Invalid IPV6 groupcount 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  } else {  	if (currIndex != IPv6.LastIndexOf (double_colon)) {  		// More than one '::'  		this.ResultInfo.Add (@"                             IPV6 double double colon present 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  		groupMax++;  		// RFC 4291 allows :: at the start or end of an  	}  	// address with 7 other groups in addition  	if (groupCount > groupMax) {  		// Too many IPv6 groups in address  		this.ResultInfo.Add (@"                             Too many groups in section 						    RFC5321 section 4.1.3	                         ");  		return false;  	}  	if (groupCount == groupMax) {  		// Eliding a single group with :: is deprecated by RFCs 5321 & 5952  		// & 5952  		this.ResultInfo.Add (@"Eliding a single group with :: is deprecated by RFCs 5321 & 5952");  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if ((currIndex == 0) || (currIndex == (IPv6.Length - 2))) {  	groupMax++;  	// RFC 4291 allows :: at the start or end of an  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: foreach (String element in dotArray) {  	string working_element = element;  	lastElement = element;  	// Remove any leading or trailing FWS  	Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  	String new_element = newReg.Replace (working_element' string.Empty);  	if (!element.Equals (new_element)) {  		this.ResultInfo.Add (@"FWS is unlikely in the real world");  	}  	working_element = new_element;  	// version 2.0: Warning condition added  	int elementLength = working_element.Length;  	// Each dot-delimited component must be of type atext  	// A zero-length element implies a period at the beginning or  	// end of the  	// local part' or two periods together. Either way it's not  	// allowed.  	if (elementLength == 0) {  		// Dots in wrong place  		this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  		return false;  	}  	// revision 1.15: Speed up the test and get rid of  	// "uninitialized string offset" notices from PHP  	// Then we need to remove all valid comments (i.e. those at the  	// start or end of the element  	if (working_element.Substring (0' 1) == "(") {  		this.ResultInfo.Add (@"Comments are unlikely in the real world");  		// version 2.0: Warning condition added  		int indexBrace = working_element.IndexOf (")");  		if (indexBrace != -1) {  			Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  			if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  				// revision 1.17: Fixed name of constant (also  				// spotted by turboflash - thanks!)  				// Illegal characters in comment  				this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  			elementLength = working_element.Length;  		}  	}  	if (working_element.Substring (elementLength - 1' 1) == ")") {  		// Comments are unlikely in the real world  		// return_status = IsEMailResult.ISEMAIL_COMMENTS;  		// version 2.0: Warning condition added  		int indexBrace = working_element.LastIndexOf ("(");  		if (indexBrace != -1) {  			Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  			if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  				// revision 1.17: Fixed name of constant (also  				// spotted by turboflash - thanks!)  				// Illegal characters in comment  				this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (0' indexBrace);  			elementLength = working_element.Length;  		}  	}  	// Remove any leading or trailing FWS around the element (inside  	// any comments)  	Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  	new_element = repRegex.Replace (working_element' string.Empty);  	//if (!element.equals(new_element))   	//{  	//    // FWS is unlikely in the real world  	//    return_status = IsEMailResult.ISEMAIL_FWS;  	//}  	working_element = new_element;  	// version 2.0: Warning condition added  	// What's left counts towards the maximum length for this part  	if (partLength > 0) {  		partLength++;  		// for the dot  	}  	partLength += working_element.Length;  	// The DNS defines domain name syntax very generally -- a  	// string of labels each containing up to 63 8-bit octets'  	// separated by dots' and with a maximum total of 255  	// octets.  	// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  	if (elementLength > 63) {  		// Label must be 63 characters or less  		this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	// Any ASCII graphic (printing) character other than the  	// at-sign ("@")' backslash' double quote' comma' or square  	// brackets may  	// appear without quoting. If any of that list of excluded  	// characters  	// are to appear' they must be quoted  	// (http://tools.ietf.org/html/rfc3696#section-3)  	//  	// If the hyphen is used' it is not permitted to appear at  	// either the beginning or end of a label.  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  	// ;' @' \' comma' period' "  	Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  	if (badChars.Matches (working_element).Count > 0) {  		// Illegal character in domain name  		this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  		return false;  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: foreach (String element in dotArray) {  	string working_element = element;  	lastElement = element;  	// Remove any leading or trailing FWS  	Regex newReg = new Regex ("^" + FWS + "|" + FWS + "$");  	String new_element = newReg.Replace (working_element' string.Empty);  	if (!element.Equals (new_element)) {  		this.ResultInfo.Add (@"FWS is unlikely in the real world");  	}  	working_element = new_element;  	// version 2.0: Warning condition added  	int elementLength = working_element.Length;  	// Each dot-delimited component must be of type atext  	// A zero-length element implies a period at the beginning or  	// end of the  	// local part' or two periods together. Either way it's not  	// allowed.  	if (elementLength == 0) {  		// Dots in wrong place  		this.ResultInfo.Add (@" 				 Each dot-delimited component must be of type atext 				 A zero-length element implies a period at the beginning or 				 end of the 				 local part' or two periods together. Either way it's not 				 allowed.                         ");  		return false;  	}  	// revision 1.15: Speed up the test and get rid of  	// "uninitialized string offset" notices from PHP  	// Then we need to remove all valid comments (i.e. those at the  	// start or end of the element  	if (working_element.Substring (0' 1) == "(") {  		this.ResultInfo.Add (@"Comments are unlikely in the real world");  		// version 2.0: Warning condition added  		int indexBrace = working_element.IndexOf (")");  		if (indexBrace != -1) {  			Regex comments1Regex = new Regex ("(?<!\\\\)[\\(\\)]");  			if (comments1Regex.Matches (working_element.Substring (1' indexBrace - 1)).Count > 0) {  				// revision 1.17: Fixed name of constant (also  				// spotted by turboflash - thanks!)  				// Illegal characters in comment  				this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (indexBrace + 1' elementLength - indexBrace - 1);  			elementLength = working_element.Length;  		}  	}  	if (working_element.Substring (elementLength - 1' 1) == ")") {  		// Comments are unlikely in the real world  		// return_status = IsEMailResult.ISEMAIL_COMMENTS;  		// version 2.0: Warning condition added  		int indexBrace = working_element.LastIndexOf ("(");  		if (indexBrace != -1) {  			Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  			if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  				// revision 1.17: Fixed name of constant (also  				// spotted by turboflash - thanks!)  				// Illegal characters in comment  				this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  				return false;  			}  			working_element = working_element.Substring (0' indexBrace);  			elementLength = working_element.Length;  		}  	}  	// Remove any leading or trailing FWS around the element (inside  	// any comments)  	Regex repRegex = new Regex ("^" + FWS + "|" + FWS + "$");  	new_element = repRegex.Replace (working_element' string.Empty);  	//if (!element.equals(new_element))   	//{  	//    // FWS is unlikely in the real world  	//    return_status = IsEMailResult.ISEMAIL_FWS;  	//}  	working_element = new_element;  	// version 2.0: Warning condition added  	// What's left counts towards the maximum length for this part  	if (partLength > 0) {  		partLength++;  		// for the dot  	}  	partLength += working_element.Length;  	// The DNS defines domain name syntax very generally -- a  	// string of labels each containing up to 63 8-bit octets'  	// separated by dots' and with a maximum total of 255  	// octets.  	// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  	if (elementLength > 63) {  		// Label must be 63 characters or less  		this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  		return false;  	}  	// Any ASCII graphic (printing) character other than the  	// at-sign ("@")' backslash' double quote' comma' or square  	// brackets may  	// appear without quoting. If any of that list of excluded  	// characters  	// are to appear' they must be quoted  	// (http://tools.ietf.org/html/rfc3696#section-3)  	//  	// If the hyphen is used' it is not permitted to appear at  	// either the beginning or end of a label.  	// (http://tools.ietf.org/html/rfc3696#section-2)  	//  	// Any excluded characters? i.e. 0x00-0x20' (' )' <' >' [' ]' :'  	// ;' @' \' comma' period' "  	Regex badChars = new Regex ("[\\x00-\\x20\\(\\)<>\\[\\]:;@\\\\'\\.\"]|^-|-$");  	if (badChars.Matches (working_element).Count > 0) {  		// Illegal character in domain name  		this.ResultInfo.Add (@"                     Illegal character in domain name                         ");  		return false;  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (working_element.Substring (elementLength - 1' 1) == ")") {  	// Comments are unlikely in the real world  	// return_status = IsEMailResult.ISEMAIL_COMMENTS;  	// version 2.0: Warning condition added  	int indexBrace = working_element.LastIndexOf ("(");  	if (indexBrace != -1) {  		Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  		if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  			// revision 1.17: Fixed name of constant (also  			// spotted by turboflash - thanks!)  			// Illegal characters in comment  			this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  			return false;  		}  		working_element = working_element.Substring (0' indexBrace);  		elementLength = working_element.Length;  	}  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (indexBrace != -1) {  	Regex commentRegex = new Regex ("(?<!\\\\)(?:[\\(\\)])");  	if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  		// revision 1.17: Fixed name of constant (also  		// spotted by turboflash - thanks!)  		// Illegal characters in comment  		this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  		return false;  	}  	working_element = working_element.Substring (0' indexBrace);  	elementLength = working_element.Length;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (commentRegex.Matches (working_element.Substring (indexBrace + 1' elementLength - indexBrace - 2)).Count > 0) {  	// revision 1.17: Fixed name of constant (also  	// spotted by turboflash - thanks!)  	// Illegal characters in comment  	this.ResultInfo.Add (@"                             Illegal characters in comment                         ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (elementLength > 63) {  	// Label must be 63 characters or less  	this.ResultInfo.Add (@" 				 The DNS defines domain name syntax very generally -- a 				 string of labels each containing up to 63 8-bit octets' 				 separated by dots' and with a maximum total of 255 				 octets. 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  	return false;  }  
Magic Number,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following statement contains a magic number: if (partLength > 255) {  	// Domain part must be 255 characters or less  	// (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)  	this.ResultInfo.Add (@" 				 Domain part must be 255 characters or less 				 (http://tools.ietf.org/html/rfc1123#section-6.1.3.5)                         ");  	return false;  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: foreach (var c in value) {  	switch (c) {  	case '\"':  		sb.Append ("\\\"");  		break;  	case '\\':  		sb.Append ("\\\\");  		break;  	case '\b':  		sb.Append ("\\b");  		break;  	case '\f':  		sb.Append ("\\f");  		break;  	case '\n':  		sb.Append ("\\n");  		break;  	case '\r':  		sb.Append ("\\r");  		break;  	case '\t':  		sb.Append ("\\t");  		break;  	default:  		int i = c;  		if (i < 32 || i > 127) {  			sb.AppendFormat ("\\u{0:X04}"' i);  		} else {  			sb.Append (c);  		}  		break;  	}  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: foreach (var c in value) {  	switch (c) {  	case '\"':  		sb.Append ("\\\"");  		break;  	case '\\':  		sb.Append ("\\\\");  		break;  	case '\b':  		sb.Append ("\\b");  		break;  	case '\f':  		sb.Append ("\\f");  		break;  	case '\n':  		sb.Append ("\\n");  		break;  	case '\r':  		sb.Append ("\\r");  		break;  	case '\t':  		sb.Append ("\\t");  		break;  	default:  		int i = c;  		if (i < 32 || i > 127) {  			sb.AppendFormat ("\\u{0:X04}"' i);  		} else {  			sb.Append (c);  		}  		break;  	}  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: switch (c) {  case '\"':  	sb.Append ("\\\"");  	break;  case '\\':  	sb.Append ("\\\\");  	break;  case '\b':  	sb.Append ("\\b");  	break;  case '\f':  	sb.Append ("\\f");  	break;  case '\n':  	sb.Append ("\\n");  	break;  case '\r':  	sb.Append ("\\r");  	break;  case '\t':  	sb.Append ("\\t");  	break;  default:  	int i = c;  	if (i < 32 || i > 127) {  		sb.AppendFormat ("\\u{0:X04}"' i);  	} else {  		sb.Append (c);  	}  	break;  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: switch (c) {  case '\"':  	sb.Append ("\\\"");  	break;  case '\\':  	sb.Append ("\\\\");  	break;  case '\b':  	sb.Append ("\\b");  	break;  case '\f':  	sb.Append ("\\f");  	break;  case '\n':  	sb.Append ("\\n");  	break;  case '\r':  	sb.Append ("\\r");  	break;  case '\t':  	sb.Append ("\\t");  	break;  default:  	int i = c;  	if (i < 32 || i > 127) {  		sb.AppendFormat ("\\u{0:X04}"' i);  	} else {  		sb.Append (c);  	}  	break;  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: if (i < 32 || i > 127) {  	sb.AppendFormat ("\\u{0:X04}"' i);  } else {  	sb.Append (c);  }  
Magic Number,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,JsEncode,The following statement contains a magic number: if (i < 32 || i > 127) {  	sb.AppendFormat ("\\u{0:X04}"' i);  } else {  	sb.Append (c);  }  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,ParseDatabaseStatusCode,The following statement contains a magic number: if (parts.Length > 0) {  	var statusCodeParts = parts [0].Split (':');  	if (statusCodeParts.Length.Equals (2)) {  		var statusCode = statusCodeParts [1];  		// if we cannot convert the code to a proper status code then do the safe thing and not allow access  		return statusCode.ToOrDefault (DownloadAttachmentStatusCodes.NoAccess.To<int> ());  	}  }  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,ParseDatabaseStatusCode,The following statement contains a magic number: if (statusCodeParts.Length.Equals (2)) {  	var statusCode = statusCodeParts [1];  	// if we cannot convert the code to a proper status code then do the safe thing and not allow access  	return statusCode.ToOrDefault (DownloadAttachmentStatusCodes.NoAccess.To<int> ());  }  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (2' @"<( )*head([^>])*>"' "<head>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (3' @"(<( )*(/)( )*head( )*>)"' "</head>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (4' "(<head>).*(</head>)"' String.Empty);  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (5' @"<( )*script([^>])*>"' "<script>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (6' @"(<( )*(/)( )*script( )*>)"' "</script>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (7' @"(<script>).*(</script>)"' String.Empty);  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (8' @"<( )*style([^>])*>"' "<style>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (9' @"(<( )*(/)( )*style( )*>)"' "</style>");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (10' "(<style>).*(</style>)"' String.Empty);  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (11' @"<( )*td([^>])*>"' "\t");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (12' @"<( )*br( )*>"' "\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (13' @"<( )*li( )*>"' "\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (14' @"<( )*div([^>])*>"' "\r\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (15' @"<( )*tr([^>])*>"' "\r\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (16' @"<( )*p([^>])*>"' "\r\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (17' @"<[^>]*>"' String.Empty);  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (18' @" "' " ");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (19' @"&bull;"' " * ");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (20' @"&lsaquo;"' "<");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (21' @"&rsaquo;"' ">");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (22' @"&trade;"' "(tm)");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (23' @"&frasl;"' "/");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (24' @"&lt;"' "<");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (25' @"&gt;"' ">");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (26' @"&copy;"' "(c)");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (27' @"&reg;"' "(r)");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (28' @"&frac14;"' "1/4");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (29' @"&frac12;"' "1/2");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (30' @"&frac34;"' "3/4");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (31' @"&lsquo;"' "'");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (32' @"&rsquo;"' "'");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (33' @"&ldquo;"' "\"");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (34' @"&rdquo;"' "\"");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (35' @"&(.{2'6});"' String.Empty);  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (36' "(\r)( )+(\r)"' "\r\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (37' "(\t)( )+(\t)"' "\t\t");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (38' "(\t)( )+(\r)"' "\t\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (39' "(\r)( )+(\t)"' "\r\t");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (40' "(\r)(\t)+(\r)"' "\r\r");  
Magic Number,BugNET.Common,Utilities,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Utilities.cs,GetTableDefinition,The following statement contains a magic number: dtCleaningCollection.Rows.Add (41' "(\r)(\t)+"' "\r\t");  
Magic Number,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,FormatShortDateAnd24HTime,The following statement contains a magic number: return dt.Date.Year > 1968 ? dt.ToString ("yyyy-MM-dd HH:mm") : "";  
Magic Number,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,FormatShortDateAnd12HTime,The following statement contains a magic number: return dt.Date.Year > 1968 ? dt.ToString ("yyyy-MM-dd hh:mm tt") : "";  
Magic Number,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,FormatShortDate,The following statement contains a magic number: return dt.Date.Year > 1968 ? dt.ToShortDateString () : "";  
Magic Number,BugNET.Common,XslHelpers,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\XslHelpers.cs,FormatShortTime,The following statement contains a magic number: return dt.Date.Year > 1968 ? dt.ToShortTimeString () : "";  
Missing Default,BugNET.Common,IsEMail,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\IsEmail.cs,IsEmailValid,The following switch statement is missing a default case: switch (charX) {  case '(':  	if (escapeThisChar) {  		replaceChar = true;  	} else {  		if (inQuote) {  			replaceChar = true;  		} else {  			if (braceDepth++ > 0) {  				replaceChar = true;  				// Increment brace depth  			}  		}  	}  	break;  case ')':  	if (escapeThisChar) {  		replaceChar = true;  	} else {  		if (inQuote) {  			replaceChar = true;  		} else {  			if (--braceDepth > 0)  				replaceChar = true;  			// Decrement brace depth  			if (braceDepth < 0) {  				braceDepth = 0;  			}  		}  	}  	break;  case '"':  	if (escapeThisChar) {  		replaceChar = true;  	} else {  		if (braceDepth == 0) {  			// Are we inside a quoted string?  			inQuote = !inQuote;  		} else {  			replaceChar = true;  		}  	}  	break;  case '.':  	// Dots don't help us either  	if (escapeThisChar) {  		replaceChar = true;  	} else {  		if (braceDepth > 0)  			replaceChar = true;  	}  	break;  }  
Missing Default,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,Get,The following switch statement is missing a default case: switch (v) {  case "true":  case "1":  	value = (T)Convert.ChangeType ("true"' typeof(bool));  	break;  case "false":  case "0":  	value = (T)Convert.ChangeType ("false"' typeof(bool));  	break;  }  
Missing Default,BugNET.Common,Extensions,F:\newReposMay17\dubeaud_bugnet\src\BugNET.Common\Extensions.cs,Get,The following switch statement is missing a default case: switch (v) {  case "true":  case "1":  	value = (T)Convert.ChangeType ("true"' typeof(bool));  	break;  case "false":  case "0":  	value = (T)Convert.ChangeType ("false"' typeof(bool));  	break;  }  
