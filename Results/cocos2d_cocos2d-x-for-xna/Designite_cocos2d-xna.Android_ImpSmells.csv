Implementation smell,Namespace,Class,File,Method,Description
Long Method,cocos2d,CCScheduler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCScheduler.cs,tick,The method has 118 lines of code.
Long Method,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The method has 152 lines of code.
Long Method,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The method has 118 lines of code.
Long Method,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The method has 158 lines of code.
Long Method,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,initWithDictionary,The method has 144 lines of code.
Long Method,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,update,The method has 124 lines of code.
Long Method,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,updateTransform,The method has 115 lines of code.
Long Method,cocos2d,CCSpriteFrameCache,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrameCache.cs,addSpriteFramesWithDictionary,The method has 127 lines of code.
Long Method,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,startElement,The method has 241 lines of code.
Long Method,cocos2d,CCTouchDispatcher,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDispatcher.cs,touches,The method has 138 lines of code.
Long Method,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The method has 508 lines of code.
Long Method,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The method has 351 lines of code.
Long Method,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The method has 247 lines of code.
Long Method,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The method has 234 lines of code.
Long Method,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,huft_build,The method has 149 lines of code.
Complex Method,cocos2d,CCActionManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\CCActionManager.cs,update,Cyclomatic complexity of the method is 8
Complex Method,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,visit,Cyclomatic complexity of the method is 10
Complex Method,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,nodeToParentTransform,Cyclomatic complexity of the method is 8
Complex Method,cocos2d,CCScheduler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCScheduler.cs,tick,Cyclomatic complexity of the method is 20
Complex Method,cocos2d,CCScheduler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCScheduler.cs,unscheduleSelector,Cyclomatic complexity of the method is 9
Complex Method,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseConfigFile,Cyclomatic complexity of the method is 12
Complex Method,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,Cyclomatic complexity of the method is 10
Complex Method,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,Cyclomatic complexity of the method is 24
Complex Method,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,Cyclomatic complexity of the method is 17
Complex Method,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,Cyclomatic complexity of the method is 24
Complex Method,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,update,Cyclomatic complexity of the method is 13
Complex Method,cocos2d,CCApplication,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCApplication.cs,ProcessTouch,Cyclomatic complexity of the method is 12
Complex Method,cocos2d,CCDictMaker,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCDictMaker.cs,startElement,Cyclomatic complexity of the method is 13
Complex Method,cocos2d,CCDictMaker,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCDictMaker.cs,endElement,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,Cyclomatic complexity of the method is 14
Complex Method,cocos2d,OGLES,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\OGLES.cs,GetXNABlend,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,updateTransform,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,insertChild,Cyclomatic complexity of the method is 9
Complex Method,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,rebuildIndexInOrder,Cyclomatic complexity of the method is 8
Complex Method,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,atlasIndexForChild,Cyclomatic complexity of the method is 8
Complex Method,cocos2d,CCSpriteFrameCache,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrameCache.cs,addSpriteFramesWithDictionary,Cyclomatic complexity of the method is 17
Complex Method,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,Cyclomatic complexity of the method is 11
Complex Method,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,Cyclomatic complexity of the method is 12
Complex Method,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,startElement,Cyclomatic complexity of the method is 33
Complex Method,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,endElement,Cyclomatic complexity of the method is 12
Complex Method,cocos2d,CCTMXTiledMap,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXTiledMap.cs,tilesetForLayer,Cyclomatic complexity of the method is 8
Complex Method,cocos2d,CCTouchDispatcher,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDispatcher.cs,touches,Cyclomatic complexity of the method is 25
Complex Method,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,Cyclomatic complexity of the method is 54
Complex Method,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Flush,Cyclomatic complexity of the method is 9
Complex Method,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,Cyclomatic complexity of the method is 42
Complex Method,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,Cyclomatic complexity of the method is 32
Complex Method,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,huft_build,Cyclomatic complexity of the method is 23
Complex Method,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,Cyclomatic complexity of the method is 8
Complex Method,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,Cyclomatic complexity of the method is 9
Complex Method,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,Read,Cyclomatic complexity of the method is 15
Long Parameter List,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,actionWithDuration,The method has 7 parameters. Parameters: t' radius' deltaRadius' angleZ' deltaAngleZ' angleX' deltaAngleX
Long Parameter List,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,initWithDuration,The method has 7 parameters. Parameters: t' radius' deltaRadius' angleZ' deltaAngleZ' angleX' deltaAngleX
Long Parameter List,cocos2d,CCRipple3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCRipple3D.cs,initWithPosition,The method has 6 parameters. Parameters: pos' r' wav' amp' gridSize' duration
Long Parameter List,cocos2d,CCRipple3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCRipple3D.cs,actionWithPosition,The method has 6 parameters. Parameters: pos' r' wav' amp' gridSize' duration
Long Parameter List,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,initWithPosition,The method has 5 parameters. Parameters: pos' t' amp' gridSize' duration
Long Parameter List,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,actionWithPosition,The method has 5 parameters. Parameters: pos' t' amp' gridSize' duration
Long Parameter List,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,initWithWaves,The method has 6 parameters. Parameters: wav' amp' h' v' gridSize' duration
Long Parameter List,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,actionWithWaves,The method has 6 parameters. Parameters: wav' amp' h' v' gridSize' duration
Long Parameter List,cocos2d,CCActionTween,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCActionTween.cs,actionWithDuration,The method has 5 parameters. Parameters: aDuration' key' from' to' d
Long Parameter List,cocos2d,CCActionTween,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCActionTween.cs,create,The method has 5 parameters. Parameters: aDuration' key' from' to' d
Long Parameter List,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The method has 5 parameters. Parameters: a' b' c' d' t
Long Parameter List,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The method has 5 parameters. Parameters: vertices' numOfVertices' closePolygon' fill' color
Long Parameter List,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCircle,The method has 6 parameters. Parameters: center' radius' angle' segments' drawLineToCenter' color
Long Parameter List,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawQuadBezier,The method has 5 parameters. Parameters: origin' control' destination' segments' color
Long Parameter List,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The method has 6 parameters. Parameters: origin' control1' control2' destination' segments' color
Long Parameter List,cocos2d,CCAffineTransform,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCAffineTransform.cs,CCAffineTransformMake,The method has 6 parameters. Parameters: a' b' c' d' tx' ty
Long Parameter List,cocos2d,CCPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,LineIntersect,The method has 6 parameters. Parameters: A' B' C' D' S' T
Long Parameter List,cocos2d,CCLabelAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelAtlas.cs,labelWithString,The method has 5 parameters. Parameters: label' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,cocos2d,CCLabelAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelAtlas.cs,initWithString,The method has 5 parameters. Parameters: label' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,cocos2d,CCLabelTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelTTF.cs,labelWithString,The method has 5 parameters. Parameters: label' dimensions' alignment' fontName' fontSize
Long Parameter List,cocos2d,CCLabelTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelTTF.cs,initWithString,The method has 5 parameters. Parameters: label' dimensions' alignment' fontName' fontSize
Long Parameter List,cocos2d,CCMenuItemImage,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemImage.cs,itemFromNormalImage,The method has 5 parameters. Parameters: normalImage' selectedImage' disabledImage' target' selector
Long Parameter List,cocos2d,CCMenuItemImage,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemImage.cs,initFromNormalImage,The method has 5 parameters. Parameters: normalImage' selectedImage' disabledImage' target' selector
Long Parameter List,cocos2d,CCMenuItemSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemSprite.cs,itemFromNormalSprite,The method has 5 parameters. Parameters: normalSprite' selectedSprite' disabledSprite' target' selector
Long Parameter List,cocos2d,CCMenuItemSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemSprite.cs,initFromNormalSprite,The method has 5 parameters. Parameters: normalSprite' selectedSprite' disabledSprite' target' selector
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,streakWithFade,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' path
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,create,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' path
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,streakWithFade,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' texture
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,create,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' texture
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' path
Long Parameter List,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The method has 5 parameters. Parameters: fade' minSeg' stroke' color' texture
Long Parameter List,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,saveBuffer,The method has 5 parameters. Parameters: szFilePath' x' y' nWidth' nHeight
Long Parameter List,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,saveBuffer,The method has 6 parameters. Parameters: format' name' x' y' nWidth' nHeight
Long Parameter List,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The method has 5 parameters. Parameters: pImage' x' y' nWidth' nHeight
Long Parameter List,cocos2d,CCPointExtension,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\CCPointExtension.cs,ccpLineIntersect,The method has 6 parameters. Parameters: A' B' C' D' S' T
Long Parameter List,cocos2d,CCSpriteFrame,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrame.cs,frameWithTexture,The method has 5 parameters. Parameters: pobTexture' rect' rotated' offset' originalSize
Long Parameter List,cocos2d,CCSpriteFrame,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrame.cs,initWithTexture,The method has 5 parameters. Parameters: pobTexture' rect' rotated' offset' originalSize
Long Parameter List,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The method has 6 parameters. Parameters: p0' p1' p2' p3' tension' t
Long Parameter List,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,The method has 5 parameters. Parameters: points' stroke' vertices' offset' nuPoints
Long Parameter List,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineIntersect,The method has 9 parameters. Parameters: Ax' Ay' Bx' By' Cx' Cy' Dx' Dy' T
Long Parameter List,cocos2d,ZipUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\zip_support\ZipUtils.cs,ccInflateMemoryWithHint,The method has 5 parameters. Parameters: parameterin' inLength' parameterout' outLength' outLenghtHint
Long Parameter List,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,The method has 5 parameters. Parameters: data' pixelFormat' pixelsWide' pixelsHigh' contentSize
Long Parameter List,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithString,The method has 5 parameters. Parameters: text' dimensions' alignment' fontName' fontSize
Long Parameter List,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithString,The method has 7 parameters. Parameters: text' dimensions' alignment' fontName' fontSize' fgColor' bgColor
Long Parameter List,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithString,The method has 5 parameters. Parameters: text' fontName' fontSize' fgColor' bgColor
Long Parameter List,cocos2d,CCTextFieldTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\text_input_node\CCTextFieldTTF .cs,textFieldWithPlaceHolder,The method has 5 parameters. Parameters: placeholder' dimensions' alignment' fontName' fontSize
Long Parameter List,cocos2d,CCTextFieldTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\text_input_node\CCTextFieldTTF .cs,initWithPlaceHolder,The method has 5 parameters. Parameters: placeholder' dimensions' alignment' fontName' fontSize
Long Parameter List,cocos2d.menu_nodes,CCMenuItemAtlasFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemAtlasFont.cs,itemFromString,The method has 5 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap
Long Parameter List,cocos2d.menu_nodes,CCMenuItemAtlasFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemAtlasFont.cs,itemFromString,The method has 7 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap' target' selector
Long Parameter List,cocos2d.menu_nodes,CCMenuItemAtlasFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemAtlasFont.cs,initFromString,The method has 7 parameters. Parameters: value' charMapFile' itemWidth' itemHeight' startCharMap' target' selector
Long Parameter List,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Init,The method has 6 parameters. Parameters: bl' bd' tl' tl_index' td' td_index
Long Parameter List,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Identifier,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,,The length of the parameter m_bStartingPositionInitialized is 30.
Long Identifier,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,,The length of the parameter CC_RETINA_DISPLAY_FILENAME_SUFFIX is 33.
Long Identifier,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,,The length of the parameter m_obUnflippedOffsetPositionFromCenter is 37.
Long Statement,cocos2d,CCLens3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLens3D.cs,update,The length of the statement  "                        CCPoint vect = new CCPoint(m_positionInPixels.x - new CCPoint(v.x' v.y).x' m_positionInPixels.y - new CCPoint(v.x' v.y).y); " is 123.
Long Statement,cocos2d,CCWaves3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves3D.cs,update,The length of the statement  "                    //CCLog("v.z offset is %f\n"' ((float)Math.Sin((float)Math.PI * time * m_nWaves * 2 + (v.y + v.x) * .01f) * m_fAmplitude * m_fAmplitudeRate)); " is 142.
Long Statement,cocos2d,CCTintBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCTintBy.cs,reverse,The length of the statement  "            return CCTintBy.actionWithDuration(m_fDuration' (short)-m_deltaR' (short)-m_deltaG' (short)-m_deltaB) as CCFiniteTimeAction; " is 124.
Long Statement,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawLine,The length of the statement  "            vertices[0] = new VertexPositionColor(new Vector3(origin.x * factor' origin.y * factor' 0)' new Color(color.r' color.g' color.b' color.a)); " is 139.
Long Statement,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawLine,The length of the statement  "            vertices[1] = new VertexPositionColor(new Vector3(destination.x * factor' destination.y * factor' 0)' new Color(color.r' color.g' color.b' color.a)); " is 149.
Long Statement,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCircle,The length of the statement  "            VertexPositionColor[] vertices = new VertexPositionColor[2 * (segments + 2)]; //	float *vertices = (float *)malloc( sizeof(float)*2*(segs+2)); " is 142.
Long Statement,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The length of the statement  "                float x = (float)Math.Pow(1 - t' 3) * origin.x + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x; " is 165.
Long Statement,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The length of the statement  "                float y = (float)Math.Pow(1 - t' 3) * origin.y + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y; " is 165.
Long Statement,cocos2d,CCAtlasNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCAtlasNode.cs,draw,The length of the statement  "            //glColor4f(((GLfloat)m_tColor.r) / 255' ((GLfloat)m_tColor.g) / 255' ((GLfloat)m_tColor.b) / 255' ((GLfloat)m_cOpacity) / 255); " is 128.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,visit,The length of the statement  "            CCApplication.sharedApplication().basicEffect.World = world; // Matrix.Invert(m_tCCNodeTransform) * CCApplication.sharedApplication().basicEffect.World; " is 152.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,transform,The length of the statement  "                    glTranslatef( RENDER_IN_SUBPIXEL(m_tPositionInPixels.x + m_tAnchorPointInPixels.x)' RENDER_IN_SUBPIXEL(m_tPositionInPixels.y + m_tAnchorPointInPixels.y)' m_fVertexZ); " is 166.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,transform,The length of the statement  "                    CCAffineTransform skewMatrix = CCAffineTransformMake( 1.0f' tanf(CC_DEGREES_TO_RADIANS(skewY_))' tanf(CC_DEGREES_TO_RADIANS(skewX_))' 1.0f' 0.0f' 0.0f ); " is 153.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,nodeToParentTransform,The length of the statement  "                    m_tTransform = CCAffineTransform.CCAffineTransformTranslate(m_tTransform' m_tAnchorPointInPixels.x' m_tAnchorPointInPixels.y); " is 126.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,nodeToParentTransform,The length of the statement  "                    m_tTransform = CCAffineTransform.CCAffineTransformTranslate(m_tTransform' m_tPositionInPixels.x' m_tPositionInPixels.y); " is 120.
Long Statement,cocos2d,CCNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCNode.cs,nodeToParentTransform,The length of the statement  "                    m_tTransform = CCAffineTransform.CCAffineTransformTranslate(m_tTransform' -m_tAnchorPointInPixels.x' -m_tAnchorPointInPixels.y); " is 128.
Long Statement,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,setOpenGLView,The length of the statement  "            m_obWinSizeInPixels = new CCSize(m_obWinSizeInPoints.width * m_fContentScaleFactor' m_obWinSizeInPoints.height * m_fContentScaleFactor); " is 136.
Long Statement,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1'4'3'2 spacing=0'0 outline=0 " is 131.
Long Statement,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseInfoArguments,The length of the statement  "            // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0'0'0'0 spacing=1'1 " is 122.
Long Statement,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseCommonArguments,The length of the statement  "            //CCAssert(atoi(value.c_str()) <= CCConfiguration::sharedConfiguration()->getMaxTextureSize()' "CCLabelBMFont: page can't be larger than supported"); " is 149.
Long Statement,cocos2d,CCLabelAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelAtlas.cs,updateAtlasValues,The length of the statement  "                quad.tl.colors = quad.tr.colors = quad.bl.colors = quad.br.colors = new ccColor4B(this.m_tColor.r' this.m_tColor.g' this.m_tColor.b' this.m_cOpacity); " is 150.
Long Statement,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,The length of the statement  "                    throw (new ArgumentException("LabelBMFont: character " + m_sString[i] + " outside of max font characters' which is " + kCCBMFontMaxChars)); " is 139.
Long Statement,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,The length of the statement  "                fontChar.positionInPixels = (new CCPoint(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0f + kerningAmount' " is 126.
Long Statement,cocos2d,CCLabelTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelTTF.cs,initWithString,The length of the statement  "                m_tDimensions = new CCSize(dimensions.width * CCDirector.sharedDirector().ContentScaleFactor' dimensions.height * CCDirector.sharedDirector().ContentScaleFactor); " is 162.
Long Statement,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The length of the statement  "            ccBlendFunc blend1 = new ccBlendFunc(OGLES.GL_ONE' OGLES.GL_ONE); // inScene will lay on background and will not be used with alpha " is 131.
Long Statement,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The length of the statement  "            ccBlendFunc blend2 = new ccBlendFunc(OGLES.GL_SRC_ALPHA' OGLES.GL_ONE_MINUS_SRC_ALPHA); // we are going to blend outScene via alpha  " is 131.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The length of the statement  "            m_pColor = new ccColor4B[m_uMaxPoints * 2];// m_pColorPointer = (GLubyte*)malloc(sizeof(GLubyte) * m_uMaxPoints * 2 * 4); " is 121.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                    m_pVerticesPCT[i] = new VertexPositionColorTexture(m_pVertices[i].ToVector3()' m_pColor[i].XNAColor' m_pTexCoords[i].ToVector2()); " is 130.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                    m_pVerticesPCT[i*2] = new VertexPositionColorTexture(m_pVerticesPCT[i].Position' m_pVerticesPCT[i].Color' m_pVerticesPCT[i].TextureCoordinate); " is 143.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                        vpc = new VertexPositionColorTexture(m_pVertices[newIdx2].ToVector3()' m_pColor[newIdx2].XNAColor' m_pTexCoords[newIdx2].ToVector2()); " is 134.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                        vpc = new VertexPositionColorTexture(m_pVertices[newIdx2 + 1].ToVector3()' m_pColor[newIdx2 + 1].XNAColor' m_pTexCoords[newIdx2 + 1].ToVector2()); " is 146.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                bool a2 = (m_uNuPoints == 1) ? false : (m_pPointVertexes[m_uNuPoints - 2].DistanceSQ(m_tPositionR) < (m_fMinSeg * 2.0f)); " is 121.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                        vpc = new VertexPositionColorTexture(m_pVertices[i * 2].ToVector3()' m_pColor[i * 2].XNAColor' m_pTexCoords[i * 2].ToVector2()); " is 128.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The length of the statement  "                        vpc = new VertexPositionColorTexture(m_pVertices[i * 2 + 1].ToVector3()' m_pColor[i * 2 + 1].XNAColor' m_pTexCoords[i * 2 + 1].ToVector2()); " is 140.
Long Statement,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,draw,The length of the statement  "                app.GraphicsDevice.DrawUserPrimitives<VertexPositionColorTexture>(PrimitiveType.TriangleStrip' m_pVerticesPCT' 0' m_uNuPoints*2); " is 129.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "            CCPoint midpoint = CCPointExtension.ccpAdd(tMin' CCPointExtension.ccpCompMult(m_tAnchorPoint' CCPointExtension.ccpSub(tMax' tMin))); " is 132.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "            float angle = 2.0f * ((float)Math.PI) * (m_eType == CCProgressTimerType.kCCProgressTimerTypeRadialCW ? alpha : 1.0f - alpha); " is 125.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                        CCPoint edgePtA = CCPointExtension.ccpAdd(tMin' CCPointExtension.ccpCompMult(boundaryTexCoord(i % kProgressTextureCoordsCount)' CCPointExtension.ccpSub(tMax' tMin))); " is 166.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                        CCPoint edgePtB = CCPointExtension.ccpAdd(tMin' CCPointExtension.ccpCompMult(boundaryTexCoord(pIndex)' CCPointExtension.ccpSub(tMax' tMin))); " is 141.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                    hit = CCPointExtension.ccpAdd(midpoint' CCPointExtension.ccpMult(CCPointExtension.ccpSub(percentagePt' midpoint)' min_t)); " is 122.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                    CCPoint texCoords = CCPointExtension.ccpAdd(tMin' CCPointExtension.ccpCompMult(boundaryTexCoord(i)' CCPointExtension.ccpSub(tMax' tMin))); " is 138.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                    m_pVertexData[m_nVertexDataCount - 1].texCoords.u = tMin.x + tMax.x - m_pVertexData[m_nVertexDataCount - 1].texCoords.u; " is 120.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The length of the statement  "                    m_pVertexData[m_nVertexDataCount - 1].texCoords.v = tMin.y + tMax.y - m_pVertexData[m_nVertexDataCount - 1].texCoords.v; " is 120.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,boundaryTexCoord,The length of the statement  "                        return new CCPoint((float)((kProgressTextureCoords >> ((index << 1) + 1)) & 1)' (float)((kProgressTextureCoords >> (index << 1)) & 1)); " is 135.
Long Statement,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,boundaryTexCoord,The length of the statement  "                        return new CCPoint((float)((kProgressTextureCoords >> (7 - (index << 1))) & 1)' (float)((kProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1)); " is 147.
Long Statement,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,begin,The length of the statement  "            //ccglOrtho((float)-1.0 / widthRatio'  (float)1.0 / widthRatio' (float)-1.0 / heightRatio' (float)1.0 / heightRatio' -1'1); " is 123.
Long Statement,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,end,The length of the statement  "            //            VolatileTexture::addDataTexture(m_pTexture' m_pUITextureImage->getData()' kTexture2DPixelFormat_RGBA8888' s); " is 123.
Long Statement,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The length of the statement  "                Debug.Assert(m_ePixelFormat == (uint)CCTexture2DPixelFormat.kCCTexture2DPixelFormat_RGBA8888' "only RGBA8888 can be saved as image"); " is 133.
Long Statement,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The length of the statement  "                //bRet = pImage.initWithImageData(pBuffer' nSavedBufferWidth * nSavedBufferHeight * 4' CCImage.kFmtRawData' nSavedBufferWidth' nSavedBufferHeight' 8); " is 150.
Long Statement,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,initWithDictionary,The length of the statement  "                    m_nEmitterMode = ccUtils.ccParseInt(ChangeToZeroIfNull(valueForKey("emitterType"' dictionary))' NumberStyles.AllowDecimalPoint); " is 128.
Long Statement,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,initWithDictionary,The length of the statement  "				        modeB.rotatePerSecondVar = ccUtils.ccParseFloat(ChangeToZeroIfNull(valueForKey("rotatePerSecondVariance"' dictionary))); " is 120.
Long Statement,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,initParticle,The length of the statement  "                particle.modeB.degreesPerSecond = ccMacros.CC_DEGREES_TO_RADIANS(modeB.rotatePerSecond + modeB.rotatePerSecondVar * ccMacros.CCRANDOM_MINUS1_1()); " is 146.
Long Statement,cocos2d,CCParticleSystem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystem.cs,update,The length of the statement  "                    if (m_ePositionType == eParticlePositionType.kCCPositionTypeFree || m_ePositionType == eParticlePositionType.kCCPositionTypeRelative) " is 133.
Long Statement,cocos2d,CCParticleSystemPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemPoint.cs,updateQuadWithParticle,The length of the statement  "            ccColor4B color = new ccColor4B((Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)' " is 127.
Long Statement,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,setDisplayFrame,The length of the statement  "           	Debug.Assert( CCPoint.CCPointEqualToPoint( spriteFrame.OffsetInPixels ' new CCPoint(0'0) )' "QuadParticle only supports SpriteFrames with no offsets"); " is 151.
Long Statement,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The length of the statement  "            ccColor4B color = new ccColor4B( (Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'  " is 128.
Long Statement,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,draw,The length of the statement  "                CCApplication.sharedApplication().spriteBatch.Draw(this.Texture.getTexture2D()' vecPosition' null' color' rotation' origin' scale' SpriteEffects.None' 0); " is 154.
Long Statement,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,draw,The length of the statement  "                //CCApplication.sharedApplication().spriteBatch.Draw(this.Texture.getTexture2D()' vecPosition' null' color' 0' origin' 1.0f' SpriteEffects.None' 0); " is 148.
Long Statement,cocos2d,CCApplication,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCApplication.cs,ProcessTouch,The length of the statement  "                                m_pTouches.AddLast(new CCTouch(touch.Id' touch.Position.X - m_rcViewPort.Left / m_fScreenScaleFactor' touch.Position.Y - m_rcViewPort.Top / m_fScreenScaleFactor)); " is 163.
Long Statement,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The length of the statement  "                            if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355 " is 165.
Long Statement,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,updateTransform,The length of the statement  "                    CCAffineTransform skewMatrix = CCAffineTransform.CCAffineTransformMake(1.0f' (float)Math.Tan(ccMacros.CC_DEGREES_TO_RADIANS(m_fSkewY))' " is 135.
Long Statement,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,updateTransform,The length of the statement  "                    // CCAssert( [p isKindOfClass:[CCSprite class]]' @"CCSprite should be a CCSprite subclass. Probably you initialized an sprite with a batchnode' but you didn't add it to the batch node." ); " is 188.
Long Statement,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,setTextureRectInPixels,The length of the statement  "            m_obOffsetPositionInPixels.x = relativeOffsetInPixels.x + (m_tContentSizeInPixels.width - m_obRectInPixels.size.width) / 2; " is 123.
Long Statement,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,setTextureRectInPixels,The length of the statement  "            m_obOffsetPositionInPixels.y = relativeOffsetInPixels.y + (m_tContentSizeInPixels.height - m_obRectInPixels.size.height) / 2; " is 125.
Long Statement,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,visit,The length of the statement  "            CCApplication.sharedApplication().basicEffect.World = CCApplication.sharedApplication().basicEffect.World * Matrix.Invert(m_tCCNodeTransform); " is 142.
Long Statement,cocos2d,CCSpriteFrameCache,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrameCache.cs,addSpriteFramesWithDictionary,The length of the statement  "                        CCLog.Log("cocos2d: WARNING: originalWidth/Height not found on the CCSpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist"); " is 141.
Long Statement,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The length of the statement  "             * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4 " is 123.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,description,The length of the statement  "            string ret = "<CCTexture2D | Dimensions = " + m_uPixelsWide + " x " + m_uPixelsHigh + " | Coordinates = (" + m_fMaxS + "' " + m_fMaxT + ")>"; " is 141.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,The length of the statement  "            Texture2D t = new Texture2D(CCApplication.sharedApplication().GraphicsDevice' (int)pixelsWide' (int)pixelsHigh' false' format); " is 127.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,The length of the statement  "            //            Texture2D t = new Texture2D(CCApplication.sharedApplication().GraphicsDevice' (int)contentSize.width' (int)contentSize.height' false' format); " is 156.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,The length of the statement  "                CCLog.Log(string.Format("cocos2d: WARNING: Image ({0} x {1}) is bigger than the supported {2} x {3}"' POTWide' POTHigh' maxTextureSize' maxTextureSize)); " is 153.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithString,The length of the statement  "            RenderTarget2D renderTarget = new RenderTarget2D(app.graphics.GraphicsDevice' (int)dimensions.width' (int)dimensions.height); " is 125.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithString,The length of the statement  "            return initWithString(text' new CCSize(0' 0)' CCTextAlignment.CCTextAlignmentCenter' fontName' fontSize' fgColor' bgColor); " is 123.
Long Statement,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithTexture,The length of the statement  "                CCLog.Log(string.Format("cocos2d: WARNING: Image ({0} x {1}) is bigger than the supported {2} x {3}"' POTWide' POTHigh' maxTextureSize' maxTextureSize)); " is 153.
Long Statement,cocos2d,CCTileMapAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTileMapAtlas.cs,calculateItemsToRender,The length of the statement  "                    ccColor3B ptr = new ccColor3B() { r = m_pTGAInfo.imageData[0]' g = m_pTGAInfo.imageData[1]' b = m_pTGAInfo.imageData[2] }; " is 122.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,initWithTilesetInfo,The length of the statement  "                this.contentSizeInPixels = new CCSize(m_tLayerSize.width * m_tMapTileSize.width' m_tLayerSize.height * m_tMapTileSize.height); " is 126.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,tileAt,The length of the statement  "            Debug.Assert(pos.x < m_tLayerSize.width && pos.y < m_tLayerSize.height && pos.x >= 0 && pos.y >= 0' "TMXLayer: invalid position"); " is 130.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,tileAt,The length of the statement  "                    rect = new CCRect(rect.origin.x / m_fContentScaleFactor' rect.origin.y / m_fContentScaleFactor' rect.size.width / m_fContentScaleFactor' rect.size.height / m_fContentScaleFactor); " is 179.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,tileGIDAt,The length of the statement  "            Debug.Assert(pos.x < m_tLayerSize.width && pos.y < m_tLayerSize.height && pos.x >= 0 && pos.y >= 0' "TMXLayer: invalid position"); " is 130.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,setTileGID,The length of the statement  "            Debug.Assert(pos.x < m_tLayerSize.width && pos.y < m_tLayerSize.height && pos.x >= 0 && pos.y >= 0' "TMXLayer: invalid position"); " is 130.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,setTileGID,The length of the statement  "                        rect = new CCRect(rect.origin.x / m_fContentScaleFactor' rect.origin.y / m_fContentScaleFactor' rect.size.width / m_fContentScaleFactor' rect.size.height / m_fContentScaleFactor); " is 179.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,removeTileAt,The length of the statement  "            Debug.Assert(pos.x < m_tLayerSize.width && pos.y < m_tLayerSize.height && pos.x >= 0 && pos.y >= 0' "TMXLayer: invalid position"); " is 130.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,setupTiles,The length of the statement  "            Debug.Assert(m_uMaxGID >= m_pTileSet.m_uFirstGid && m_uMinGID >= m_pTileSet.m_uFirstGid' "TMX: Only 1 tilset per layer is supported"); " is 134.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,appendTileForGID,The length of the statement  "            rect = new CCRect(rect.origin.x / m_fContentScaleFactor' rect.origin.y / m_fContentScaleFactor' rect.size.width / m_fContentScaleFactor' rect.size.height / m_fContentScaleFactor); " is 179.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,insertTileForGID,The length of the statement  "            rect = new CCRect(rect.origin.x / m_fContentScaleFactor' rect.origin.y / m_fContentScaleFactor' rect.size.width / m_fContentScaleFactor' rect.size.height / m_fContentScaleFactor); " is 179.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,updateTileForGID,The length of the statement  "            rect = new CCRect(rect.origin.x / m_fContentScaleFactor' rect.origin.y / m_fContentScaleFactor' rect.size.width / m_fContentScaleFactor' rect.size.height / m_fContentScaleFactor); " is 179.
Long Statement,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,atlasIndexForExistantZ,The length of the statement  "            //int item = (int)bsearch((void*)&key' (void*)&m_pAtlasIndexArray.arr[0]' m_pAtlasIndexArray.num' sizeof(object)' compareInts); " is 127.
Long Statement,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,startElement,The length of the statement  "                    Debug.Assert(compression == "" || compression == "gzip" || compression == "zlib"' "TMX: unsupported compression method"); " is 121.
Long Statement,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,startElement,The length of the statement  "                Debug.Assert(pTMXMapInfo.LayerAttribs != (int)TMXLayerAttrib.TMXLayerAttribNone' "TMX tile map: Only base64 and/or gzip/zlib maps are supported"); " is 146.
Long Statement,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,startElement,The length of the statement  "                y = (int)(pTMXMapInfo.MapSize.height * pTMXMapInfo.TileSize.height) - y - (attributeDict.ContainsKey("height") ? ccUtils.ccParseInt(attributeDict["height"]) : 0); " is 162.
Long Statement,cocos2d,CCTMXMapInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXMapInfo.cs,endElement,The length of the statement  "                if ((pTMXMapInfo.LayerAttribs & ((int)(TMXLayerAttrib.TMXLayerAttribGzip) | (int)TMXLayerAttrib.TMXLayerAttribZlib)) != 0) " is 122.
Long Statement,cocos2d,CCTouchDelegate,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDelegate.cs,excuteScriptTouchHandler,The length of the statement  "                CCScriptEngineManager.sharedScriptEngineManager().ScriptEngine.executeTouchEvent((m_pEventTypeFuncMap)[eventType].ToString()' " is 125.
Long Statement,cocos2d,CCTouchDelegate,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDelegate.cs,excuteScriptTouchesHandler,The length of the statement  "                CCScriptEngineManager.sharedScriptEngineManager().ScriptEngine.executeTouchesEvent((m_pEventTypeFuncMap)[eventType].ToString()' " is 127.
Long Statement,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,SlurpBlock,The length of the statement  "                this._RunningCrc32Result = this._RunningCrc32Result >> 8 ^ Crc32.crc32Table[(int) ((uint)block[index2] ^ this._RunningCrc32Result & (uint)byte.MaxValue)]; " is 154.
Long Statement,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The length of the statement  "            Array.Copy((Array)BitConverter.GetBytes((int)(this.LastModified.Value - GZipStream._unixEpoch).TotalSeconds)' 0' (Array)buffer' destinationIndex1' 4); " is 150.
Long Statement,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The length of the statement  "                        num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec); " is 142.
Long Statement,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The length of the statement  "                            r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z); " is 126.
Long Statement,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Initialize,The length of the statement  "                this.blocks = new InflateBlocks(codec' this.HandleRfc1950HeaderBytes ? (object)this : (object)(InflateManager)null' 1 << w); " is 124.
Long Statement,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,The length of the statement  "                if (this._streamMode != ZlibBaseStream.StreamMode.Reader || this._flavor != ZlibStreamFlavor.GZIP || this._z.TotalBytesOut == 0L) " is 129.
Long Statement,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,The length of the statement  "                    throw new ZlibException(string.Format("Protocol error. AvailableBytesIn={0}' expected 8"' (object)this._z.AvailableBytesIn)); " is 125.
Long Statement,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,The length of the statement  "                    throw new ZlibException(string.Format("Bad CRC32 in GZIP stream. (actual({0:X8})!=expected({1:X8}))"' (object)crc32Result' (object)num1)); " is 138.
Long Statement,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,The length of the statement  "                    throw new ZlibException(string.Format("Bad size in GZIP stream. (actual({0})!=expected({1}))"' (object)num3' (object)num2)); " is 124.
Long Statement,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,Read,The length of the statement  "            while ((!this.nomoreinput && num != 1 || this._z.AvailableBytesOut != count) && (this._z.AvailableBytesOut > 0 && !this.nomoreinput && num == 0)); " is 146.
Complex Conditional,cocos2d,CCPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,SegmentIntersect,The conditional expression  "LineIntersect(A' B' C' D' out S' out T)                  && (S >= 0.0f && S <= 1.0f && T >= 0.0f && T <= 1.0f)"  is complex.
Complex Conditional,cocos2d,CCPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,LineIntersect,The conditional expression  "(A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)"  is complex.
Complex Conditional,cocos2d,CCRect,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,CCRectContainsPoint,The conditional expression  "point.x >= CCRectGetMinX(rect)                      && point.x <= CCRectGetMaxX(rect)                      && point.y >= CCRectGetMinY(rect)                      && point.y <= CCRectGetMaxY(rect)"  is complex.
Complex Conditional,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The conditional expression  "x < 0 || x >= tx || y < 0 || y >= ty"  is complex.
Complex Conditional,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The conditional expression  "nWidth < 0                  || nHeight < 0                  || (0 == nWidth && 0 != nHeight)                  || (0 == nHeight && 0 != nWidth)"  is complex.
Complex Conditional,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The conditional expression  "name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false""  is complex.
Complex Conditional,cocos2d,CCPointExtension,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\CCPointExtension.cs,ccpLineIntersect,The conditional expression  "(A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)"  is complex.
Complex Conditional,cocos2d,CCPointExtension,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\CCPointExtension.cs,ccpSegmentIntersect,The conditional expression  "ccpLineIntersect(A' B' C' D' ref S' ref T)                  && (S >= 0.0f && S <= 1.0f && T >= 0.0f && T <= 1.0f)"  is complex.
Complex Conditional,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,atlasIndexForChild,The conditional expression  "(pPrevious.zOrder < 0 && nZ < 0) || (pPrevious.zOrder >= 0 && nZ >= 0)"  is complex.
Complex Conditional,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineIntersect,The conditional expression  "(Ax == Bx && Ay == By) || (Cx == Dx && Cy == Dy)"  is complex.
Magic Number,cocos2d,CCFollow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action\CCFollow.cs,initWithTarget,The following statement contains a magic number: m_obHalfScreenSize = CCPointExtension.ccpMult(m_obFullScreenSize' 0.5f);
Magic Number,cocos2d,CCFollow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action\CCFollow.cs,initWithTarget,The following statement contains a magic number: m_fRightBoundary = m_fLeftBoundary = (m_fLeftBoundary + m_fRightBoundary) / 2;
Magic Number,cocos2d,CCFollow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action\CCFollow.cs,initWithTarget,The following statement contains a magic number: m_fTopBoundary = m_fBottomBoundary = (m_fTopBoundary + m_fBottomBoundary) / 2;
Magic Number,cocos2d,CCFollow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action\CCFollow.cs,initWithTarget,The following statement contains a magic number: m_obHalfScreenSize = CCPointExtension.ccpMult(m_obFullScreenSize' 0.5f);
Magic Number,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,sphericalRadius,The following statement contains a magic number: r = (float)Math.Sqrt((float)Math.Pow(x' 2) + (float)Math.Pow(y' 2) + (float)Math.Pow(z' 2));
Magic Number,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,sphericalRadius,The following statement contains a magic number: r = (float)Math.Sqrt((float)Math.Pow(x' 2) + (float)Math.Pow(y' 2) + (float)Math.Pow(z' 2));
Magic Number,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,sphericalRadius,The following statement contains a magic number: r = (float)Math.Sqrt((float)Math.Pow(x' 2) + (float)Math.Pow(y' 2) + (float)Math.Pow(z' 2));
Magic Number,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,sphericalRadius,The following statement contains a magic number: s = (float)Math.Sqrt((float)Math.Pow(x' 2) + (float)Math.Pow(y' 2));
Magic Number,cocos2d,CCOrbitCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_camera\CCOrbitCamera.cs,sphericalRadius,The following statement contains a magic number: s = (float)Math.Sqrt((float)Math.Pow(x' 2) + (float)Math.Pow(y' 2));
Magic Number,cocos2d,CCEaseBackIn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackIn.cs,update,The following statement contains a magic number: float overshoot = 1.70158f;
Magic Number,cocos2d,CCEaseBackInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackInOut.cs,update,The following statement contains a magic number: float overshoot = 1.70158f * 1.525f;
Magic Number,cocos2d,CCEaseBackInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackInOut.cs,update,The following statement contains a magic number: float overshoot = 1.70158f * 1.525f;
Magic Number,cocos2d,CCEaseBackInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackInOut.cs,update,The following statement contains a magic number: time = time * 2;
Magic Number,cocos2d,CCEaseBackInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackInOut.cs,update,The following statement contains a magic number: m_pOther.update((time * time * ((overshoot + 1) * time - overshoot)) / 2);
Magic Number,cocos2d,CCEaseBackOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBackOut.cs,update,The following statement contains a magic number: float overshoot = 1.70158f;
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: return 7.5625f * time * time;
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: time < 1 / 2.75
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: time -= 2.625f / 2.75f;
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: time -= 2.625f / 2.75f;
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: return 7.5625f * time * time + 0.984375f;
Magic Number,cocos2d,CCEaseBounce,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounce.cs,bounceTime,The following statement contains a magic number: return 7.5625f * time * time + 0.984375f;
Magic Number,cocos2d,CCEaseBounceInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounceInOut.cs,update,The following statement contains a magic number: time = time * 2;
Magic Number,cocos2d,CCEaseBounceInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounceInOut.cs,update,The following statement contains a magic number: newT = (1 - bounceTime(1 - time)) * 0.5f;
Magic Number,cocos2d,CCEaseBounceInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseBounceInOut.cs,update,The following statement contains a magic number: time < 0.5f
Magic Number,cocos2d,CCEaseElastic,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseElastic.cs,initWithAction,The following statement contains a magic number: return initWithAction(pAction' 0.3f);
Magic Number,cocos2d,CCEaseExponentialIn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialIn.cs,update,The following statement contains a magic number: m_pOther.update(time == 0 ? 0 : (float)Math.Pow(2' 10 * (time / 1 - 1)) - 1 * 0.001f);
Magic Number,cocos2d,CCEaseExponentialIn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialIn.cs,update,The following statement contains a magic number: m_pOther.update(time == 0 ? 0 : (float)Math.Pow(2' 10 * (time / 1 - 1)) - 1 * 0.001f);
Magic Number,cocos2d,CCEaseExponentialIn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialIn.cs,update,The following statement contains a magic number: m_pOther.update(time == 0 ? 0 : (float)Math.Pow(2' 10 * (time / 1 - 1)) - 1 * 0.001f);
Magic Number,cocos2d,CCEaseExponentialInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialInOut.cs,update,The following statement contains a magic number: time /= 0.5f;
Magic Number,cocos2d,CCEaseExponentialInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialInOut.cs,update,The following statement contains a magic number: time = 0.5f *(float) Math.Pow(2' 10 * (time - 1));
Magic Number,cocos2d,CCEaseExponentialInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialInOut.cs,update,The following statement contains a magic number: time = 0.5f *(float) Math.Pow(2' 10 * (time - 1));
Magic Number,cocos2d,CCEaseExponentialInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialInOut.cs,update,The following statement contains a magic number: time = 0.5f *(float) Math.Pow(2' 10 * (time - 1));
Magic Number,cocos2d,CCEaseExponentialOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialOut.cs,update,The following statement contains a magic number: m_pOther.update(time == 1 ? 1 : (-(float)Math.Pow(2' -10 * time / 1) + 1));
Magic Number,cocos2d,CCEaseExponentialOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseExponentialOut.cs,update,The following statement contains a magic number: m_pOther.update(time == 1 ? 1 : (-(float)Math.Pow(2' -10 * time / 1) + 1));
Magic Number,cocos2d,CCEaseInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseInOut.cs,update,The following statement contains a magic number: r % 2 == 0
Magic Number,cocos2d,CCEaseInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseInOut.cs,update,The following statement contains a magic number: time *= 2;
Magic Number,cocos2d,CCEaseInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseInOut.cs,update,The following statement contains a magic number: m_pOther.update(0.5f * (float)Math.Pow(time' m_fRate));
Magic Number,cocos2d,CCEaseSineInOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_ease\CCEaseSineInOut.cs,update,The following statement contains a magic number: m_pOther.update(-0.5f * ((float)Math.Cos((float)Math.PI * time) - 1));
Magic Number,cocos2d,CCFlipX3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCFlipX3D.cs,update,The following statement contains a magic number: angle = angle / 2.0f;
Magic Number,cocos2d,CCFlipX3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCFlipX3D.cs,update,The following statement contains a magic number: diff.z = Math.Abs((float)Math.Floor((x * mz) / 4.0f));
Magic Number,cocos2d,CCFlipY3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCFlipY3D.cs,update,The following statement contains a magic number: angle = angle / 2.0f;
Magic Number,cocos2d,CCFlipY3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCFlipY3D.cs,update,The following statement contains a magic number: diff.z = Math.Abs((float)Math.Floor((y * mz) / 4.0f));
Magic Number,cocos2d,CCLens3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLens3D.cs,initWithPosition,The following statement contains a magic number: m_fLensEffect = 0.7f;
Magic Number,cocos2d,CCLens3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLens3D.cs,update,The following statement contains a magic number: pre_log = 0.001f;
Magic Number,cocos2d,CCLiquid,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLiquid.cs,update,The following statement contains a magic number: float coeffA = time * (float)Math.PI * m_nWaves * 2f;
Magic Number,cocos2d,CCLiquid,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLiquid.cs,update,The following statement contains a magic number: v.x = (v.x + ((float)Math.Sin(coeffA + v.x * .01f) * coeffB));
Magic Number,cocos2d,CCLiquid,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCLiquid.cs,update,The following statement contains a magic number: v.y = (v.y + ((float)Math.Sin(coeffA + v.y * .01f) * coeffB));
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: float tt = Math.Max(0' time - 0.25f);
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: float deltaAy = (tt * tt * 500);
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: float ay = -100 - deltaAy;
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: float deltaTheta = -(float)Math.PI / 2 * (float)Math.Sqrt(time);
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: float theta = /*0.01f */ +(float)Math.PI / 2 + deltaTheta;
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: p.z = (r * (1 - cosBeta) * cosTheta) / 7;
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: p.z = 0.5f;
Magic Number,cocos2d,CCPageTurn3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCPageTurn3D.cs,update,The following statement contains a magic number: p.z < 0.5f
Magic Number,cocos2d,CCRipple3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCRipple3D.cs,update,The following statement contains a magic number: float rate = (float)Math.Pow(r / m_fRadius' 2);
Magic Number,cocos2d,CCRipple3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCRipple3D.cs,update,The following statement contains a magic number: v.z += ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + r * 0.1f) * m_fAmplitude * m_fAmplitudeRate * rate);
Magic Number,cocos2d,CCRipple3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCRipple3D.cs,update,The following statement contains a magic number: v.z += ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + r * 0.1f) * m_fAmplitude * m_fAmplitudeRate * rate);
Magic Number,cocos2d,CCShaky3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCShaky3D.cs,update,The following statement contains a magic number: v.x += (random.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShaky3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCShaky3D.cs,update,The following statement contains a magic number: v.y += (random.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShaky3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCShaky3D.cs,update,The following statement contains a magic number: v.z += (random.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,update,The following statement contains a magic number: CCPoint avg = new CCPoint(i - (m_sGridSize.x / 2.0f)' j - (m_sGridSize.y / 2.0f));
Magic Number,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,update,The following statement contains a magic number: CCPoint avg = new CCPoint(i - (m_sGridSize.x / 2.0f)' j - (m_sGridSize.y / 2.0f));
Magic Number,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,update,The following statement contains a magic number: float amp = 0.1f * m_fAmplitude * m_fAmplitudeRate;
Magic Number,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,update,The following statement contains a magic number: float a = r * (float)Math.Cos((float)Math.PI / 2.0f + time * (float)Math.PI * m_nTwirls * 2) * amp;
Magic Number,cocos2d,CCTwirl,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCTwirl.cs,update,The following statement contains a magic number: float a = r * (float)Math.Cos((float)Math.PI / 2.0f + time * (float)Math.PI * m_nTwirls * 2) * amp;
Magic Number,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,update,The following statement contains a magic number: v.x = (v.x + ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + v.y * .01f) * m_fAmplitude * m_fAmplitudeRate));
Magic Number,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,update,The following statement contains a magic number: v.x = (v.x + ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + v.y * .01f) * m_fAmplitude * m_fAmplitudeRate));
Magic Number,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,update,The following statement contains a magic number: v.y = (v.y + ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + v.x * .01f) * m_fAmplitude * m_fAmplitudeRate));
Magic Number,cocos2d,CCWaves,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves.cs,update,The following statement contains a magic number: v.y = (v.y + ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 + v.x * .01f) * m_fAmplitude * m_fAmplitudeRate));
Magic Number,cocos2d,CCWaves3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves3D.cs,update,The following statement contains a magic number: v.z += ((float)Math.Sin((float)Math.PI * time * m_nWaves * 2 + (v.y + v.x) * .01f) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCWaves3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid3d\CCWaves3D.cs,update,The following statement contains a magic number: v.z += ((float)Math.Sin((float)Math.PI * time * m_nWaves * 2 + (v.y + v.x) * .01f) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCAccelDeccelAmplitude,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_grid\CCAccelDeccelAmplitude.cs,update,The following statement contains a magic number: float f = time * 2;
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBezierBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBezierBy.cs,bezierat,The following statement contains a magic number: return (float)((Math.Pow(1 - t' 3) * a +                              3 * t * (Math.Pow(1 - t' 2)) * b +                              3 * Math.Pow(t' 2) * (1 - t) * c +                              Math.Pow(t' 3) * d));
Magic Number,cocos2d,CCBlink,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCBlink.cs,update,The following statement contains a magic number: m_pTarget.visible = m > slice / 2 ? true : false;
Magic Number,cocos2d,CCCardinalSplineTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCCardinalSplineTo.cs,update,The following statement contains a magic number: CCPoint pp3 = m_pPoints.getControlPointAtIndex(p + 2);
Magic Number,cocos2d,CCCatmullRomBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCCatmullRomBy.cs,initWithDuration,The following statement contains a magic number: base.initWithDuration(dt' points' 0.5f)
Magic Number,cocos2d,CCFadeIn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCFadeIn.cs,update,The following statement contains a magic number: pRGBAProtocol.Opacity = (byte)(255 * time);
Magic Number,cocos2d,CCFadeOut,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCFadeOut.cs,update,The following statement contains a magic number: pRGBAProtocol.Opacity  = (byte)(255 * (1 - time));
Magic Number,cocos2d,CCJumpBy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCJumpBy.cs,update,The following statement contains a magic number: float y = m_height * 4 * frac * (1 - frac);
Magic Number,cocos2d,CCRotateTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCRotateTo.cs,startWithTarget,The following statement contains a magic number: m_fStartAngle = m_fStartAngle % 350.0f;
Magic Number,cocos2d,CCRotateTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCRotateTo.cs,startWithTarget,The following statement contains a magic number: m_fDiffAngle -= 360;
Magic Number,cocos2d,CCRotateTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCRotateTo.cs,startWithTarget,The following statement contains a magic number: m_fDiffAngle > 180
Magic Number,cocos2d,CCRotateTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCRotateTo.cs,startWithTarget,The following statement contains a magic number: m_fDiffAngle += 360;
Magic Number,cocos2d,CCRotateTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCRotateTo.cs,startWithTarget,The following statement contains a magic number: m_fDiffAngle < -180
Magic Number,cocos2d,CCSequence,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSequence.cs,CCSequence,The following statement contains a magic number: m_pActions = new CCFiniteTimeAction[2];
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fStartSkewX = m_fStartSkewX % 180f;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaX -= 360;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaX > 180
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaX += 360;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaX < -180
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fStartSkewY = m_fStartSkewY % 360f;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaY -= 360;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaY > 180
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaY += 360;
Magic Number,cocos2d,CCSkewTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCSkewTo.cs,startWithTarget,The following statement contains a magic number: m_fDeltaY < -180
Magic Number,cocos2d,CCProgressTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_progress_timer\CCProgressTo.cs,startWithTarget,The following statement contains a magic number: m_fFrom == 100
Magic Number,cocos2d,CCFadeOutBLTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutBLTiles.cs,testFunc,The following statement contains a magic number: return (float)Math.Pow((n.x + n.y) / (pos.x + pos.y)' 6);
Magic Number,cocos2d,CCFadeOutDownTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutDownTiles.cs,testFunc,The following statement contains a magic number: return (float)Math.Pow(n.y / pos.y' 6);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,testFunc,The following statement contains a magic number: return (float)Math.Pow((pos.x + pos.y) / (n.x + n.y)' 6);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.bl.x += (step.x / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.bl.y += (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.br.x -= (step.x / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.br.y += (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.tl.x += (step.x / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.tl.y -= (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.tr.x -= (step.x / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutTRTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutTRTiles.cs,transformTile,The following statement contains a magic number: coords.tr.y -= (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutUpTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutUpTiles.cs,testFunc,The following statement contains a magic number: return (float)Math.Pow(pos.y / n.y' 6);
Magic Number,cocos2d,CCFadeOutUpTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutUpTiles.cs,transformTile,The following statement contains a magic number: coords.bl.y += (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutUpTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutUpTiles.cs,transformTile,The following statement contains a magic number: coords.br.y += (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutUpTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutUpTiles.cs,transformTile,The following statement contains a magic number: coords.tl.y -= (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCFadeOutUpTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCFadeOutUpTiles.cs,transformTile,The following statement contains a magic number: coords.tr.y -= (step.y / 2) * (1.0f - distance);
Magic Number,cocos2d,CCJumpTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCJumpTiles3D.cs,update,The following statement contains a magic number: float sinz = ((float)Math.Sin((float)Math.PI * time * m_nJumps * 2) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCJumpTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCJumpTiles3D.cs,update,The following statement contains a magic number: float sinz2 = (float)(Math.Sin((float)Math.PI * (time * m_nJumps * 2 + 1)) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCJumpTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCJumpTiles3D.cs,update,The following statement contains a magic number: ((i + j) % 2) == 0
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.bl.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.br.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tl.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tr.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.bl.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.br.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tl.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tr.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.bl.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.br.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tl.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShakyTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShakyTiles3D.cs,update,The following statement contains a magic number: coords.tr.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.bl.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.br.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tl.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tr.x += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.bl.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.br.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tl.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tr.y += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.bl.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.br.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tl.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCShatteredTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCShatteredTiles3D.cs,update,The following statement contains a magic number: coords.tr.z += (rand.Next() % (m_nRandrange * 2)) - m_nRandrange;
Magic Number,cocos2d,CCSplitCols,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCSplitCols.cs,update,The following statement contains a magic number: (i % 2) == 0
Magic Number,cocos2d,CCSplitRows,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCSplitRows.cs,update,The following statement contains a magic number: (j % 2) == 0
Magic Number,cocos2d,CCWavesTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCWavesTiles3D.cs,update,The following statement contains a magic number: coords.bl.z = ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 +                          (coords.bl.y + coords.bl.x) * .01f) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCWavesTiles3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_tiled_grid\CCWavesTiles3D.cs,update,The following statement contains a magic number: coords.bl.z = ((float)Math.Sin(time * (float)Math.PI * m_nWaves * 2 +                          (coords.bl.y + coords.bl.x) * .01f) * m_fAmplitude * m_fAmplitudeRate);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawLine,The following statement contains a magic number: VertexPositionColor[] vertices = new VertexPositionColor[2];
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: short[] indexes = new short[(numOfVertices - 2) * 3];
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: short[] indexes = new short[(numOfVertices - 2) * 3];
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: indexes[i * 3 + 0] = 0;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: indexes[i * 3 + 1] = (short)(i + 2);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: indexes[i * 3 + 1] = (short)(i + 2);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: indexes[i * 3 + 2] = (short)(i + 1);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: indexes[i * 3 + 2] = (short)(i + 1);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: i < numOfVertices - 2
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawPoly,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColor>(PrimitiveType.TriangleStrip'                          newPoint' 0' numOfVertices'                          indexes' 0' numOfVertices - 2);
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCircle,The following statement contains a magic number: float coef = 2.0f * (float)(Math.PI) / segments;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCircle,The following statement contains a magic number: VertexPositionColor[] vertices = new VertexPositionColor[2 * (segments + 2)];
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCircle,The following statement contains a magic number: VertexPositionColor[] vertices = new VertexPositionColor[2 * (segments + 2)];
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawQuadBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 2) * origin.x + 2.0f * (1 - t) * t * control.x + t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawQuadBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 2) * origin.x + 2.0f * (1 - t) * t * control.x + t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawQuadBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 2) * origin.y + 2.0f * (1 - t) * t * control.y + t * t * destination.y;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawQuadBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 2) * origin.y + 2.0f * (1 - t) * t * control.y + t * t * destination.y;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 3) * origin.x + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 3) * origin.x + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 3) * origin.x + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float x = (float)Math.Pow(1 - t' 3) * origin.x + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.x + 3.0f * (1 - t) * t * t * control2.x + t * t * t * destination.x;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 3) * origin.y + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 3) * origin.y + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 3) * origin.y + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y;
Magic Number,cocos2d,CCDrawingPrimitives,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDrawingPrimitives.cs,ccDrawCubicBezier,The following statement contains a magic number: float y = (float)Math.Pow(1 - t' 3) * origin.y + 3.0f * (float)Math.Pow(1 - t' 2) * t * control1.y + 3.0f * (1 - t) * t * t * control2.y + t * t * t * destination.y;
Magic Number,cocos2d,CCNS,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCNS.cs,CCRectFromString,The following statement contains a magic number: i < 3
Magic Number,cocos2d,CCNS,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCNS.cs,splitWithForm,The following statement contains a magic number: strs.Count != 2 || strs[0].Length == 0 || strs[1].Length == 0
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,blit,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices.ToArray()' 0' vertices.Count'                      indexes' 0' indexes.Length / 3);
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: m_pIndices = new short[m_sGridSize.x * m_sGridSize.y * 6];
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: short[] tempidx = new short[6] { (short)a' (short)d' (short)b' (short)b' (short)d' (short)c };
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: Array.Copy(tempidx' 0' idxArray' 6 * idx' tempidx.Length);
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: int[] l1 = new int[4] { a' b' c' d };
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: ccVertex3F[] l2 = new ccVertex3F[4] { e' f' g' h };
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: int[] tex1 = new int[4] { a' b' c' d };
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: CCPoint[] tex2 = new CCPoint[4]                       {                      new CCPoint(x1' y1)'                       new CCPoint(x2' y1)'                       new CCPoint(x2' y2)'                      new CCPoint(x1' y2)                      };
Magic Number,cocos2d,CCGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: i < 4
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,blit,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices.ToArray()' 0' vertices.Count'                      this.m_pIndices' 0' this.m_pIndices.Length / 3);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: m_pIndices = new short[numQuads * 6];
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 0] = (short)(x * 4 + 0);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 0] = (short)(x * 4 + 0);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 1] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 1] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 1] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 2] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 2] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 2] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 3] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 3] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 3] = (short)(x * 4 + 1);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 4] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 4] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 4] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 4] = (short)(x * 4 + 2);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 5] = (short)(x * 4 + 3);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 5] = (short)(x * 4 + 3);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 5] = (short)(x * 4 + 3);
Magic Number,cocos2d,CCTiledGrid3D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCTiledGrid3D.cs,calculateVertexPoints,The following statement contains a magic number: idxArray[x * 6 + 5] = (short)(x * 4 + 3);
Magic Number,cocos2d,CCAtlasNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\base_nodes\CCAtlasNode.cs,initWithTileFile,The following statement contains a magic number: m_cOpacity = 255;
Magic Number,cocos2d,CCCamera,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCCamera.cs,getZEye,The following statement contains a magic number: return 1.192092896e-07F;
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,getLastScene,The following statement contains a magic number: return m_pobScenesStack[m_pobScenesStack.Count - 2];
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,showFPS,The following statement contains a magic number: CCApplication.sharedApplication().spriteBatch.DrawString(font'                   m_pszFPS'                   new Vector2(0' CCApplication.sharedApplication().getSize().height - 50)'                   new Color(0' 255' 255));
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,showFPS,The following statement contains a magic number: CCApplication.sharedApplication().spriteBatch.DrawString(font'                   m_pszFPS'                   new Vector2(0' CCApplication.sharedApplication().getSize().height - 50)'                   new Color(0' 255' 255));
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,showFPS,The following statement contains a magic number: CCApplication.sharedApplication().spriteBatch.DrawString(font'                   m_pszFPS'                   new Vector2(0' CCApplication.sharedApplication().getSize().height - 50)'                   new Color(0' 255' 255));
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,pause,The following statement contains a magic number: animationInterval = 1 / 4.0;
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,enableRetinaDisplay,The following statement contains a magic number: enabled && m_fContentScaleFactor == 2
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,enableRetinaDisplay,The following statement contains a magic number: float newScale = (float)(enabled ? 2 : 1);
Magic Number,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,enableRetinaDisplay,The following statement contains a magic number: m_fContentScaleFactor == 2
Magic Number,cocos2d,CCPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,Midpoint,The following statement contains a magic number: return Add(v2).Mult(0.5f);
Magic Number,cocos2d,CCRect,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,CCRectGetMidX,The following statement contains a magic number: return (rect.origin.x + rect.size.width / 2.0f);
Magic Number,cocos2d,CCRect,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\cocoa\CCGeometry.cs,CCRectGetMidY,The following statement contains a magic number: return (rect.origin.y + rect.size.height / 2.0f);
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,applyLandscape,The following statement contains a magic number: float w = winSize.width / 2;
Magic Number,cocos2d,CCGridBase,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\effects\CCGridBase.cs,applyLandscape,The following statement contains a magic number: float h = winSize.height / 2;
Magic Number,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: m_tPadding.bottom = ccUtils.ccParseInt(temp[2]);
Magic Number,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseInfoArguments,The following statement contains a magic number: m_tPadding.left = ccUtils.ccParseInt(temp[3]);
Magic Number,cocos2d,CCBMFontConfiguration,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCBMFontConfiguration.cs,parseKerningEntry,The following statement contains a magic number: element.key = (first << 16) | (second & 0xffff);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: m_cOpacity = 255;
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: m_tColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: m_tColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: m_tColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,initWithString,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,The following statement contains a magic number: fontChar.positionInPixels = (new CCPoint(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0f + kerningAmount'                      (float)nextFontPositionY + yOffset - rect.size.height / 2.0f));
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,The following statement contains a magic number: fontChar.positionInPixels = (new CCPoint(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width / 2.0f + kerningAmount'                      (float)nextFontPositionY + yOffset - rect.size.height / 2.0f));
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,createFontChars,The following statement contains a magic number: m_cOpacity != 255
Magic Number,cocos2d,CCLabelBMFont,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\label_nodes\CCLabelBMFont.cs,kerningAmountForFirst,The following statement contains a magic number: int key = (first << 16) | (second & 0xffff);
Magic Number,cocos2d,CCLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayer.cs,CCLayer,The following statement contains a magic number: anchorPoint = CCPointExtension.ccp(0.5f' 0.5f);
Magic Number,cocos2d,CCLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayer.cs,CCLayer,The following statement contains a magic number: anchorPoint = CCPointExtension.ccp(0.5f' 0.5f);
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,draw,The following statement contains a magic number: app.basicEffect.Alpha = (float)this.m_cOpacity / 255.0f;
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,draw,The following statement contains a magic number: VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Vector4' VertexElementUsage.Color' 0)                  });
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,draw,The following statement contains a magic number: app.GraphicsDevice.DrawUserPrimitives<VertexPositionColor>(                      PrimitiveType.TriangleStrip'                      vertices' 0' 2);
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,initWithColorWidthHeight,The following statement contains a magic number: indexes[0] = 2;
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,initWithColorWidthHeight,The following statement contains a magic number: indexes[0] = 2;
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,initWithColorWidthHeight,The following statement contains a magic number: indexes[0] = 3;
Magic Number,cocos2d,CCLayerColor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerColor.cs,updateColor,The following statement contains a magic number: i < 4
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,initWithColor,The following statement contains a magic number: return base.initWithColor(new ccColor4B(start.r' start.g' start.b' 255));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: double c = Math.Sqrt(2.0);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: float opacityf = (float)m_cOpacity / 255.0f;
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[0].r = (byte)(E.r + (S.r - E.r) * ((c + u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[0].g = (byte)(E.g + (S.g - E.g) * ((c + u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[0].b = (byte)(E.b + (S.b - E.b) * ((c + u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[0].a = (byte)(E.a + (S.a - E.a) * ((c + u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[1].r = (byte)(E.r + (S.r - E.r) * ((c - u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[1].g = (byte)(E.g + (S.g - E.g) * ((c - u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[1].b = (byte)(E.b + (S.b - E.b) * ((c - u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[1].a = (byte)(E.a + (S.a - E.a) * ((c - u.x + u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].r = (byte)(E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].r = (byte)(E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].g = (byte)(E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].g = (byte)(E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].b = (byte)(E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].b = (byte)(E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].a = (byte)(E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[2].a = (byte)(E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].r = (byte)(E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].r = (byte)(E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].g = (byte)(E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].g = (byte)(E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].b = (byte)(E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].b = (byte)(E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].a = (byte)(E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: m_pSquareColors[3].a = (byte)(E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0f * c)));
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[2].Color = new Color(m_pSquareColors[2].r' m_pSquareColors[2].g' m_pSquareColors[2].b' m_pSquareColors[2].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[2].Color = new Color(m_pSquareColors[2].r' m_pSquareColors[2].g' m_pSquareColors[2].b' m_pSquareColors[2].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[2].Color = new Color(m_pSquareColors[2].r' m_pSquareColors[2].g' m_pSquareColors[2].b' m_pSquareColors[2].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[2].Color = new Color(m_pSquareColors[2].r' m_pSquareColors[2].g' m_pSquareColors[2].b' m_pSquareColors[2].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[2].Color = new Color(m_pSquareColors[2].r' m_pSquareColors[2].g' m_pSquareColors[2].b' m_pSquareColors[2].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[3].Color = new Color(m_pSquareColors[3].r' m_pSquareColors[3].g' m_pSquareColors[3].b' m_pSquareColors[3].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[3].Color = new Color(m_pSquareColors[3].r' m_pSquareColors[3].g' m_pSquareColors[3].b' m_pSquareColors[3].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[3].Color = new Color(m_pSquareColors[3].r' m_pSquareColors[3].g' m_pSquareColors[3].b' m_pSquareColors[3].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[3].Color = new Color(m_pSquareColors[3].r' m_pSquareColors[3].g' m_pSquareColors[3].b' m_pSquareColors[3].a);
Magic Number,cocos2d,CCLayerGradient,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerGradient.cs,updateColor,The following statement contains a magic number: vertices[3].Color = new Color(m_pSquareColors[3].r' m_pSquareColors[3].g' m_pSquareColors[3].b' m_pSquareColors[3].a);
Magic Number,cocos2d,CCLayerMultiplex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCLayerMultiplex.cs,initWithLayers,The following statement contains a magic number: m_pLayers = new List<CCLayer>(5);
Magic Number,cocos2d,CCScene,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCScene.cs,CCScene,The following statement contains a magic number: anchorPoint = CCPointExtension.ccp(0.5f' 0.5f);
Magic Number,cocos2d,CCScene,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\CCScene.cs,CCScene,The following statement contains a magic number: anchorPoint = CCPointExtension.ccp(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 0' 0)'                      CCCallFunc.actionWithTarget(this' (base.finish)));
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 0' 0)'                      CCCallFunc.actionWithTarget(this' (base.finish)));
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2));
Magic Number,cocos2d,CCTransitionFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2));
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCShow.action()'                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.5f;
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval jump = CCJumpBy.actionWithDuration(m_fDuration / 4' new CCPoint(-s.width' 0)' s.width / 4' 2);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval jump = CCJumpBy.actionWithDuration(m_fDuration / 4' new CCPoint(-s.width' 0)' s.width / 4' 2);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval jump = CCJumpBy.actionWithDuration(m_fDuration / 4' new CCPoint(-s.width' 0)' s.width / 4' 2);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval scaleIn = CCScaleTo.actionWithDuration(m_fDuration / 4' 1.0f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval scaleOut = CCScaleTo.actionWithDuration(m_fDuration / 4' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval scaleOut = CCScaleTo.actionWithDuration(m_fDuration / 4' 0.5f);
Magic Number,cocos2d,CCTransitionJumpZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionJumpZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval delay = CCDelayTime.actionWithDuration(m_fDuration / 2);
Magic Number,cocos2d,CCTransitionMoveInL,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionMoveInL.cs,easeActionWithAction,The following statement contains a magic number: return CCEaseOut.actionWithAction(action' 2.0f);
Magic Number,cocos2d,CCTransitionPageTurn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionPageTurn.cs,onEnter,The following statement contains a magic number: x = 16;
Magic Number,cocos2d,CCTransitionPageTurn,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionPageTurn.cs,onEnter,The following statement contains a magic number: y = 12;
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outNode.Percentage = 100.0f;
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outNode.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outNode.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outNode.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: outNode.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: CCAction layerAction = CCSequence.actions              (                  CCProgressFromTo.actionWithDuration(m_fDuration' 100.0f' 0.0f)'                  CCCallFunc.actionWithTarget(this' base.finish)              );
Magic Number,cocos2d,CCTransitionRadialCCW,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRadialCCW.cs,onEnter,The following statement contains a magic number: this.addChild(outNode' 2' kSceneRadial);
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.001f;
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionRotoZoom,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionRotoZoom.cs,onEnter,The following statement contains a magic number: CCActionInterval rotozoom = (CCActionInterval)(CCSequence.actions              (                  CCSpawn.actions                  (                      CCScaleBy.actionWithDuration(m_fDuration / 2' 0.001f)'                      CCRotateBy.actionWithDuration(m_fDuration / 2' 360 * 2)                  )'                  CCDelayTime.actionWithDuration(m_fDuration / 2)              ));
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.001f;
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(2 / 3.0f' 0.5f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(2 / 3.0f' 0.5f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pInScene.anchorPoint = new CCPoint(2 / 3.0f' 0.5f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(1 / 3.0f' 0.5f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: m_pOutScene.anchorPoint = new CCPoint(1 / 3.0f' 0.5f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,onEnter,The following statement contains a magic number: CCActionInterval scaleOut = CCScaleTo.actionWithDuration(m_fDuration' 0.01f);
Magic Number,cocos2d,CCTransitionShrinkGrow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionShrinkGrow.cs,easeActionWithAction,The following statement contains a magic number: return CCEaseOut.actionWithAction(action' 2.0f);
Magic Number,cocos2d,CCTransitionSlideInB,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInB.cs,initScenes,The following statement contains a magic number: m_pInScene.position = new CCPoint(0' -(s.height - 0.5f));
Magic Number,cocos2d,CCTransitionSlideInB,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInB.cs,action,The following statement contains a magic number: return CCMoveBy.actionWithDuration(m_fDuration' new CCPoint(0' s.height - 0.5f));
Magic Number,cocos2d,CCTransitionSlideInL,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInL.cs,initScenes,The following statement contains a magic number: m_pInScene.position = new CCPoint(-(s.width - 0.5f)' 0);
Magic Number,cocos2d,CCTransitionSlideInL,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInL.cs,action,The following statement contains a magic number: return CCMoveBy.actionWithDuration(m_fDuration' new CCPoint(s.width - 0.5f' 0));
Magic Number,cocos2d,CCTransitionSlideInL,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInL.cs,easeActionWithAction,The following statement contains a magic number: return CCEaseOut.actionWithAction(action' 2.0f);
Magic Number,cocos2d,CCTransitionSlideInR,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInR.cs,initScenes,The following statement contains a magic number: m_pInScene.position = new CCPoint(s.width - 0.5f' 0);
Magic Number,cocos2d,CCTransitionSlideInR,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInR.cs,action,The following statement contains a magic number: return CCMoveBy.actionWithDuration(m_fDuration' new CCPoint(-(s.width - 0.5f)' 0));
Magic Number,cocos2d,CCTransitionSlideInT,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInT.cs,initScenes,The following statement contains a magic number: m_pInScene.position = new CCPoint(0' s.height - 0.5f);
Magic Number,cocos2d,CCTransitionSlideInT,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSlideInT.cs,action,The following statement contains a magic number: return CCMoveBy.actionWithDuration(m_fDuration' new CCPoint(0' -(s.height - 0.5f)));
Magic Number,cocos2d,CCTransitionSplitCols,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSplitCols.cs,action,The following statement contains a magic number: return CCSplitCols.actionWithCols(3' m_fDuration / 2.0f);
Magic Number,cocos2d,CCTransitionSplitCols,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSplitCols.cs,action,The following statement contains a magic number: return CCSplitCols.actionWithCols(3' m_fDuration / 2.0f);
Magic Number,cocos2d,CCTransitionSplitCols,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSplitCols.cs,easeActionWithAction,The following statement contains a magic number: return CCEaseInOut.actionWithAction(action' 3.0f);
Magic Number,cocos2d,CCTransitionSplitRows,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSplitRows.cs,action,The following statement contains a magic number: return CCSplitRows.actionWithRows(3' m_fDuration / 2.0f);
Magic Number,cocos2d,CCTransitionSplitRows,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionSplitRows.cs,action,The following statement contains a magic number: return CCSplitRows.actionWithRows(3' m_fDuration / 2.0f);
Magic Number,cocos2d,CCTransitionTurnOffTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionTurnOffTiles.cs,onEnter,The following statement contains a magic number: int x = (int)(12 * aspect);
Magic Number,cocos2d,CCTransitionTurnOffTiles,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionTurnOffTiles.cs,onEnter,The following statement contains a magic number: int y = 12;
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCShow.action()'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCShow.action()'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCShow.action()'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' -45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCShow.action()'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 45' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipAngular,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipAngular.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.5f;
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 0' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipX,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipX.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.5f;
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inAngleZ = 270;
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outDeltaZ = 90;
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: inA = (CCActionInterval)CCSequence.actions                  (                      CCDelayTime.actionWithDuration(m_fDuration / 2)'                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' inAngleZ' inDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 1)'                          CCShow.action()                      )'                      CCCallFunc.actionWithTarget(this' base.finish)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: outA = (CCActionInterval)CCSequence.actions                  (                      CCSpawn.actions                      (                          CCOrbitCamera.actionWithDuration(m_fDuration / 2' 1' 0' outAngleZ' outDeltaZ' 90' 0)'                          CCScaleTo.actionWithDuration(m_fDuration / 2' 0.5f)                      )'                      CCHide.action()'                      CCDelayTime.actionWithDuration(m_fDuration / 2)                  );
Magic Number,cocos2d,CCTransitionZoomFlipY,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionZoomFlipY.cs,onEnter,The following statement contains a magic number: m_pInScene.scale = 0.5f;
Magic Number,cocos2d,CCTransitionFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFade.cs,onEnter,The following statement contains a magic number: addChild(l' 2' kSceneFade);
Magic Number,cocos2d,CCTransitionFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFade.cs,onEnter,The following statement contains a magic number: CCActionInterval a = (CCActionInterval)CCSequence.actions                  (                      CCFadeIn.actionWithDuration(m_fDuration / 2)'                      CCCallFunc.actionWithTarget(this' (base.hideOutShowIn))'                      CCFadeOut.actionWithDuration(m_fDuration / 2)'                      CCCallFunc.actionWithTarget(this' (base.finish))                  );
Magic Number,cocos2d,CCTransitionFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFade.cs,onEnter,The following statement contains a magic number: CCActionInterval a = (CCActionInterval)CCSequence.actions                  (                      CCFadeIn.actionWithDuration(m_fDuration / 2)'                      CCCallFunc.actionWithTarget(this' (base.hideOutShowIn))'                      CCFadeOut.actionWithDuration(m_fDuration / 2)'                      CCCallFunc.actionWithTarget(this' (base.finish))                  );
Magic Number,cocos2d,CCTransitionFadeTR,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFadeTR.cs,onEnter,The following statement contains a magic number: int x = (int)(12 * aspect);
Magic Number,cocos2d,CCTransitionFadeTR,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionFadeTR.cs,onEnter,The following statement contains a magic number: int y = 12;
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.Sprite.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.position = new CCPoint(size.width / 2' size.height / 2);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: inTexture.Sprite.Opacity = 255;
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: outTexture.Sprite.Opacity = 255;
Magic Number,cocos2d,CCTransitionCrossFade,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\layers_scenes_transitions_nodes\transition\CCTransitionCrossFade.cs,onEnter,The following statement contains a magic number: addChild(layer' 2' kSceneFade);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,initWithItems,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,initWithItems,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,initWithItems,The following statement contains a magic number: position = new CCPoint(s.width / 2' s.height / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,initWithItems,The following statement contains a magic number: position = new CCPoint(s.width / 2' s.height / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsVerticallyWithPadding,The following statement contains a magic number: float y = height / 2.0f;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsVerticallyWithPadding,The following statement contains a magic number: pChild.position = new CCPoint(0' y - pChild.contentSize.height * pChild.scaleY / 2.0f);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsHorizontallyWithPadding,The following statement contains a magic number: float x = -width / 2.0f;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsHorizontallyWithPadding,The following statement contains a magic number: pChild.position = new CCPoint(x + pChild.contentSize.width * pChild.scaleX / 2.0f' 0);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: int height = -5;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: float y = (float)(height / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: w = (winSize.width - 2 * kDefaultPadding) / rowColumns;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: x = w/2f;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: pChild.position = new CCPoint(kDefaultPadding + x - (winSize.width - 2*kDefaultPadding) / 2'                                                y - pChild.contentSize.height*pChild.scaleY / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: pChild.position = new CCPoint(kDefaultPadding + x - (winSize.width - 2*kDefaultPadding) / 2'                                                y - pChild.contentSize.height*pChild.scaleY / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: pChild.position = new CCPoint(kDefaultPadding + x - (winSize.width - 2*kDefaultPadding) / 2'                                                y - pChild.contentSize.height*pChild.scaleY / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInColumns,The following statement contains a magic number: y -= rowHeight + 5;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: int width = -10;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: int columnHeight = -5;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: columnHeight += (int)(pChild.contentSize.height*pChild.scaleY + 5);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: width += columnWidth + 10;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: columnHeight = -5;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: float x = (float)(-width / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: pChild.position = new CCPoint(x + columnWidths[column] / 2'  					                                  y - winSize.height / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: pChild.position = new CCPoint(x + columnWidths[column] / 2'  					                                  y - winSize.height / 2);
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: y -= pChild.contentSize.height*pChild.scaleY + 10;
Magic Number,cocos2d,CCMenu,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenu.cs,alignItemsInRows,The following statement contains a magic number: x += columnWidth + 5;
Magic Number,cocos2d,CCMenuItem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItem.cs,initWithTarget,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCMenuItem,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItem.cs,initWithTarget,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,initWithLabel,The following statement contains a magic number: DisabledColor = new ccColor3B(126' 126' 126);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,initWithLabel,The following statement contains a magic number: DisabledColor = new ccColor3B(126' 126' 126);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,initWithLabel,The following statement contains a magic number: DisabledColor = new ccColor3B(126' 126' 126);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,selected,The following statement contains a magic number: CCAction zoomAction = CCScaleTo.actionWithDuration(0.1f' m_fOriginalScale * 1.2f);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,selected,The following statement contains a magic number: CCAction zoomAction = CCScaleTo.actionWithDuration(0.1f' m_fOriginalScale * 1.2f);
Magic Number,cocos2d,CCMenuItemLabel,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\menu_nodes\CCMenuItemLabel.cs,unselected,The following statement contains a magic number: CCAction zoomAction = CCScaleTo.actionWithDuration(0.1f' m_fOriginalScale);
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_fMinSeg = (minSeg == -1.0f) ? stroke / 5.0f : minSeg;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_uMaxPoints = (int)(fade * 60.0f) + 2;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_uMaxPoints = (int)(fade * 60.0f) + 2;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_pVertices = new ccVertex2F[m_uMaxPoints * 2];
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_pTexCoords = new ccTex2F[m_uMaxPoints * 2];
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,initWithFade,The following statement contains a magic number: m_pColor = new ccColor4B[m_uMaxPoints * 2];
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,tintWithColor,The following statement contains a magic number: i < m_uNuPoints * 2
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVerticesPCT = new VertexPositionColorTexture[((m_uNuPoints+1) * 2)];
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: VertexPositionColorTexture[] tmp = new VertexPositionColorTexture[((m_uNuPoints + 1) * 2)];
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_uNuPoints * 2 > m_pVerticesPCT.Length
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVerticesPCT[i*2] = new VertexPositionColorTexture(m_pVerticesPCT[i].Position' m_pVerticesPCT[i].Color' m_pVerticesPCT[i].TextureCoordinate);
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVerticesPCT[i*2] == null
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: int offset = m_uNuPoints * 2;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pColor[offset].a = 255;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pColor[offset + 1].a = 255;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: int count = (m_uNuPoints + 1) * 2;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pTexCoords[i * 2] = new ccTex2F(0' texDelta * i);
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pTexCoords[i * 2 + 1] = new ccTex2F(1' texDelta * i);
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2].ToVector3()' m_pColor[i * 2].XNAColor' m_pTexCoords[i * 2].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2].ToVector3()' m_pColor[i * 2].XNAColor' m_pTexCoords[i * 2].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2].ToVector3()' m_pColor[i * 2].XNAColor' m_pTexCoords[i * 2].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVerticesPCT[i * 2] = vpc;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVertices[i * 2] != null
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2 + 1].ToVector3()' m_pColor[i * 2 + 1].XNAColor' m_pTexCoords[i * 2 + 1].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2 + 1].ToVector3()' m_pColor[i * 2 + 1].XNAColor' m_pTexCoords[i * 2 + 1].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: vpc = new VertexPositionColorTexture(m_pVertices[i * 2 + 1].ToVector3()' m_pColor[i * 2 + 1].XNAColor' m_pTexCoords[i * 2 + 1].ToVector2());
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVerticesPCT[i * 2 + 1] = vpc;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,update,The following statement contains a magic number: m_pVertices[i * 2 + 1] != null
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,draw,The following statement contains a magic number: app.basicEffect.Alpha = (float)Opacity / 255.0f;
Magic Number,cocos2d,CCMotionStreak,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCMotionStreak.cs,draw,The following statement contains a magic number: app.GraphicsDevice.DrawUserPrimitives<VertexPositionColorTexture>(PrimitiveType.TriangleStrip' m_pVerticesPCT' 0' m_uNuPoints*2);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,initWithTexture,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,initWithTexture,The following statement contains a magic number: anchorPoint = new CCPoint(0.5f' 0.5f);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,draw,The following statement contains a magic number: VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Vector3' VertexElementUsage.Color' 0)'                      new VertexElement(24' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  });
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,draw,The following statement contains a magic number: VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Vector3' VertexElementUsage.Color' 0)'                      new VertexElement(24' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  });
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,draw,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices' 0' m_nVertexDataCount'                      indexes' 0' m_nVertexDataCount - 2);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The following statement contains a magic number: float alpha = m_fPercentage / 100.0f;
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The following statement contains a magic number: int[] vIndexes = new int[2] { 0' 0 };
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The following statement contains a magic number: m_pVertexData[vIndexes[0] = 3].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * alpha' tMax.y);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The following statement contains a magic number: m_pVertexData[vIndexes[1] = 2].texCoords = new ccTex2F(tMin.x + (tMax.x - tMin.x) * alpha' tMin.y);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: float alpha = m_fPercentage / 100.0f;
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: float angle = 2.0f * ((float)Math.PI) * (m_eType == CCProgressTimerType.kCCProgressTimerTypeRadialCW ? alpha : 1.0f - alpha);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: m_nVertexDataCount != index + 3
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: m_nVertexDataCount = index + 3;
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: m_pVertexData[i + 2].texCoords = new ccTex2F(texCoords.x' texCoords.y);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateRadial,The following statement contains a magic number: m_pVertexData[i + 2].vertices = vertexFromTexCoord(texCoords);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateColor,The following statement contains a magic number: color.r *= (byte)(op / 255);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateColor,The following statement contains a magic number: color.g *= (byte)(op / 255);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateColor,The following statement contains a magic number: color.b *= (byte)(op / 255);
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,boundaryTexCoord,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          return new CCPoint((float)((kProgressTextureCoords >> ((index << 1) + 1)) & 1)' (float)((kProgressTextureCoords >> (index << 1)) & 1));                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          return new CCPoint((float)((kProgressTextureCoords >> (7 - (index << 1))) & 1)' (float)((kProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1));                      default:                          break;                  }
Magic Number,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,boundaryTexCoord,The following statement contains a magic number: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          return new CCPoint((float)((kProgressTextureCoords >> ((index << 1) + 1)) & 1)' (float)((kProgressTextureCoords >> (index << 1)) & 1));                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          return new CCPoint((float)((kProgressTextureCoords >> (7 - (index << 1))) & 1)' (float)((kProgressTextureCoords >> (7 - ((index << 1) + 1))) & 1));                      default:                          break;                  }
Magic Number,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The following statement contains a magic number: (pBuffer = new byte[nSavedBufferWidth * nSavedBufferHeight * 4]) == null
Magic Number,cocos2d,CCRenderTexture,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCRenderTexture.cs,getUIImageFromBuffer,The following statement contains a magic number: (pTempData = new byte[nReadBufferWidth * nReadBufferHeight * 4]) == null
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(250);
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.modeA.speed = 60;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.modeA.speedVar = 20;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 10;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' 60);
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' 60);
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.PosVar = new CCPoint(40' 20);
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.PosVar = new CCPoint(40' 20);
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 3;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: LifeVar = 0.25f;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 54.0f;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.76f;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.25f;
Magic Number,cocos2d,CCParticleFire,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.12f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(1500);
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.modeA.gravity = new CCPoint(0'-90);
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.modeA.speed = 180;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.modeA.speedVar = 50;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.Angle= 90;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.AngleVar = 20;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.Life = 3.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.a = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.r = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.g = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.b = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.a = 0.2f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.r = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.g = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.b = 0.1f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.a = 0.2f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 8.0f;
Magic Number,cocos2d,CCParticleFireworks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 2.0f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(350);
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 20;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 5;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 360;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: LifeVar = 0.5f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 30.0f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.76f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.25f;
Magic Number,cocos2d,CCParticleSun,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.12f;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(200);
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 60;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 10;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.radialAccel = -80;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.tangentialAccel = 80;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 360;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 4;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 37.0f;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.12f;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.25f;
Magic Number,cocos2d,CCParticleGalaxy,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.76f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(250);
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 80;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 10;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.radialAccel = -60;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.tangentialAccel = 15;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 360;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 4;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 30.0f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.50f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.50f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.50f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleFlower,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.a = 0.5f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(150);
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.gravity = new CCPoint(-200'200);
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.gravity = new CCPoint(-200'200);
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 15;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 5;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 360;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 2;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 60.0f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.2f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.4f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.7f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.2f;
Magic Number,cocos2d,CCParticleMeteor,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.a = 0.1f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(500);
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 150;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.radialAccel = -380;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.tangentialAccel = 45;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 12;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 20.0f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.r = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.g = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.b = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleSpiral,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(700);
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Duration = 0.1f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 70;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 40;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 360;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height/2);
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 5.0f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: LifeVar = 2;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 15.0f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.7f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.1f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.2f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.r = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.g = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.b = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.r = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.g = 0.5f;
Magic Number,cocos2d,CCParticleExplosion,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColorVar.b = 0.5f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(200);
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 25;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 10;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = 90;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 5;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' 0);
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: PosVar = new CCPoint(20' 0);
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 4;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 60.0f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 10.0f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.8f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.8f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.b = 0.8f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.r = 0.02f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.g = 0.02f;
Magic Number,cocos2d,CCParticleSmoke,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColorVar.b = 0.02f;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(700);
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 5;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height + 10);
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height + 10);
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: PosVar = new CCPoint( winSize.width/2' 0 );
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = -90;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 5;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 45;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: LifeVar = 15;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 10.0f;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 5.0f;
Magic Number,cocos2d,CCParticleSnow,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EmissionRate = 10;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,init,The following statement contains a magic number: return initWithTotalParticles(1000);
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.gravity = new CCPoint(10'-10);
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.gravity = new CCPoint(10'-10);
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speed = 130;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: modeA.speedVar = 30;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Angle = -90;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: AngleVar = 5;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: this.position = new CCPoint(winSize.width/2' winSize.height);
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: PosVar = new CCPoint( winSize.width/2' 0 );
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: Life = 4.5f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSize = 4.0f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartSizeVar = 2.0f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EmissionRate = 20;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.r = 0.7f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: StartColor.g = 0.8f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.r = 0.7f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.g = 0.8f;
Magic Number,cocos2d,CCParticleRain,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleExamples.cs,initWithTotalParticles,The following statement contains a magic number: EndColor.a = 0.5f;
Magic Number,cocos2d,CCParticleSystemPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemPoint.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B((Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'  		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemPoint.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B((Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'  		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemPoint.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B((Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'  		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemPoint,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemPoint.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B((Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'  		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: uint i6 = i*6;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: uint i4 = i*4;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+2] = (uint) i4+2;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+2] = (uint) i4+2;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+5] = (uint) i4+1;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+4] = (uint) i4+2;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+4] = (uint) i4+2;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+3] = (uint) i4+3;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initIndices,The following statement contains a magic number: m_pIndices[i6+3] = (uint) i4+3;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,initWithTotalParticles,The following statement contains a magic number: m_pIndices = new uint[this.TotalParticles * 6];
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B( (Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'   		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B( (Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'   		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B( (Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'   		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The following statement contains a magic number: ccColor4B color = new ccColor4B( (Byte)(particle.color.r * 255)' (Byte)(particle.color.g * 255)' (Byte)(particle.color.b * 255)'   		(Byte)(particle.color.a * 255));
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,updateQuadWithParticle,The following statement contains a magic number: float size_2 = particle.size / 2;
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,draw,The following statement contains a magic number: Vector2 origin = new Vector2(Texture.getTexture2D().Width / 2' Texture.getTexture2D().Height / 2);
Magic Number,cocos2d,CCParticleSystemQuad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\particle_nodes\CCParticleSystemQuad.cs,draw,The following statement contains a magic number: Vector2 origin = new Vector2(Texture.getTexture2D().Width / 2' Texture.getTexture2D().Height / 2);
Magic Number,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The following statement contains a magic number: switch (xmlReader.NodeType)                  {                      case XmlNodeType.Element:                            string[] attrs = null;                            if (name == "map")                          {                              Width = ccUtils.ccParseInt(xmlReader.GetAttribute("width"));                              Height = ccUtils.ccParseInt(xmlReader.GetAttribute("height"));                          }                            if (xmlReader.HasAttributes)                          {                              attrs = new string[xmlReader.AttributeCount * 2];                              xmlReader.MoveToFirstAttribute();                              int i = 0;                              attrs[0] = xmlReader.Name;                              attrs[1] = xmlReader.Value;                              i += 2;                                while (xmlReader.MoveToNextAttribute())                              {                                  attrs[i] = xmlReader.Name;                                  attrs[i + 1] = xmlReader.Value;                                  i += 2;                              }                                // Move the reader back to the element node.                              xmlReader.MoveToElement();                          }                          startElement(this' name' attrs);                            byte[] buffer = null;                            //read data content of tmx file                          if (name == "data")                          {                              if (attrs != null)                              {                                  string encoding = "";                                  for (int i = 0; i < attrs.Length; i++)                                  {                                      if (attrs[i] == "encoding")                                      {                                          encoding = attrs[i + 1];                                      }                                  }                                    if (encoding == "base64")                                  {                                      int dataSize = (Width * Height * 4) + 1024;                                      buffer = new byte[dataSize];                                      xmlReader.ReadElementContentAsBase64(buffer' 0' dataSize);                                  }                                  else                                  {                                      string value = xmlReader.ReadElementContentAsString();                                      buffer = Encoding.UTF8.GetBytes(value);                                  }                              }                                textHandler(this' buffer' buffer.Length);                              endElement(this' name);                          }                          else                              if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355                              {                                  string value = xmlReader.ReadElementContentAsString();                                  buffer = Encoding.UTF8.GetBytes(value);                                  textHandler(this' buffer' buffer.Length);                                  endElement(this' name);                              }                              else                              {                                  IXmlLineInfo info = (IXmlLineInfo)xmlReader;                                  CCLog.Log("Failed to handle XML tag: " + name + " in " + info.LineNumber + "@" + info.LinePosition + ":" + pszFile);                              }                          break;                        case XmlNodeType.EndElement:                          endElement(this' xmlReader.Name);                          dataindex++;                          break;                        default:                          break;                  }
Magic Number,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The following statement contains a magic number: switch (xmlReader.NodeType)                  {                      case XmlNodeType.Element:                            string[] attrs = null;                            if (name == "map")                          {                              Width = ccUtils.ccParseInt(xmlReader.GetAttribute("width"));                              Height = ccUtils.ccParseInt(xmlReader.GetAttribute("height"));                          }                            if (xmlReader.HasAttributes)                          {                              attrs = new string[xmlReader.AttributeCount * 2];                              xmlReader.MoveToFirstAttribute();                              int i = 0;                              attrs[0] = xmlReader.Name;                              attrs[1] = xmlReader.Value;                              i += 2;                                while (xmlReader.MoveToNextAttribute())                              {                                  attrs[i] = xmlReader.Name;                                  attrs[i + 1] = xmlReader.Value;                                  i += 2;                              }                                // Move the reader back to the element node.                              xmlReader.MoveToElement();                          }                          startElement(this' name' attrs);                            byte[] buffer = null;                            //read data content of tmx file                          if (name == "data")                          {                              if (attrs != null)                              {                                  string encoding = "";                                  for (int i = 0; i < attrs.Length; i++)                                  {                                      if (attrs[i] == "encoding")                                      {                                          encoding = attrs[i + 1];                                      }                                  }                                    if (encoding == "base64")                                  {                                      int dataSize = (Width * Height * 4) + 1024;                                      buffer = new byte[dataSize];                                      xmlReader.ReadElementContentAsBase64(buffer' 0' dataSize);                                  }                                  else                                  {                                      string value = xmlReader.ReadElementContentAsString();                                      buffer = Encoding.UTF8.GetBytes(value);                                  }                              }                                textHandler(this' buffer' buffer.Length);                              endElement(this' name);                          }                          else                              if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355                              {                                  string value = xmlReader.ReadElementContentAsString();                                  buffer = Encoding.UTF8.GetBytes(value);                                  textHandler(this' buffer' buffer.Length);                                  endElement(this' name);                              }                              else                              {                                  IXmlLineInfo info = (IXmlLineInfo)xmlReader;                                  CCLog.Log("Failed to handle XML tag: " + name + " in " + info.LineNumber + "@" + info.LinePosition + ":" + pszFile);                              }                          break;                        case XmlNodeType.EndElement:                          endElement(this' xmlReader.Name);                          dataindex++;                          break;                        default:                          break;                  }
Magic Number,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The following statement contains a magic number: switch (xmlReader.NodeType)                  {                      case XmlNodeType.Element:                            string[] attrs = null;                            if (name == "map")                          {                              Width = ccUtils.ccParseInt(xmlReader.GetAttribute("width"));                              Height = ccUtils.ccParseInt(xmlReader.GetAttribute("height"));                          }                            if (xmlReader.HasAttributes)                          {                              attrs = new string[xmlReader.AttributeCount * 2];                              xmlReader.MoveToFirstAttribute();                              int i = 0;                              attrs[0] = xmlReader.Name;                              attrs[1] = xmlReader.Value;                              i += 2;                                while (xmlReader.MoveToNextAttribute())                              {                                  attrs[i] = xmlReader.Name;                                  attrs[i + 1] = xmlReader.Value;                                  i += 2;                              }                                // Move the reader back to the element node.                              xmlReader.MoveToElement();                          }                          startElement(this' name' attrs);                            byte[] buffer = null;                            //read data content of tmx file                          if (name == "data")                          {                              if (attrs != null)                              {                                  string encoding = "";                                  for (int i = 0; i < attrs.Length; i++)                                  {                                      if (attrs[i] == "encoding")                                      {                                          encoding = attrs[i + 1];                                      }                                  }                                    if (encoding == "base64")                                  {                                      int dataSize = (Width * Height * 4) + 1024;                                      buffer = new byte[dataSize];                                      xmlReader.ReadElementContentAsBase64(buffer' 0' dataSize);                                  }                                  else                                  {                                      string value = xmlReader.ReadElementContentAsString();                                      buffer = Encoding.UTF8.GetBytes(value);                                  }                              }                                textHandler(this' buffer' buffer.Length);                              endElement(this' name);                          }                          else                              if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355                              {                                  string value = xmlReader.ReadElementContentAsString();                                  buffer = Encoding.UTF8.GetBytes(value);                                  textHandler(this' buffer' buffer.Length);                                  endElement(this' name);                              }                              else                              {                                  IXmlLineInfo info = (IXmlLineInfo)xmlReader;                                  CCLog.Log("Failed to handle XML tag: " + name + " in " + info.LineNumber + "@" + info.LinePosition + ":" + pszFile);                              }                          break;                        case XmlNodeType.EndElement:                          endElement(this' xmlReader.Name);                          dataindex++;                          break;                        default:                          break;                  }
Magic Number,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The following statement contains a magic number: switch (xmlReader.NodeType)                  {                      case XmlNodeType.Element:                            string[] attrs = null;                            if (name == "map")                          {                              Width = ccUtils.ccParseInt(xmlReader.GetAttribute("width"));                              Height = ccUtils.ccParseInt(xmlReader.GetAttribute("height"));                          }                            if (xmlReader.HasAttributes)                          {                              attrs = new string[xmlReader.AttributeCount * 2];                              xmlReader.MoveToFirstAttribute();                              int i = 0;                              attrs[0] = xmlReader.Name;                              attrs[1] = xmlReader.Value;                              i += 2;                                while (xmlReader.MoveToNextAttribute())                              {                                  attrs[i] = xmlReader.Name;                                  attrs[i + 1] = xmlReader.Value;                                  i += 2;                              }                                // Move the reader back to the element node.                              xmlReader.MoveToElement();                          }                          startElement(this' name' attrs);                            byte[] buffer = null;                            //read data content of tmx file                          if (name == "data")                          {                              if (attrs != null)                              {                                  string encoding = "";                                  for (int i = 0; i < attrs.Length; i++)                                  {                                      if (attrs[i] == "encoding")                                      {                                          encoding = attrs[i + 1];                                      }                                  }                                    if (encoding == "base64")                                  {                                      int dataSize = (Width * Height * 4) + 1024;                                      buffer = new byte[dataSize];                                      xmlReader.ReadElementContentAsBase64(buffer' 0' dataSize);                                  }                                  else                                  {                                      string value = xmlReader.ReadElementContentAsString();                                      buffer = Encoding.UTF8.GetBytes(value);                                  }                              }                                textHandler(this' buffer' buffer.Length);                              endElement(this' name);                          }                          else                              if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355                              {                                  string value = xmlReader.ReadElementContentAsString();                                  buffer = Encoding.UTF8.GetBytes(value);                                  textHandler(this' buffer' buffer.Length);                                  endElement(this' name);                              }                              else                              {                                  IXmlLineInfo info = (IXmlLineInfo)xmlReader;                                  CCLog.Log("Failed to handle XML tag: " + name + " in " + info.LineNumber + "@" + info.LinePosition + ":" + pszFile);                              }                          break;                        case XmlNodeType.EndElement:                          endElement(this' xmlReader.Name);                          dataindex++;                          break;                        default:                          break;                  }
Magic Number,cocos2d,CCSAXParser,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\CCSAXParser.cs,parse,The following statement contains a magic number: switch (xmlReader.NodeType)                  {                      case XmlNodeType.Element:                            string[] attrs = null;                            if (name == "map")                          {                              Width = ccUtils.ccParseInt(xmlReader.GetAttribute("width"));                              Height = ccUtils.ccParseInt(xmlReader.GetAttribute("height"));                          }                            if (xmlReader.HasAttributes)                          {                              attrs = new string[xmlReader.AttributeCount * 2];                              xmlReader.MoveToFirstAttribute();                              int i = 0;                              attrs[0] = xmlReader.Name;                              attrs[1] = xmlReader.Value;                              i += 2;                                while (xmlReader.MoveToNextAttribute())                              {                                  attrs[i] = xmlReader.Name;                                  attrs[i + 1] = xmlReader.Value;                                  i += 2;                              }                                // Move the reader back to the element node.                              xmlReader.MoveToElement();                          }                          startElement(this' name' attrs);                            byte[] buffer = null;                            //read data content of tmx file                          if (name == "data")                          {                              if (attrs != null)                              {                                  string encoding = "";                                  for (int i = 0; i < attrs.Length; i++)                                  {                                      if (attrs[i] == "encoding")                                      {                                          encoding = attrs[i + 1];                                      }                                  }                                    if (encoding == "base64")                                  {                                      int dataSize = (Width * Height * 4) + 1024;                                      buffer = new byte[dataSize];                                      xmlReader.ReadElementContentAsBase64(buffer' 0' dataSize);                                  }                                  else                                  {                                      string value = xmlReader.ReadElementContentAsString();                                      buffer = Encoding.UTF8.GetBytes(value);                                  }                              }                                textHandler(this' buffer' buffer.Length);                              endElement(this' name);                          }                          else                              if (name == "key" || name == "integer" || name == "real" || name == "string" || name == "true" || name == "false") // http://www.cocos2d-x.org/boards/17/topics/11355                              {                                  string value = xmlReader.ReadElementContentAsString();                                  buffer = Encoding.UTF8.GetBytes(value);                                  textHandler(this' buffer' buffer.Length);                                  endElement(this' name);                              }                              else                              {                                  IXmlLineInfo info = (IXmlLineInfo)xmlReader;                                  CCLog.Log("Failed to handle XML tag: " + name + " in " + info.LineNumber + "@" + info.LinePosition + ":" + pszFile);                              }                          break;                        case XmlNodeType.EndElement:                          endElement(this' xmlReader.Name);                          dataindex++;                          break;                        default:                          break;                  }
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CCRANDOM_MINUS1_1,The following statement contains a magic number: return (2.0f * ((float)rand.Next() / int.MaxValue)) - 1.0f;
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_DEGREES_TO_RADIANS,The following statement contains a magic number: return angle * 0.01745329252f;
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_RADIANS_TO_DEGREES,The following statement contains a magic number: return angle * 57.29577951f;
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP32,The following statement contains a magic number: return ((i & 0x000000ff) << 24 | (i & 0x0000ff00) << 8 | (i & 0x00ff0000) >> 8 | (i & 0xff000000) >> 24);
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP32,The following statement contains a magic number: return ((i & 0x000000ff) << 24 | (i & 0x0000ff00) << 8 | (i & 0x00ff0000) >> 8 | (i & 0xff000000) >> 24);
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP32,The following statement contains a magic number: return ((i & 0x000000ff) << 24 | (i & 0x0000ff00) << 8 | (i & 0x00ff0000) >> 8 | (i & 0xff000000) >> 24);
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP32,The following statement contains a magic number: return ((i & 0x000000ff) << 24 | (i & 0x0000ff00) << 8 | (i & 0x00ff0000) >> 8 | (i & 0xff000000) >> 24);
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP16,The following statement contains a magic number: return (ushort)((i & 0x00ff) << 8 | (i & 0xff00) >> 8);
Magic Number,cocos2d,ccMacros,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccMacros.cs,CC_SWAP16,The following statement contains a magic number: return (ushort)((i & 0x00ff) << 8 | (i & 0xff00) >> 8);
Magic Number,cocos2d,CCPointArray,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\CCPointArray.cs,reverseInline,The following statement contains a magic number: i < l / 2
Magic Number,cocos2d,CCPointExtension,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\CCPointExtension.cs,ccpMidpoint,The following statement contains a magic number: return ccpMult(ccpAdd(v1' v2)' 0.5f);
Magic Number,cocos2d,ccColor4B,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccColor4B,The following statement contains a magic number: a = 255;
Magic Number,cocos2d,ccColor4B,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,Parse,The following statement contains a magic number: return(new ccColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,cocos2d,ccColor4B,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,Parse,The following statement contains a magic number: return(new ccColor4B(byte.Parse(f[0])' byte.Parse(f[1])' byte.Parse(f[2])' byte.Parse(f[3])));
Magic Number,cocos2d,ccColor4F,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,Parse,The following statement contains a magic number: return(new ccColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,cocos2d,ccColor4F,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,Parse,The following statement contains a magic number: return(new ccColor4F(float.Parse(f[0])' float.Parse(f[1])' float.Parse(f[2])' float.Parse(f[3])));
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getVertices,The following statement contains a magic number: VertexPositionColorTexture[] vertices = new VertexPositionColorTexture[4];
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getVertices,The following statement contains a magic number: vertices[2] = new VertexPositionColorTexture(                      new Vector3(this.tl.vertices.x' this.tl.vertices.y' this.tl.vertices.z)'                      new Color(this.bl.colors.r' this.bl.colors.g' this.bl.colors.b' this.bl.colors.a)'                      new Vector2(this.tl.texCoords.u' this.tl.texCoords.v));
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getVertices,The following statement contains a magic number: vertices[3] = new VertexPositionColorTexture(                      new Vector3(this.tr.vertices.x' this.tr.vertices.y' this.tr.vertices.z)'                      new Color(this.br.colors.r' this.br.colors.g' this.br.colors.b' this.br.colors.a)'                      new Vector2(this.tr.texCoords.u' this.tr.texCoords.v));
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: short[] indexes = new short[6];
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[2] = 2;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[2] = 2;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[3] = 2;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[3] = 2;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[4] = 1;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[5] = 3;
Magic Number,cocos2d,ccV3F_C4B_T2F_Quad,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,getIndexes,The following statement contains a magic number: indexes[5] = 3;
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc3B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' 1.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc3B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' 1.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc3B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' 1.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc4B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' c.a / 255.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc4B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' c.a / 255.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc4B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' c.a / 255.0f);
Magic Number,cocos2d,ccTypes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\predefine\ccTypes.cs,ccc4FFromccc4B,The following statement contains a magic number: ccColor4F c4 = new ccColor4F(c.r / 255.0f' c.g / 255.0f' c.b / 255.0f' c.a / 255.0f);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_nOpacity = 255;
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColor = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColorUnmodified = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColorUnmodified = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: m_sColorUnmodified = new ccColor3B(255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: anchorPoint = (CCPointExtension.ccp(0.5f' 0.5f));
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: anchorPoint = (CCPointExtension.ccp(0.5f' 0.5f));
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: ccColor4B tmpColor = new ccColor4B(255' 255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: ccColor4B tmpColor = new ccColor4B(255' 255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: ccColor4B tmpColor = new ccColor4B(255' 255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,init,The following statement contains a magic number: ccColor4B tmpColor = new ccColor4B(255' 255' 255' 255);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,draw,The following statement contains a magic number: app.basicEffect.Alpha = (float)this.Opacity / 255.0f;
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,draw,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices' 0' 4'                      indexes' 0' 2);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,draw,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices' 0' 4'                      indexes' 0' 2);
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,setTextureRectInPixels,The following statement contains a magic number: m_obOffsetPositionInPixels.x = relativeOffsetInPixels.x + (m_tContentSizeInPixels.width - m_obRectInPixels.size.width) / 2;
Magic Number,cocos2d,CCSprite,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSprite.cs,setTextureRectInPixels,The following statement contains a magic number: m_obOffsetPositionInPixels.y = relativeOffsetInPixels.y + (m_tContentSizeInPixels.height - m_obRectInPixels.size.height) / 2;
Magic Number,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,increaseAtlasCapacity,The following statement contains a magic number: int quantity = (m_pobTextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,increaseAtlasCapacity,The following statement contains a magic number: int quantity = (m_pobTextureAtlas.Capacity + 1) * 4 / 3;
Magic Number,cocos2d,CCSpriteBatchNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteBatchNode.cs,addQuadFromSprite,The following statement contains a magic number: index == -901
Magic Number,cocos2d,CCSpriteFrameCache,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\sprite_nodes\CCSpriteFrameCache.cs,addSpriteFramesWithDictionary,The following statement contains a magic number: Debug.Assert(format >= 0 && format <= 3);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float s = (1 - tension) / 2;
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b1 = s * ((-t3 + (2 * t2)) - t);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccCardinalSplineAt,The following statement contains a magic number: float b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 2);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 4);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 8);
Magic Number,cocos2d,ccUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\ccUtils.cs,ccNextPOT,The following statement contains a magic number: x = x | (x >> 16);
Magic Number,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,The following statement contains a magic number: stroke *= 0.5f;
Magic Number,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,The following statement contains a magic number: idx = i * 2;
Magic Number,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,The following statement contains a magic number: idx = i * 2;
Magic Number,cocos2d,CCVertex,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\CCVertex.cs,LineToPolygon,The following statement contains a magic number: int idx1 = idx + 2;
Magic Number,cocos2d,ccCArray,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\data_support\ccCArray.cs,ccCArrayDoubleCapacity,The following statement contains a magic number: arr.max *= 2;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: Matrix mat = new Matrix()              {                  M11 = m[0]'M21 = m[4]'M31 = m[8]'M41 = m[12]'                  M12 = m[1]'M22 = m[5]'M32 = m[9]'M42 = m[13]'                  M13 = m[2]'M23 = m[6]'M33 = m[10]'M43 = m[14]'                  M14 = m[3]'M24 = m[7]'M34 = m[11]'M44 = m[15]'              };
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToMatrix,The following statement contains a magic number: float[] m = new float[16];
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[2] = m[3] = m[6] = m[7] = m[8] = m[9] = m[11] = m[14] = 0.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[10] = m[15] = 1.0f;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[4] = t.c;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[12] = t.tx;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[5] = t.d;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,CGAffineToGL,The following statement contains a magic number: m[13] = t.ty;
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.c = m[4];
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.tx = m[12];
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.d = m[5];
Magic Number,cocos2d,TransformUtils,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\TransformUtils.cs,GLToCGAffine,The following statement contains a magic number: t.ty = m[13];
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initWithTexture,The following statement contains a magic number: m_pIndices = new short[m_uCapacity * 6];
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 0] = (short)(i * 4 + 0);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 0] = (short)(i * 4 + 0);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 1] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 1] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 3] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 3] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 3] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 3] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 4] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 4] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 4] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 4] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 5] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 5] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,initIndices,The following statement contains a magic number: m_pIndices[i * 6 + 5] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,resizeCapacity,The following statement contains a magic number: m_pIndices = new short[m_uCapacity * 6];
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: short[] indexes = new short[n * 6];
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 0] = (short)(i * 4 + 0);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 0] = (short)(i * 4 + 0);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 1] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 1] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 2] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 3] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 3] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 3] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 3] = (short)(i * 4 + 2);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 4] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 4] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 4] = (short)(i * 4 + 1);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 5] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 5] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 5] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: indexes[i * 6 + 5] = (short)(i * 4 + 3);
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Vector3' VertexElementUsage.Color' 0)'                      new VertexElement(24' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  });
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: VertexDeclaration vertexDeclaration = new VertexDeclaration(new VertexElement[]                  {                      new VertexElement(0' VertexElementFormat.Vector3' VertexElementUsage.Position' 0)'                      new VertexElement(12' VertexElementFormat.Vector3' VertexElementUsage.Color' 0)'                      new VertexElement(24' VertexElementFormat.Vector2' VertexElementUsage.TextureCoordinate' 0)                  });
Magic Number,cocos2d,CCTextureAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTextureAtlas.cs,drawNumberOfQuads,The following statement contains a magic number: app.GraphicsDevice.DrawUserIndexedPrimitives<VertexPositionColorTexture>(                      PrimitiveType.TriangleList'                      vertices.ToArray()' 0' vertices.Count'                      indexes' 0' vertices.Count / 2);
Magic Number,cocos2d,CCTextFieldTTF,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\text_input_node\CCTextFieldTTF .cs,CCTextFieldTTF,The following statement contains a magic number: m_ColorSpaceHolder.r = m_ColorSpaceHolder.g = m_ColorSpaceHolder.b = 127;
Magic Number,cocos2d,CCParallaxNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: m_tLastPosition = new CCPoint(-100' -100);
Magic Number,cocos2d,CCParallaxNode,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCParallaxNode.cs,CCParallaxNode,The following statement contains a magic number: m_tLastPosition = new CCPoint(-100' -100);
Magic Number,cocos2d,CCTileMapAtlas,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTileMapAtlas.cs,calculateItemsToRender,The following statement contains a magic number: ccColor3B ptr = new ccColor3B() { r = m_pTGAInfo.imageData[0]' g = m_pTGAInfo.imageData[1]' b = m_pTGAInfo.imageData[2] };
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,initWithTilesetInfo,The following statement contains a magic number: float capacity = totalNumberOfTiles * 0.35f + 1;
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForIsoAt,The following statement contains a magic number: CCPoint xy = new CCPoint(m_tMapTileSize.width / 2 * (m_tLayerSize.width + pos.x - pos.y - 1)'                                   m_tMapTileSize.height / 2 * ((m_tLayerSize.height * 2 - pos.x - pos.y) - 2));
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForIsoAt,The following statement contains a magic number: CCPoint xy = new CCPoint(m_tMapTileSize.width / 2 * (m_tLayerSize.width + pos.x - pos.y - 1)'                                   m_tMapTileSize.height / 2 * ((m_tLayerSize.height * 2 - pos.x - pos.y) - 2));
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForIsoAt,The following statement contains a magic number: CCPoint xy = new CCPoint(m_tMapTileSize.width / 2 * (m_tLayerSize.width + pos.x - pos.y - 1)'                                   m_tMapTileSize.height / 2 * ((m_tLayerSize.height * 2 - pos.x - pos.y) - 2));
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForIsoAt,The following statement contains a magic number: CCPoint xy = new CCPoint(m_tMapTileSize.width / 2 * (m_tLayerSize.width + pos.x - pos.y - 1)'                                   m_tMapTileSize.height / 2 * ((m_tLayerSize.height * 2 - pos.x - pos.y) - 2));
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForHexAt,The following statement contains a magic number: diffY = -m_tMapTileSize.height / 2;
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForHexAt,The following statement contains a magic number: (int)pos.x % 2 == 1
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForHexAt,The following statement contains a magic number: CCPoint xy = new CCPoint(pos.x * m_tMapTileSize.width * 3 / 4'                                      (m_tLayerSize.height - pos.y - 1) * m_tMapTileSize.height + diffY);
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionForHexAt,The following statement contains a magic number: CCPoint xy = new CCPoint(pos.x * m_tMapTileSize.width * 3 / 4'                                      (m_tLayerSize.height - pos.y - 1) * m_tMapTileSize.height + diffY);
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,calculateLayerOffset,The following statement contains a magic number: switch (m_uLayerOrientation)              {                  case CCTMXOrientatio.CCTMXOrientationOrtho:                      ret = new CCPoint(pos.x * m_tMapTileSize.width' -pos.y * m_tMapTileSize.height);                      break;                  case CCTMXOrientatio.CCTMXOrientationHex:                      Debug.Assert(CCPoint.CCPointEqualToPoint(pos' new CCPoint(0' 0))' "offset for hexagonal map not implemented yet");                      break;                  case CCTMXOrientatio.CCTMXOrientationIso:                      ret = new CCPoint((m_tMapTileSize.width / 2) * (pos.x - pos.y)'                                     (m_tMapTileSize.height / 2) * (-pos.x - pos.y));                      break;              }
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,calculateLayerOffset,The following statement contains a magic number: switch (m_uLayerOrientation)              {                  case CCTMXOrientatio.CCTMXOrientationOrtho:                      ret = new CCPoint(pos.x * m_tMapTileSize.width' -pos.y * m_tMapTileSize.height);                      break;                  case CCTMXOrientatio.CCTMXOrientationHex:                      Debug.Assert(CCPoint.CCPointEqualToPoint(pos' new CCPoint(0' 0))' "offset for hexagonal map not implemented yet");                      break;                  case CCTMXOrientatio.CCTMXOrientationIso:                      ret = new CCPoint((m_tMapTileSize.width / 2) * (pos.x - pos.y)'                                     (m_tMapTileSize.height / 2) * (-pos.x - pos.y));                      break;              }
Magic Number,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,appendTileForGID,The following statement contains a magic number: m_pReusedTile.Opacity = 255;
Magic Number,cocos2d,CCTMXLayerInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayerInfo.cs,CCTMXLayerInfo,The following statement contains a magic number: m_uMinGID = 100000;
Magic Number,cocos2d,CCTMXTilesetInfo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXTilesetInfo.cs,rectForGID,The following statement contains a magic number: int max_x = (int)((m_tImageSize.width - m_uMargin * 2 + m_uSpacing) / (m_tTileSize.width + m_uSpacing));
Magic Number,cocos2d.actions,CCCatmullRomTo,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\actions\action_intervals\CCCatmullRomTo.cs,initWithDuration,The following statement contains a magic number: base.initWithDuration(dt' points' 0.5f)
Magic Number,WP7Contrib.Communications.Compression,Adler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Adler.cs,Adler32,The following statement contains a magic number: long num2 = adler >> 16 & (long)ushort.MaxValue;
Magic Number,WP7Contrib.Communications.Compression,Adler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Adler.cs,Adler32,The following statement contains a magic number: num3 -= 16;
Magic Number,WP7Contrib.Communications.Compression,Adler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Adler.cs,Adler32,The following statement contains a magic number: num3 >= 16
Magic Number,WP7Contrib.Communications.Compression,Adler,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Adler.cs,Adler32,The following statement contains a magic number: return num2 << 16 | num1;
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,Crc32,The following statement contains a magic number: uint num1 = 3988292384U;
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,Crc32,The following statement contains a magic number: Crc32.crc32Table = new uint[256];
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,Crc32,The following statement contains a magic number: index1 < 256U
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,GetCrc32AndCopy,The following statement contains a magic number: byte[] numArray = new byte[8192];
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,GetCrc32AndCopy,The following statement contains a magic number: int count1 = 8192;
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,_InternalComputeCrc32,The following statement contains a magic number: return (int)Crc32.crc32Table[((int)W ^ (int)B) & (int)byte.MaxValue] ^ (int)(W >> 8);
Magic Number,WP7Contrib.Communications.Compression,Crc32,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\Crc32.cs,SlurpBlock,The following statement contains a magic number: this._RunningCrc32Result = this._RunningCrc32Result >> 8 ^ Crc32.crc32Table[(int) ((uint)block[index2] ^ this._RunningCrc32Result & (uint)byte.MaxValue)];
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: byte[] buffer = new byte[10 + num1 + num2];
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: int num6 = 31;
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: int num9 = 139;
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: int num12 = 8;
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: num13 ^= (byte)16;
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: num13 ^= (byte)8;
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: Array.Copy((Array)BitConverter.GetBytes((int)(this.LastModified.Value - GZipStream._unixEpoch).TotalSeconds)' 0' (Array)buffer' destinationIndex1' 4);
Magic Number,WP7Contrib.Communications.Compression,GZipStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\GZipStream.cs,EmitHeader,The following statement contains a magic number: int num16 = destinationIndex1 + 4;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,InflateBlocks,The following statement contains a magic number: this.hufts = new int[4320];
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Reset,The following statement contains a magic number: this.mode != 4 && this.mode != 5
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Reset,The following statement contains a magic number: this.mode != 4 && this.mode != 5
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Reset,The following statement contains a magic number: this.mode != 6
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          while (num2 < 3)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int number2 = number1 & 7;                          this.last = number2 & 1;                          switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }                          break;                      case 1:                          while (num2 < 32)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          if ((SharedUtils.URShift(~number1' 16) & (int)ushort.MaxValue) == (number1 & (int)ushort.MaxValue))                          {                              this.left = number1 & (int)ushort.MaxValue;                              number1 = num2 = 0;                              this.mode = this.left != 0 ? 2 : (this.last != 0 ? 7 : 0);                              break;                          }                          else                              goto label_15;                      case 2:                          if (num1 != 0)                          {                              if (num3 == 0)                              {                                  if (destinationIndex == this.end && this.read != 0)                                  {                                      destinationIndex = 0;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                  }                                  if (num3 == 0)                                  {                                      this.write = destinationIndex;                                      r = this.Flush(r);                                      destinationIndex = this.write;                                      num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      if (destinationIndex == this.end && this.read != 0)                                      {                                          destinationIndex = 0;                                          num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                                      }                                      if (num3 == 0)                                          goto label_26;                                  }                              }                              r = 0;                              int length = this.left;                              if (length > num1)                                  length = num1;                              if (length > num3)                                  length = num3;                              Array.Copy((Array)this._codec.InputBuffer' sourceIndex' (Array)this.window' destinationIndex' length);                              sourceIndex += length;                              num1 -= length;                              destinationIndex += length;                              num3 -= length;                              if ((this.left -= length) == 0)                              {                                  this.mode = this.last != 0 ? 7 : 0;                                  break;                              }                              else                                  break;                          }                          else                              goto label_18;                      case 3:                          while (num2 < 14)                          {                              if (num1 != 0)                              {                                  r = 0;                                  --num1;                                  number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                  num2 += 8;                              }                              else                              {                                  this.bitb = number1;                                  this.bitk = num2;                                  this._codec.AvailableBytesIn = num1;                                  this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                  this._codec.NextIn = sourceIndex;                                  this.write = destinationIndex;                                  return this.Flush(r);                              }                          }                          int num7;                          this.table = num7 = number1 & 16383;                          if ((num7 & 31) <= 29 && (num7 >> 5 & 31) <= 29)                          {                              int length = 258 + (num7 & 31) + (num7 >> 5 & 31);                              if (this.blens == null || this.blens.Length < length)                              {                                  this.blens = new int[length];                              }                              else                              {                                  for (int index = 0; index < length; ++index)                                      this.blens[index] = 0;                              }                              number1 = SharedUtils.URShift(number1' 14);                              num2 -= 14;                              this.index = 0;                              this.mode = 4;                              goto case 4;                          }                          else                              goto label_39;                      case 4:                          while (this.index < 4 + SharedUtils.URShift(this.table' 10))                          {                              while (num2 < 3)                              {                                  if (num1 != 0)                                  {                                      r = 0;                                      --num1;                                      number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                      num2 += 8;                                  }                                  else                                  {                                      this.bitb = number1;                                      this.bitk = num2;                                      this._codec.AvailableBytesIn = num1;                                      this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                      this._codec.NextIn = sourceIndex;                                      this.write = destinationIndex;                                      return this.Flush(r);                                  }                              }                              this.blens[InflateBlocks.border[this.index++]] = number1 & 7;                              number1 = SharedUtils.URShift(number1' 3);                              num2 -= 3;                          }                          while (this.index < 19)                              this.blens[InflateBlocks.border[this.index++]] = 0;                          this.bb[0] = 7;                          num4 = this.inftree.inflate_trees_bits(this.blens' this.bb' this.tb' this.hufts' this._codec);                          if (num4 == 0)                          {                              this.index = 0;                              this.mode = 5;                              goto case 5;                          }                          else                              goto label_55;                      case 5:                          while (true)                          {                              int num8 = this.table;                              if (this.index < 258 + (num8 & 31) + (num8 >> 5 & 31))                              {                                  int index = this.bb[0];                                  while (num2 < index)                                  {                                      if (num1 != 0)                                      {                                          r = 0;                                          --num1;                                          number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                          num2 += 8;                                      }                                      else                                      {                                          this.bitb = number1;                                          this.bitk = num2;                                          this._codec.AvailableBytesIn = num1;                                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                          this._codec.NextIn = sourceIndex;                                          this.write = destinationIndex;                                          return this.Flush(r);                                      }                                  }                                  if (this.tb[0] != -1)                                  {}                                  int bits2 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[index])) * 3 + 1];                                  int num9 = this.hufts[(this.tb[0] + (number1 & InflateBlocks.inflate_mask[bits2])) * 3 + 2];                                  if (num9 < 16)                                  {                                      number1 = SharedUtils.URShift(number1' bits2);                                      num2 -= bits2;                                      this.blens[this.index++] = num9;                                  }                                  else                                  {                                      int bits3 = num9 == 18 ? 7 : num9 - 14;                                      int num10 = num9 == 18 ? 11 : 3;                                      while (num2 < bits2 + bits3)                                      {                                          if (num1 != 0)                                          {                                              r = 0;                                              --num1;                                              number1 |= ((int)this._codec.InputBuffer[sourceIndex++] & (int)byte.MaxValue) << num2;                                              num2 += 8;                                          }                                          else                                          {                                              this.bitb = number1;                                              this.bitk = num2;                                              this._codec.AvailableBytesIn = num1;                                              this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                                              this._codec.NextIn = sourceIndex;                                              this.write = destinationIndex;                                              return this.Flush(r);                                          }                                      }                                      int number4 = SharedUtils.URShift(number1' bits2);                                      int num11 = num2 - bits2;                                      int num12 = num10 + (number4 & InflateBlocks.inflate_mask[bits3]);                                      number1 = SharedUtils.URShift(number4' bits3);                                      num2 = num11 - bits3;                                      int num13 = this.index;                                      int num14 = this.table;                                      if (num13 + num12 <= 258 + (num14 & 31) + (num14 >> 5 & 31) && (num9 != 16 || num13 >= 1))                                      {                                          int num15 = num9 == 16 ? this.blens[num13 - 1] : 0;                                          do                                          {                                              this.blens[num13++] = num15;                                          }                                          while (--num12 != 0);                                          this.index = num13;                                      }                                      else                                          goto label_73;                                  }                              }                              else                                  break;                          }                          this.tb[0] = -1;                          int[] bl2 = new int[1]                                          {                                              9                                          };                          int[] bd2 = new int[1]                                          {                                              6                                          };                          int[] tl2 = new int[1];                          int[] td2 = new int[1];                          int num16 = this.table;                          num5 = this.inftree.inflate_trees_dynamic(257 + (num16 & 31)' 1 + (num16 >> 5 & 31)' this.blens' bl2' bd2' tl2' td2' this.hufts' this._codec);                          switch (num5)                          {                              case 0:                                  this.codes.Init(bl2[0]' bd2[0]' this.hufts' tl2[0]' this.hufts' td2[0]);                                  this.mode = 6;                                  goto label_83;                              case -3:                                  goto label_80;                              default:                                  goto label_81;                          }                      case 6:                          label_83:                          this.bitb = number1;                          this.bitk = num2;                          this._codec.AvailableBytesIn = num1;                          this._codec.TotalBytesIn += (long)(sourceIndex - this._codec.NextIn);                          this._codec.NextIn = sourceIndex;                          this.write = destinationIndex;                          if ((r = this.codes.Process(this' r)) == 1)                          {                              r = 0;                              sourceIndex = this._codec.NextIn;                              num1 = this._codec.AvailableBytesIn;                              number1 = this.bitb;                              num2 = this.bitk;                              destinationIndex = this.write;                              num3 = destinationIndex < this.read ? this.read - destinationIndex - 1 : this.end - destinationIndex;                              if (this.last == 0)                              {                                  this.mode = 0;                                  break;                              }                              else                                  goto label_87;                          }                          else                              goto label_84;                      case 7:                          goto label_88;                      case 8:                          goto label_91;                      case 9:                          goto label_92;                      default:                          goto label_93;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: int num17 = SharedUtils.URShift(number1' 3);
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: int num18 = num2 - 3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r == -3
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: this.mode = 7;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following statement contains a magic number: r = -2;
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Flush,The following statement contains a magic number: num2 != 0 && r == -5
Magic Number,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Flush,The following statement contains a magic number: num5 != 0 && r == -5
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (num5 >= 258 && num2 >= 10)                          {                              blocks.bitb = number;                              blocks.bitk = num3;                              z.AvailableBytesIn = num2;                              z.TotalBytesIn += (long)(num1 - z.NextIn);                              z.NextIn = num1;                              blocks.write = num4;                              r = this.InflateFast((int)this.lbits' (int)this.dbits' this.ltree' this.ltree_index' this.dtree' this.dtree_index' blocks' z);                              num1 = z.NextIn;                              num2 = z.AvailableBytesIn;                              number = blocks.bitb;                              num3 = blocks.bitk;                              num4 = blocks.write;                              num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              if (r != 0)                              {                                  this.mode = r == 1 ? 7 : 9;                                  break;                              }                          }                          this.need = (int)this.lbits;                          this.tree = this.ltree;                          this.tree_index = this.ltree_index;                          this.mode = 1;                          goto case 1;                      case 1:                          int index1 = this.need;                          while (num3 < index1)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index2 = (this.tree_index + (number & InflateCodes.inflate_mask[index1])) * 3;                          number = SharedUtils.URShift(number' this.tree[index2 + 1]);                          num3 -= this.tree[index2 + 1];                          int num6 = this.tree[index2];                          if (num6 == 0)                          {                              this.lit = this.tree[index2 + 2];                              this.mode = 6;                              break;                          }                          else if ((num6 & 16) != 0)                          {                              this.get_Renamed = num6 & 15;                              this.len = this.tree[index2 + 2];                              this.mode = 2;                              break;                          }                          else if ((num6 & 64) == 0)                          {                              this.need = num6;                              this.tree_index = index2 / 3 + this.tree[index2 + 2];                              break;                          }                          else if ((num6 & 32) != 0)                          {                              this.mode = 7;                              break;                          }                          else                              goto label_18;                      case 2:                          int index3 = this.get_Renamed;                          while (num3 < index3)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.len += number & InflateCodes.inflate_mask[index3];                          number >>= index3;                          num3 -= index3;                          this.need = (int)this.dbits;                          this.tree = this.dtree;                          this.tree_index = this.dtree_index;                          this.mode = 3;                          goto case 3;                      case 3:                          int index4 = this.need;                          while (num3 < index4)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          int index5 = (this.tree_index + (number & InflateCodes.inflate_mask[index4])) * 3;                          number >>= this.tree[index5 + 1];                          num3 -= this.tree[index5 + 1];                          int num7 = this.tree[index5];                          if ((num7 & 16) != 0)                          {                              this.get_Renamed = num7 & 15;                              this.dist = this.tree[index5 + 2];                              this.mode = 4;                              break;                          }                          else if ((num7 & 64) == 0)                          {                              this.need = num7;                              this.tree_index = index5 / 3 + this.tree[index5 + 2];                              break;                          }                          else                              goto label_34;                      case 4:                          int index6 = this.get_Renamed;                          while (num3 < index6)                          {                              if (num2 != 0)                              {                                  r = 0;                                  --num2;                                  number |= ((int)z.InputBuffer[num1++] & (int)byte.MaxValue) << num3;                                  num3 += 8;                              }                              else                              {                                  blocks.bitb = number;                                  blocks.bitk = num3;                                  z.AvailableBytesIn = num2;                                  z.TotalBytesIn += (long)(num1 - z.NextIn);                                  z.NextIn = num1;                                  blocks.write = num4;                                  return blocks.Flush(r);                              }                          }                          this.dist += number & InflateCodes.inflate_mask[index6];                          number >>= index6;                          num3 -= index6;                          this.mode = 5;                          goto case 5;                      case 5:                          int num8 = num4 - this.dist;                          while (num8 < 0)                              num8 += blocks.end;                          for (; this.len != 0; --this.len)                          {                              if (num5 == 0)                              {                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                  {                                      blocks.write = num4;                                      r = blocks.Flush(r);                                      num4 = blocks.write;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      if (num4 == blocks.end && blocks.read != 0)                                      {                                          num4 = 0;                                          num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                      }                                      if (num5 == 0)                                      {                                          blocks.bitb = number;                                          blocks.bitk = num3;                                          z.AvailableBytesIn = num2;                                          z.TotalBytesIn += (long)(num1 - z.NextIn);                                          z.NextIn = num1;                                          blocks.write = num4;                                          return blocks.Flush(r);                                      }                                  }                              }                              blocks.window[num4++] = blocks.window[num8++];                              --num5;                              if (num8 == blocks.end)                                  num8 = 0;                          }                          this.mode = 0;                          break;                      case 6:                          if (num5 == 0)                          {                              if (num4 == blocks.end && blocks.read != 0)                              {                                  num4 = 0;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                              }                              if (num5 == 0)                              {                                  blocks.write = num4;                                  r = blocks.Flush(r);                                  num4 = blocks.write;                                  num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  if (num4 == blocks.end && blocks.read != 0)                                  {                                      num4 = 0;                                      num5 = num4 < blocks.read ? blocks.read - num4 - 1 : blocks.end - num4;                                  }                                  if (num5 == 0)                                      goto label_65;                              }                          }                          r = 0;                          blocks.window[num4++] = (byte)this.lit;                          --num5;                          this.mode = 0;                          break;                      case 7:                          goto label_68;                      case 8:                          goto label_73;                      case 9:                          goto label_74;                      default:                          goto label_75;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: this.mode = 9;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: num3 -= 8;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: r = -3;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,Process,The following statement contains a magic number: r = -2;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: num4 += 8;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: num4 < 20
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: int index1 = (num9 + num8) * 3;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: s.window[destinationIndex++] = (byte)numArray1[index1 + 2];
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: int num30 = num4 >> 3 < num29 ? num4 >> 3 : num29;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: int num30 = num4 >> 3 < num29 ? num4 >> 3 : num29;
Magic Number,WP7Contrib.Communications.Compression,InflateCodes,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateCodes.cs,InflateFast,The following statement contains a magic number: int num33 = num4 - (num30 << 3);
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Reset,The following statement contains a magic number: this.mode = this.HandleRfc1950HeaderBytes ? 0 : 7;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Initialize,The following statement contains a magic number: w < 8 || w > 15
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: int num2 = num1 == 4 ? -5 : 0;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: int num2 = num1 == 4 ? -5 : 0;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: int r = -5;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: switch (this.mode)                  {                      case 0:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              InflateManager inflateManager = this;                              byte[] numArray = this._codec.InputBuffer;                              int index = this._codec.NextIn++;                              int num3;                              int num4 = num3 = (int)numArray[index];                              inflateManager.method = num3;                              if ((num4 & 15) != 8)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("unknown compression method (0x{0:X2})"' (object)this.method);                                  this.marker = 5;                                  break;                              }                              else if ((this.method >> 4) + 8 > this.wbits)                              {                                  this.mode = 13;                                  this._codec.Message = string.Format("invalid window size ({0})"' (object)((this.method >> 4) + 8));                                  this.marker = 5;                                  break;                              }                              else                              {                                  this.mode = 1;                                  goto case 1;                              }                          }                          else                              goto label_4;                      case 1:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              int num3 = (int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue;                              if (((this.method << 8) + num3) % 31 != 0)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect header check";                                  this.marker = 5;                                  break;                              }                              else if ((num3 & 32) == 0)                              {                                  this.mode = 7;                                  break;                              }                              else                                  goto label_16;                          }                          else                              goto label_11;                      case 2:                          goto label_17;                      case 3:                          goto label_20;                      case 4:                          goto label_23;                      case 5:                          goto label_26;                      case 6:                          goto label_29;                      case 7:                          r = this.blocks.Process(r);                          if (r == -3)                          {                              this.mode = 13;                              this.marker = 0;                              break;                          }                          else                          {                              if (r == 0)                                  r = num2;                              if (r == 1)                              {                                  r = num2;                                  this.blocks.Reset(this.was);                                  if (!this.HandleRfc1950HeaderBytes)                                  {                                      this.mode = 12;                                      break;                                  }                                  else                                  {                                      this.mode = 8;                                      goto case 8;                                  }                              }                              else                                  goto label_35;                          }                      case 8:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);                              this.mode = 9;                              goto case 9;                          }                          else                              goto label_40;                      case 9:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;                              this.mode = 10;                              goto case 10;                          }                          else                              goto label_43;                      case 10:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;                              this.mode = 11;                              goto case 11;                          }                          else                              goto label_46;                      case 11:                          if (this._codec.AvailableBytesIn != 0)                          {                              r = num2;                              --this._codec.AvailableBytesIn;                              ++this._codec.TotalBytesIn;                              this.need += (long)this._codec.InputBuffer[this._codec.NextIn++] & (long)byte.MaxValue;                              if ((int)this.was[0] != (int)this.need)                              {                                  this.mode = 13;                                  this._codec.Message = "incorrect data check";                                  this.marker = 5;                                  break;                              }                              else                                  goto label_52;                          }                          else                              goto label_49;                      case 12:                          goto label_53;                      case 13:                          goto label_54;                      default:                          goto label_55;                  }
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 2;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need = (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 24 & -16777216);
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 3;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 16) & 16711680L;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 4;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.need += (long)(((int)this._codec.InputBuffer[this._codec.NextIn++] & (int)byte.MaxValue) << 8) & 65280L;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 5;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 6;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: return 2;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 13;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: return -2;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Inflate,The following statement contains a magic number: this.mode = 12;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,SetDictionary,The following statement contains a magic number: this.mode != 6
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,SetDictionary,The following statement contains a magic number: return -3;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,SetDictionary,The following statement contains a magic number: this.mode = 7;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: this.mode = 13;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: this.mode != 13
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: return -5;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: num1 != 0 && index2 < 4
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: return -3;
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: index2 != 4
Magic Number,WP7Contrib.Communications.Compression,InflateManager,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateManager.cs,Sync,The following statement contains a magic number: this.mode = 7;
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: this.initWorkArea(19);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int num1 = this.huft_build(c' 0' 19' 19' (int[])null' (int[])null' tb' bb' hp' this.hn' this.v);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int num1 = this.huft_build(c' 0' 19' 19' (int[])null' (int[])null' tb' bb' hp' this.hn' this.v);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: switch (num1)              {                  case -3:                      z.Message = "oversubscribed dynamic bit lengths tree";                      goto label_6;                  case -5:                      num2 = 0;                      break;                  default:                      num2 = bb[0] != 0 ? 1 : 0;                      break;              }
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: switch (num1)              {                  case -3:                      z.Message = "oversubscribed dynamic bit lengths tree";                      goto label_6;                  case -5:                      num2 = 0;                      break;                  default:                      num2 = bb[0] != 0 ? 1 : 0;                      break;              }
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: num1 = -3;
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: this.initWorkArea(288);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: int num1 = this.huft_build(c' 0' nl' 257' InfTree.cplens' InfTree.cplext' tl' bl' hp' this.hn' this.v);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: num1 == -3
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_fixed,The following statement contains a magic number: bl[0] = 9;
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,inflate_trees_fixed,The following statement contains a magic number: bd[0] = 5;
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: this.c = new int[16];
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: this.r = new int[3];
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: this.u = new int[15];
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: this.x = new int[16];
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: index < 16
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: index < 3
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: Array.Copy((Array)this.c' 0' (Array)this.u' 0' 15);
Magic Number,WP7Contrib.Communications.Compression,InfTree,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InfTree.cs,initWorkArea,The following statement contains a magic number: Array.Copy((Array)this.c' 0' (Array)this.x' 0' 16);
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,Write,The following statement contains a magic number: flag = this._z.AvailableBytesIn == 8 && this._z.AvailableBytesOut != 0;
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,finish,The following statement contains a magic number: flag = this._z.AvailableBytesIn == 8 && this._z.AvailableBytesOut != 0;
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: byte[] buffer1 = new byte[10];
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,_ReadAndValidateGzipHeader,The following statement contains a magic number: switch (num2)              {                  case 0:                      return 0;                  case 10:                      if ((int)buffer1[0] != 31 || (int)buffer1[1] != 139 || (int)buffer1[2] != 8)                          throw new ZlibException("Bad GZIP header.");                        int num3 = BitConverter.ToInt32(buffer1' 4);                      this._GzipMtime = GZipStream._unixEpoch.AddSeconds((double)num3);                      int num4 = num1 + num2;                      if (((int)buffer1[3] & 4) == 4)                      {                          int num5 = this._stream.Read(buffer1' 0' 2);                          int num6 = num4 + num5;                          short num7 = (short)((int)buffer1[0] + (int)buffer1[1] * 256);                          byte[] buffer2 = new byte[(int)num7];                          int num8 = this._stream.Read(buffer2' 0' buffer2.Length);                          if (num8 != (int)num7)                              throw new ZlibException("Unexpected end-of-file reading GZIP header.");                          num4 = num6 + num8;                      }                      if (((int)buffer1[3] & 8) == 8)                          this._GzipFileName = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 16) == 16)                          this._GzipComment = this.ReadZeroTerminatedString();                      if (((int)buffer1[3] & 2) == 2)                          this.Read(this._buf1' 0' 1);                      return num4;                  default:                      throw new ZlibException("Not a valid GZIP stream.");              }
Magic Number,WP7Contrib.Communications.Compression,ZlibBaseStream,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\ZlibBaseStream.cs,Read,The following statement contains a magic number: this.nomoreinput && num == -5
Duplicate Code,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,updateBar,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 78)' (110' 131))
Duplicate Code,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The method contains a code clone-set at the following line numbers (starting from the method definition): ((15' 34)' (189' 208))
Missing Default,cocos2d,CCDirector,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\CCDirector.cs,applyOrientation,The following switch statement is missing a default case: switch (m_eDeviceOrientation)              {                  case ccDeviceOrientation.CCDeviceOrientationPortrait:                      // nothing                      break;                  case ccDeviceOrientation.CCDeviceOrientationPortraitUpsideDown:                      // upside down                      //glTranslatef(w' h' 0);                      //glRotatef(180' 0' 0' 1);                      //glTranslatef(-w' -h' 0);                      break;                  case ccDeviceOrientation.CCDeviceOrientationLandscapeRight:                      //glTranslatef(w' h' 0);                      //glRotatef(90' 0' 0' 1);                      //glTranslatef(-h' -w' 0);                      break;                  case ccDeviceOrientation.CCDeviceOrientationLandscapeLeft:                      //glTranslatef(w' h' 0);                      //glRotatef(-90' 0' 0' 1);                      //glTranslatef(-h' -w' 0);                      break;              }
Missing Default,cocos2d,CCProgressTimer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\misc_nodes\CCProgressTimer.cs,getIndexes,The following switch statement is missing a default case: switch (m_eType)                  {                      case CCProgressTimerType.kCCProgressTimerTypeRadialCCW:                          indexes = new short[15];                            indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                            indexes[3] = 2;                          indexes[4] = 0;                          indexes[5] = 3;                            indexes[6] = 3;                          indexes[7] = 0;                          indexes[8] = 4;                            indexes[9] = 4;                          indexes[10] = 0;                          indexes[11] = 5;                            indexes[12] = 5;                          indexes[13] = 0;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeRadialCW:                          indexes = new short[15];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                            indexes[3] = 0;                          indexes[4] = 2;                          indexes[5] = 3;                            indexes[6] = 0;                          indexes[7] = 3;                          indexes[8] = 4;                            indexes[9] = 0;                          indexes[10] = 4;                          indexes[11] = 5;                            indexes[12] = 0;                          indexes[13] = 5;                          indexes[14] = 6;                            break;                      case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarRL:                          indexes = new short[6];                          indexes[0] = 0;                          indexes[1] = 1;                          indexes[2] = 2;                          indexes[3] = 2;                          indexes[4] = 1;                          indexes[5] = 3;                          break;                        case CCProgressTimerType.kCCProgressTimerTypeHorizontalBarLR:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarBT:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                            break;                        case CCProgressTimerType.kCCProgressTimerTypeVerticalBarTB:                          indexes = new short[6];                          indexes[0] = 1;                          indexes[1] = 0;                          indexes[2] = 2;                          indexes[3] = 1;                          indexes[4] = 2;                          indexes[5] = 3;                          break;                  }
Missing Default,cocos2d,OGLES,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\platform\OGLES.cs,GetXNABlend,The following switch statement is missing a default case: switch (glBlend)              {                  case GL_ZERO:                      return Blend.Zero;                  case GL_ONE:                      return Blend.One;                  case GL_SRC_COLOR:                      return Blend.SourceColor;                  case GL_ONE_MINUS_SRC_COLOR:                      return Blend.InverseSourceColor;                  case GL_SRC_ALPHA:                      return Blend.SourceAlpha;                  case GL_ONE_MINUS_SRC_ALPHA:                      return Blend.InverseSourceAlpha;                  case GL_DST_ALPHA:                      return Blend.DestinationAlpha;                  case GL_ONE_MINUS_DST_ALPHA:                      return Blend.InverseDestinationAlpha;                    /* BlendingFactorSrc */                  /*      GL_ZERO */                  /*      GL_ONE */                  case GL_DST_COLOR:                      return Blend.DestinationColor;                  case GL_ONE_MINUS_DST_COLOR:                      return Blend.InverseDestinationColor;                  case GL_SRC_ALPHA_SATURATE:                      return Blend.SourceAlphaSaturation;              }
Missing Default,cocos2d,CCTexture2D,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\textures\CCTexture2D.cs,initWithData,The following switch statement is missing a default case: switch(pixelFormat) {                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_A8:                      format = SurfaceFormat.Alpha8;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_AI88:                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_Automatic:                      format = SurfaceFormat.Color;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_Default:                      format = SurfaceFormat.Color;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_I8:                      format = SurfaceFormat.Single;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_PVRTC2:                      format = SurfaceFormat.Vector2;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_PVRTC4:                      format = SurfaceFormat.Vector4;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_RGB565:                      format = SurfaceFormat.Bgr565;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_RGB5A1:                      format = SurfaceFormat.Bgra5551;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_RGB888:                      format = SurfaceFormat.Color;                      break;                  case CCTexture2DPixelFormat.kCCTexture2DPixelFormat_RGBA4444:                      format = SurfaceFormat.Bgra4444;                      break;              }
Missing Default,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,positionAt,The following switch statement is missing a default case: switch (m_uLayerOrientation)              {                  case CCTMXOrientatio.CCTMXOrientationOrtho:                      ret = positionForOrthoAt(pos);                      break;                  case CCTMXOrientatio.CCTMXOrientationIso:                      ret = positionForIsoAt(pos);                      break;                  case CCTMXOrientatio.CCTMXOrientationHex:                      ret = positionForHexAt(pos);                      break;              }
Missing Default,cocos2d,CCTMXLayer,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\tileMap_parallax_nodes\CCTMXLayer.cs,calculateLayerOffset,The following switch statement is missing a default case: switch (m_uLayerOrientation)              {                  case CCTMXOrientatio.CCTMXOrientationOrtho:                      ret = new CCPoint(pos.x * m_tMapTileSize.width' -pos.y * m_tMapTileSize.height);                      break;                  case CCTMXOrientatio.CCTMXOrientationHex:                      Debug.Assert(CCPoint.CCPointEqualToPoint(pos' new CCPoint(0' 0))' "offset for hexagonal map not implemented yet");                      break;                  case CCTMXOrientatio.CCTMXOrientationIso:                      ret = new CCPoint((m_tMapTileSize.width / 2) * (pos.x - pos.y)'                                     (m_tMapTileSize.height / 2) * (-pos.x - pos.y));                      break;              }
Missing Default,cocos2d,CCTouchDispatcher,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDispatcher.cs,touches,The following switch statement is missing a default case: switch (sHelper)                                  {                                      case CCTouchType.CCTOUCHMOVED:                                          pDelegate.ccTouchMoved(pTouch' pEvent);                                          break;                                      case CCTouchType.CCTOUCHENDED:                                          pDelegate.ccTouchEnded(pTouch' pEvent);                                          pHandler.ClaimedTouches.Remove(pTouch);                                          break;                                      case CCTouchType.CCTOUCHCANCELLED:                                          pDelegate.ccTouchCancelled(pTouch' pEvent);                                          pHandler.ClaimedTouches.Remove(pTouch);                                          break;                                  }
Missing Default,cocos2d,CCTouchDispatcher,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\touch_dispatcher\CCTouchDispatcher.cs,touches,The following switch statement is missing a default case: switch (sHelper)                      {                          case CCTouchType.CCTOUCHBEGAN:                              pDelegate.ccTouchesBegan(pMutableTouches' pEvent);                              break;                          case CCTouchType.CCTOUCHMOVED:                              pDelegate.ccTouchesMoved(pMutableTouches' pEvent);                              break;                          case CCTouchType.CCTOUCHENDED:                              pDelegate.ccTouchesEnded(pMutableTouches' pEvent);                              break;                          case CCTouchType.CCTOUCHCANCELLED:                              pDelegate.ccTouchesCancelled(pMutableTouches' pEvent);                              break;                      }
Missing Default,WP7Contrib.Communications.Compression,InflateBlocks,D:\research\architectureSmells\repos\cocos2d_cocos2d-x-for-xna\cocos2d-xna\support\Compression\InflateBlocks.cs,Process,The following switch statement is missing a default case: switch (SharedUtils.URShift(number2' 1))                          {                              case 0:                                  int number3 = SharedUtils.URShift(number1' 3);                                  int num6 = num2 - 3;                                  int bits1 = num6 & 7;                                  number1 = SharedUtils.URShift(number3' bits1);                                  num2 = num6 - bits1;                                  this.mode = 1;                                  break;                              case 1:                                  int[] bl1 = new int[1];                                  int[] bd1 = new int[1];                                  int[][] tl1 = new int[1][];                                  int[][] td1 = new int[1][];                                  InfTree.inflate_trees_fixed(bl1' bd1' tl1' td1' this._codec);                                  this.codes.Init(bl1[0]' bd1[0]' tl1[0]' 0' td1[0]' 0);                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 6;                                  break;                              case 2:                                  number1 = SharedUtils.URShift(number1' 3);                                  num2 -= 3;                                  this.mode = 3;                                  break;                              case 3:                                  goto label_9;                          }
