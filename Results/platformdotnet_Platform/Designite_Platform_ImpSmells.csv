Implementation smell,Namespace,Class,File,Method,Description
Long Method,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,The method has 110 lines of code.
Long Method,Platform.IO,ChunkingStream,C:\repos\platformdotnet_Platform\src\Platform\IO\ChunkingStream.cs,Read,The method has 108 lines of code.
Long Method,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The method has 268 lines of code.
Long Method,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,Consume,The method has 133 lines of code.
Complex Method,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,FindSequenceElementType,Cyclomatic complexity of the method is 10
Complex Method,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,Cyclomatic complexity of the method is 12
Complex Method,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,Cyclomatic complexity of the method is 8
Complex Method,Platform.IO,ChunkingStream,C:\repos\platformdotnet_Platform\src\Platform\IO\ChunkingStream.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,Cyclomatic complexity of the method is 14
Complex Method,Platform.IO,TextReaderUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\TextReaderUtils.cs,ReadLine,Cyclomatic complexity of the method is 9
Complex Method,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,WriteUnescapedHexString,Cyclomatic complexity of the method is 9
Complex Method,Platform.Validation,ValidatorOptions,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValidatorOptions.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,Cyclomatic complexity of the method is 18
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Compose,The method has 5 parameters. Parameters: e' d' c' b' a
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Compose,The method has 6 parameters. Parameters: f' e' d' c' b' a
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Compose,The method has 7 parameters. Parameters: g' f' e' d' c' b' a
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Compose,The method has 8 parameters. Parameters: h' g' f' e' d' c' b' a
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 5 parameters. Parameters: ff' a' b' c' d
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 5 parameters. Parameters: ff' a' b' c' d
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 6 parameters. Parameters: ff' a' b' c' d' e
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 5 parameters. Parameters: ff' a' b' c' d
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 6 parameters. Parameters: ff' a' b' c' d' e
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 7 parameters. Parameters: ff' a' b' c' d' e' f
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 5 parameters. Parameters: ff' a' b' c' d
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 6 parameters. Parameters: ff' a' b' c' d' e
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 7 parameters. Parameters: ff' a' b' c' d' e' f
Long Parameter List,Platform,FuncUtils,C:\repos\platformdotnet_Platform\src\Platform\FuncUtils.cs,Curry,The method has 8 parameters. Parameters: ff' a' b' c' d' e' f' g
Long Parameter List,Platform,MutableMeter,C:\repos\platformdotnet_Platform\src\Platform\MutableMeter.cs,MutableMeter,The method has 5 parameters. Parameters: owner' minimumValue' maximumValue' currentValue' units
Long Parameter List,Platform,StringUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUtils.cs,Replace,The method has 5 parameters. Parameters: s' regex' replacement' count' startIndex
Long Parameter List,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,The method has 5 parameters. Parameters: path' startIndex' count' seperatorChars' preserveEndingSeperator
Long Parameter List,Platform.IO,PartialStream,C:\repos\platformdotnet_Platform\src\Platform\IO\PartialStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Platform.IO,PartialStream,C:\repos\platformdotnet_Platform\src\Platform\IO\PartialStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Platform.IO,StreamCopier,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamCopier.cs,StreamCopier,The method has 5 parameters. Parameters: source' destination' autoCloseSource' autoCloseDestination' bufferSize
Long Parameter List,Platform.IO,StreamWrapper,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamWrapper.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Platform.IO,StreamWrapper,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamWrapper.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,Platform.Network.Time,ProgressMeter,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,ProgressMeter,The method has 5 parameters. Parameters: owner' minimumValue' maximumValue' currentValue' units
Long Parameter List,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase64CharArray,The method has 5 parameters. Parameters: input' offsetIn' length' outArray' offsetOut
Long Parameter List,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32CharArray,The method has 5 parameters. Parameters: input' offsetIn' length' outArray' offsetOut
Long Identifier,Platform,DateTimeFormats,C:\repos\platformdotnet_Platform\src\Platform\DateTimeFormats.cs,,The length of the parameter SortableUtcDateTimeFormatWithSecondsString is 42.
Long Identifier,Platform,DateTimeFormats,C:\repos\platformdotnet_Platform\src\Platform\DateTimeFormats.cs,,The length of the parameter SortableUtcDateTimeFormatWithFractionSecondsString is 50.
Long Identifier,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,WalkHierarchy,The length of the parameter convertGenericsToGenericTypeDefinition is 38.
Long Identifier,Platform.Validation,PropertyValidationContext,C:\repos\platformdotnet_Platform\src\Platform\Validation\PropertyValidationContext.cs,GetCurrentValueExpression,The length of the parameter propertyValidationContextExpression is 35.
Long Identifier,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the parameter propertyValidationContextLocal is 30.
Long Identifier,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,GetDelegateFromExpression,The length of the parameter propertyValidationContextExpression is 35.
Long Identifier,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,StringExpressionParser,The length of the parameter propertyValidationContextExpression is 35.
Long Identifier,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,Parse,The length of the parameter propertyValidationContextExpression is 35.
Long Identifier,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,,The length of the parameter propertyValidationContextExpression is 35.
Long Statement,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,GetMostDerivedField,The length of the statement  "				var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | (includeNonPublic ? (BindingFlags.NonPublic | BindingFlags.Public) : BindingFlags.Public); " is 154.
Long Statement,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,GetMostDerivedProperty,The length of the statement  "				var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | (includeNonPublic ? (BindingFlags.NonPublic | BindingFlags.Public) : BindingFlags.Public); " is 154.
Long Statement,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,GetMostDerivedMethod,The length of the statement  "				var flags = BindingFlags.DeclaredOnly | BindingFlags.Instance | (includeNonPublic ? (BindingFlags.NonPublic | BindingFlags.Public) : BindingFlags.Public); " is 154.
Long Statement,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,BuildQuery,The length of the statement  "			return BuildQuery(Pair<string' string>.FromNameValueCollection(nameValueCollection)' PredicateUtils<Pair<string' string>>.AlwaysTrue); " is 134.
Long Statement,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,ReadLineUnbuffered,The length of the statement  "			var charCount = Encoding.UTF8.GetChars(retval.Left' 0' lastByte == '\r' ? retval.Right - 1 : retval.Right' t_CharBuffer' 0); " is 124.
Long Statement,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The length of the statement  "				var x = this.transform.TransformBlock(this.writeBuffer' i * this.transform.InputBlockSize' this.transform.InputBlockSize'  this.writeBlockBuffer' 0); " is 149.
Long Statement,Platform.Linq,ExpressionVisitor,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionVisitor.cs,VisitBinary,The length of the statement  "					return Expression.MakeBinary(binaryExpression.NodeType' left' right' binaryExpression.IsLiftedToNull' binaryExpression.Method); " is 127.
Long Statement,Platform.Linq,ExpressionVisitor,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionVisitor.cs,VisitLambda,The length of the statement  "				if (expression.Body.Type.IsAssignableFrom(body.Type) && parameters.Select(c => c.Type).SequenceEqual(expression.Parameters.Select(c => c.Type))) " is 144.
Long Statement,Platform.Reflection,ConstructorInfoUtils,C:\repos\platformdotnet_Platform\src\Platform\Reflection\ConstructorInfoUtils.cs,GetConstructorOnTypeReplacingTypeGenericArgs,The length of the statement  "				.Select(c => new { constructor = c' currentTypes = TypeUtils.Substitute(c.GetParameters().Select(d => d.ParameterType)' realisedTypeFromGenericParam1)' newTypes = TypeUtils.Substitute(c.GetParameters().Select(d => d.ParameterType)' realisedTypeFromGenericParam2) }) " is 265.
Long Statement,Platform.Reflection,MethodInfoUtils,C:\repos\platformdotnet_Platform\src\Platform\Reflection\MethodInfoUtils.cs,GetMethodOnTypeReplacingTypeGenericArgs,The length of the statement  "				.Select(c => new { constructor = c' currentTypes = TypeUtils.Substitute(c.GetParameters().Select(d => d.ParameterType)' realisedTypeFromGenericParam1)' newTypes = TypeUtils.Substitute(c.GetParameters().Select(d => d.ParameterType)' realisedTypeFromGenericParam2) }) " is 265.
Long Statement,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,CalculateRoundTripDelay,The length of the statement  "			return (resultTime - resultPacket.OriginateTimeSpamp) - (resultPacket.ReceiveTimeSpamp - resultPacket.TransmitTimeSpamp); " is 121.
Long Statement,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,CalculateLocalClockOffset,The length of the statement  "			return TimeSpan.FromTicks(((resultPacket.ReceiveTimeSpamp - resultPacket.OriginateTimeSpamp) + (resultPacket.TransmitTimeSpamp - resultTime)).Ticks / 2); " is 153.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,CreateExceptionString,The length of the statement  "			return $@"The value's length must be between {this.MinimumLength} and {this.MaximumLength} (inclusive) but is {(value == null ? "null" : value.Length.ToString())}"; " is 164.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			var propertyValidationContext = Expression.Parameter(typeof(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>)' "propertyValidationContext"); " is 145.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				Expression.GreaterThanOrEqual(Expression.Property(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' "Length")' Expression.Constant(MinimumLength))' " is 205.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				Expression.LessThanOrEqual(Expression.Property(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' "Length")' Expression.Constant(MaximumLength))' " is 202.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				Expression.Equal(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' Expression.Constant(null))' " is 152.
Long Statement,Platform.Validation,SizeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\SizeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			return Expression.Lambda<Func<PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>' ValidationResult>>(body' propertyValidationContext); " is 137.
Long Statement,Platform.Validation,ValidationException,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValidationException.cs,CreateExceptionString,The length of the statement  "			return $"The property '{context.PropertyInfo.ReflectedType.Name}.{context.PropertyInfo.Name}' with the value '{(context.PropertyValue == null ? "null" : Convert.ToString(context.PropertyValue))}' failed {context.ValidationAttribute.Name} validation with result: {context.ValidationAttribute.CreateExceptionString(context)}"; " is 324.
Long Statement,Platform.Validation,ValidatorFactory,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValidatorFactory.cs,NewValidator,The length of the statement  "				var methodInfo = typeof(ValidatorFactory).GetMethods(BindingFlags.Public | BindingFlags.Instance).FirstOrDefault(c => c.GetGenericArguments().Length == 1).MakeGenericMethod(type); " is 179.
Long Statement,Platform.Validation,ValueExpressionConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueExpressionConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			var propertyValidationContext = Expression.Parameter(typeof(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>)' "propertyValidationContext"); " is 145.
Long Statement,Platform.Validation,ValueExpressionConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueExpressionConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			return Expression.Lambda<Func<PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>' ValidationResult>>(constraintExpression' propertyValidationContext); " is 153.
Long Statement,Platform.Validation,ValuePatternConstraint,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValuePatternConstraint.cs,GetValidateExpression,The length of the statement  "			return c => (this.AllowDefault && c.PropertyValue == null) ? ValidationResult.Success : (this.patternRegex.IsMatch(c.PropertyValue.ToString()) ? ValidationResult.Success : new ValidationResult(new ValidationException(c))); " is 222.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,CreateExceptionString,The length of the statement  "			return $@"Value must be between {this.MinimumValue ?? "MinValue"} and {this.MaximumValue ?? "MaxValue"} (inclusive) but is {context.PropertyValue}"; " is 148.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				var field = underlyingType.GetField("MaxValue"' System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); " is 127.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			var propertyValidationContext = Expression.Parameter(typeof(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>)' "propertyValidationContext"); " is 145.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				Expression.GreaterThanOrEqual(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' Expression.Constant(minimumValue' typeof(PROPERTY_TYPE)))' " is 196.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				Expression.LessThanOrEqual(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' Expression.Constant(maximumValue' typeof(PROPERTY_TYPE)))' " is 193.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				var nullCheck = Expression.Equal(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>.GetCurrentValueExpression(propertyValidationContext)' Expression.Constant(null)); " is 168.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "				body = Expression.Condition(nullCheck' Expression.Field(null' typeof(ValidationResult).GetField("Success"' BindingFlags.Static | BindingFlags.Public))' body); " is 158.
Long Statement,Platform.Validation,ValueRangeConstraintAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRangeConstraintAttribute.cs,GetValidateExpression,The length of the statement  "			return Expression.Lambda<Func<PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>' ValidationResult>>(body' propertyValidationContext); " is 137.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				return value => value.PropertyValue.Equals(defaultValue) ? new ValidationResult(new ValidationException(value)) : ValidationResult.Success; " is 139.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				return value => String.IsNullOrEmpty((string)(object)value.PropertyValue) ? new ValidationResult(new ValidationException(value)) : ValidationResult.Success; " is 156.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var parameter = Expression.Parameter(typeof(PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>)' "propertyValidationContext"); " is 129.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var nulltest = Expression.Equal(Expression.Property(parameter' "PropertyValue")' Expression.Constant(null' typeof(PROPERTY_TYPE))); " is 131.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var counttest = Expression.Equal(Expression.Property(Expression.Property(parameter' "PropertyValue")' "Count")' Expression.Constant(0)); " is 136.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var newValidationException = Expression.New(typeof(ValidationException).GetConstructor(new[] { typeof(IPropertyValidationContext) })' Expression.Convert(parameter' typeof(IPropertyValidationContext))); " is 201.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var iftrue = Expression.New(typeof(ValidationResult).GetConstructor(new[] { typeof(ValidationException) })' newValidationException); " is 132.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				var iffalse = Expression.Field(null' typeof(ValidationResult).GetField("Success"' System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public)); " is 162.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				return Expression.Lambda<Func<PropertyValidationContext<OBJECT_TYPE' PROPERTY_TYPE>' ValidationResult>>(body' parameter); " is 121.
Long Statement,Platform.Validation,ValueRequiredAttribute,C:\repos\platformdotnet_Platform\src\Platform\Validation\ValueRequiredAttribute.cs,GetValidateExpression,The length of the statement  "				return value => value.PropertyValue == null ? new ValidationResult(new ValidationException(value)) : ValidationResult.Success; " is 126.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "							methodCallExpression = Expression.Call(Expression.Constant(compiledLambda)' compiledLambda.GetType().GetMethod("Invoke")' propertyValidationContext); " is 149.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "							methodCallExpression = Expression.Call(Expression.Constant(attribute)' attribute.GetType().GetMethod("Validate").MakeGenericMethod(typeof(T)' propertyInfo.PropertyType)' propertyValidationContext); " is 197.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "						setDefaultsDynamicMethod = new DynamicMethod("SetDefaults"' typeof(ValidationResult)' new[] { typeof(ValidationResult)' typeof(T)' typeof(List<Delegate>)' typeof(List<PropertyInfo>)' typeof(List<DefaultValueAttribute>)' typeof(ValidationContext<T>) }); " is 252.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "							var constructor = typeof(PropertyValidationContext<'>).MakeGenericType(typeof(T)' propertyInfo.PropertyType).GetConstructor " is 123.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "							generator.Emit(OpCodes.Call' typeof(Convert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public' null' new[] { typeof(object)' typeof(Type) }' null)); " is 165.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "							generator.Emit(OpCodes.Call' typeof(Object).GetMethod("Equals"' BindingFlags.Static | BindingFlags.Public' null' new [] { typeof(Object)' typeof(Object) }' null)); " is 163.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "				var setDefaultsFunc = setDefaultsDynamicMethod.CreateDelegate(typeof(Func<''''''>).MakeGenericType(typeof(ValidationResult)' typeof(T)' typeof(List<Delegate>)' typeof(List<PropertyInfo>)' typeof(List<DefaultValueAttribute>)' typeof(ValidationContext<T>)' typeof(ValidationResult))); " is 282.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The length of the statement  "				body = Expression.Call(Expression.Constant(setDefaultsFunc)' setDefaultsFunc.GetType().GetMethod("Invoke")' body ?? Expression.Constant(ValidationResult.Success)' currentObject' Expression.Constant(delegates)' Expression.Constant(propertyInfos)' Expression.Constant(defaultAttributes)' validationContext); " is 305.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,GetDelegateFromExpression,The length of the statement  "			var lambdaExpression = Expression.Lambda(typeof(Func<'>).MakeGenericType(parameter.Type' body.Type)' body' parameter).Compile(); " is 128.
Long Statement,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,GetProperties,The length of the statement  "				foreach (var propertyInfo in parentType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)) " is 124.
Long Statement,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,ParseOperand,The length of the statement  "						return Expression.Property(Expression.Property(propertyValidationContextExpression' "ObjectValue")' propertyReferenceValue); " is 124.
Complex Conditional,Platform,EnvironmentUtils,C:\repos\platformdotnet_Platform\src\Platform\EnvironmentUtils.cs,SetSystemTime,The conditional expression  "Environment.OSVersion.Platform == PlatformID.Win32NT  				|| Environment.OSVersion.Platform == PlatformID.Win32S  				|| Environment.OSVersion.Platform == PlatformID.Win32Windows  				|| Environment.OSVersion.Platform == PlatformID.WinCE"  is complex.
Complex Conditional,Platform,TaskAsyncStateAndImplementationHelper,C:\repos\platformdotnet_Platform\src\Platform\AbstractTask.cs,RequestTaskState,The conditional expression  "(state == TaskState.Starting || state == TaskState.Running)                              && TaskState != TaskState.Starting && TaskState != TaskState.Running                              && TaskState != TaskState.Paused && TaskState != TaskState.Waiting"  is complex.
Complex Conditional,Platform,Int32Utils,C:\repos\platformdotnet_Platform\src\Platform\Int32Utils.cs,FromHex,The conditional expression  "(((digit < '0') || (digit > '9')) && ((digit < 'A') || (digit > 'F'))) && ((digit < 'a') || (digit > 'f'))"  is complex.
Complex Conditional,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The conditional expression  "((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))"  is complex.
Complex Conditional,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,IsStandardUrlUnEscapedChar,The conditional expression  "c == ' ' || c == '|' || c == '{' || c == '}' || c == '^'  				|| c == '<' || c == '>' || c == '"' || c == '\\' || c == '%'  				|| c == ';'"  is complex.
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMinimumValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetCurrentValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetCurrentValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMinimumValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMaximumValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMaximumValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMaximumValue".
Virtual Method Call from Constructor,Platform.IO,MeteringStream,C:\repos\platformdotnet_Platform\src\Platform\IO\MeteringStream.cs,MeteringStream,The constructor "MeteringStream" calls a virtual method "SetMaximumValue".
Virtual Method Call from Constructor,Platform.Network.Time,ProgressMeter,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,ProgressMeter,The constructor "ProgressMeter" calls a virtual method "SetOwner".
Virtual Method Call from Constructor,Platform.Utilities,InvocationQueue,C:\repos\platformdotnet_Platform\src\Platform\Utilities\InvocationQueue.cs,InvocationQueue,The constructor "InvocationQueue" calls a virtual method "SetTaskState".
Empty Catch Block,Platform,AbstractMeter,C:\repos\platformdotnet_Platform\src\Platform\AbstractMeter.cs,ToString,The method has an empty catch block.
Magic Number,Platform,ActionUtils,C:\repos\platformdotnet_Platform\src\Platform\ActionUtils.cs,ToRetryAction,The following statement contains a magic number: return delegate(T state)  			{  				startTime = DateTime.Now;    				while (true)  				{  					try  					{  						action(state);    						return;  					}  					catch (Exception e)  					{  						if (!retryOnException(e))  						{  							throw;  						}    						if (DateTime.Now - startTime > maximumTime)  						{  							throw;  						}  					}    					Thread.Sleep(pause ?? TimeSpan.FromSeconds(maximumTime.TotalSeconds / 10));					  				}  			};
Magic Number,Platform,ActionUtils,C:\repos\platformdotnet_Platform\src\Platform\ActionUtils.cs,ToRetryAction,The following statement contains a magic number: return delegate  			{  				startTime = DateTime.Now;    				while (true)  				{  					try  					{  						action();    						return;  					}  					catch (Exception e)  					{  						if (!retryOnException(e))  						{  							throw;  						}    						if (DateTime.Now - startTime > maximumTime)  						{  							throw;  						}  					}    					Thread.Sleep(pause ?? TimeSpan.FromSeconds(maximumTime.TotalSeconds / 10));  				}  			};
Magic Number,Platform,ActionUtils,C:\repos\platformdotnet_Platform\src\Platform\ActionUtils.cs,RetryAction,The following statement contains a magic number: while (true)  			{  				try  				{  					action();    					return;  				}  				catch (Exception e)  				{  					if (!retryOnException(e))  					{  						throw;  					}    					if (DateTime.Now - startTime > maximumTime)  					{  						throw;  					}  				}    				Thread.Sleep(pause ?? TimeSpan.FromSeconds(maximumTime.TotalSeconds / 10));  			}
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToInt32,The following statement contains a magic number: return (((((Byte1 << 8) + Byte2) << 8) + Byte3) << 8) + Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToInt32,The following statement contains a magic number: return (((((Byte1 << 8) + Byte2) << 8) + Byte3) << 8) + Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToInt32,The following statement contains a magic number: return (((((Byte1 << 8) + Byte2) << 8) + Byte3) << 8) + Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToUInt32,The following statement contains a magic number: return ((((((uint)Byte1 << 8) + (uint)Byte2) << 8) + (uint)Byte3) << 8) + (uint)Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToUInt32,The following statement contains a magic number: return ((((((uint)Byte1 << 8) + (uint)Byte2) << 8) + (uint)Byte3) << 8) + (uint)Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToUInt32,The following statement contains a magic number: return ((((((uint)Byte1 << 8) + (uint)Byte2) << 8) + (uint)Byte3) << 8) + (uint)Byte4;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToTimeSpan,The following statement contains a magic number: return TimeSpan.FromMilliseconds(1000 * (((double)ToInt32()) / 0x10000));
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,ToTimeSpanAsUInt,The following statement contains a magic number: return TimeSpan.FromMilliseconds(1000 * (((double)ToUInt32()) / 0x10000));
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromInt32,The following statement contains a magic number: retval.Byte1 = (byte)((value >> 24) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromInt32,The following statement contains a magic number: retval.Byte2 = (byte)((value >> 16) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromInt32,The following statement contains a magic number: retval.Byte3 = (byte)((value >> 8) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromUInt32,The following statement contains a magic number: retval.Byte1 = (byte)((value >> 24) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromUInt32,The following statement contains a magic number: retval.Byte2 = (byte)((value >> 16) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromUInt32,The following statement contains a magic number: retval.Byte3 = (byte)((value >> 8) & 0xff);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromTimeSpan,The following statement contains a magic number: milliseconds /= 1000;
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromTimeSpan,The following statement contains a magic number: retval.Byte3 = (byte)((x >> 8) & 0xf);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromTimeSpan,The following statement contains a magic number: retval.Byte2 = (byte)((x >> 16) & 0xf);
Magic Number,Platform,BigEndianByteQuad,C:\repos\platformdotnet_Platform\src\Platform\BigEndianByteQuad.cs,FromTimeSpan,The following statement contains a magic number: retval.Byte1 = (byte)((x >> 24) & 0xf);
Magic Number,Platform,HashValue,C:\repos\platformdotnet_Platform\src\Platform\HashValue.cs,GetHashCode,The following statement contains a magic number: for (var i = 0; i < Value.Length; i++)  			{  				hash ^= i >> (offset * 8);    				offset++;  				offset %= 4;  			}
Magic Number,Platform,HashValue,C:\repos\platformdotnet_Platform\src\Platform\HashValue.cs,GetHashCode,The following statement contains a magic number: for (var i = 0; i < Value.Length; i++)  			{  				hash ^= i >> (offset * 8);    				offset++;  				offset %= 4;  			}
Magic Number,Platform,Quad,C:\repos\platformdotnet_Platform\src\Platform\Quad.cs,GetAt,The following statement contains a magic number: switch (index)  			{  				case 0:  					return (T)(object)this.First;  				case 1:  					return (T)(object)this.Second;  				case 2:  					return (T)(object)this.Third;  				case 3:  					return (T)(object)this.Fourth;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,Platform,Quad,C:\repos\platformdotnet_Platform\src\Platform\Quad.cs,GetAt,The following statement contains a magic number: switch (index)  			{  				case 0:  					return (T)(object)this.First;  				case 1:  					return (T)(object)this.Second;  				case 2:  					return (T)(object)this.Third;  				case 3:  					return (T)(object)this.Fourth;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,Platform,Triple,C:\repos\platformdotnet_Platform\src\Platform\Triple.cs,GetAt,The following statement contains a magic number: switch (index)  			{  				case 0:  					return (T)(object)this.First;  				case 1:  					return (T)(object)this.Second;  				case 2:  					return (T)(object)this.Third;  				default:  					throw new IndexOutOfRangeException();  			}
Magic Number,Platform,ArrayUtils,C:\repos\platformdotnet_Platform\src\Platform\ArrayUtils.cs,Combine,The following statement contains a magic number: var list = new List<T>(Math.Max(16' array1.Length * 2));
Magic Number,Platform,ArrayUtils,C:\repos\platformdotnet_Platform\src\Platform\ArrayUtils.cs,Combine,The following statement contains a magic number: var list = new List<T>(Math.Max(16' array1.Length * 2));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,CharUtils,C:\repos\platformdotnet_Platform\src\Platform\CharUtils.cs,IsAsciiLetterOrDigit,The following statement contains a magic number: return (((c >= 48) && (c <= 57)) // 0-9  				|| ((c >= 65) && (c <= 90)) // A-Z  				|| ((c >= 97) && (c <= 122)));
Magic Number,Platform,MathUtils,C:\repos\platformdotnet_Platform\src\Platform\MathUtils.cs,MidPoint,The following statement contains a magic number: return low + ((high - low) / 2);
Magic Number,Platform,MathUtils,C:\repos\platformdotnet_Platform\src\Platform\MathUtils.cs,Min,The following statement contains a magic number: if (args.Length < 2)  			{  				throw new ArgumentException("Must provide at least two values");  			}
Magic Number,Platform,MathUtils,C:\repos\platformdotnet_Platform\src\Platform\MathUtils.cs,Max,The following statement contains a magic number: if (args.Length < 2)  			{  				throw new ArgumentException("Must provide at least two values");  			}
Magic Number,Platform,AbstractMeter,C:\repos\platformdotnet_Platform\src\Platform\AbstractMeter.cs,ToString,The following statement contains a magic number: try  			{  				arguments[3] = Percentage * 100;    				if (formatString.Length > 0)  				{  					formatString += " ";  				}    				formatString += "({3:0}%)";  			}  			catch (InvalidCastException)  			{				  			}
Magic Number,Platform,AbstractMeter,C:\repos\platformdotnet_Platform\src\Platform\AbstractMeter.cs,ToString,The following statement contains a magic number: try  			{  				arguments[3] = Percentage * 100;    				if (formatString.Length > 0)  				{  					formatString += " ";  				}    				formatString += "({3:0}%)";  			}  			catch (InvalidCastException)  			{				  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,GetPath,The following statement contains a magic number: if (x < 0)  			{  				return uri;  			}  			else  			{  				return uri.Substring(x + 3);  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,The following statement contains a magic number: if (StringUriUtils.backtrackStack == null)  			{  				lock (typeof(StringUriUtils))  				{  					if (StringUriUtils.backtrackStack == null)  					{  						StringUriUtils.backtrackStack = new int[100];  					}  				}  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,The following statement contains a magic number: while (x < (count + startIndex))  			{  				y = x;    				while (y < (count + startIndex))  				{  					if (CharArrayContains(seperatorChars' path[y]))  					{  						break;  					}  					  					y++;  				}    				z = y - x;    				if (z == 0)  				{  					// Ignore '//'.  				}  				else if (z == 1 && path[x] == '.')  				{  					// Ignore '/./'  				}  				else if (z == 2 && path[x] == '.' && path[x + 1] == '.')  				{  					if (x < 2)  					{  						throw new ArgumentException("Root (/) has no parent."' path);  					}    					if (builder.Length == 0)  					{  						throw new InvalidOperationException("Impossible attempt to go above path root (/).");  					}    					xi--;  					builder.Remove(StringUriUtils.backtrackStack[xi]' builder.Length - StringUriUtils.backtrackStack[xi]);  				}  				else  				{  					localBackTrackStack[xi++] = builder.Length;    					if (x == 0)  					{  						if (startsWithSeperator)  						{  							builder.Append('/');  						}  					}  					else  					{  						builder.Append('/');  					}    					builder.Append(path' x' z);  				}    				x = y + 1;  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,NormalizePath,The following statement contains a magic number: while (x < (count + startIndex))  			{  				y = x;    				while (y < (count + startIndex))  				{  					if (CharArrayContains(seperatorChars' path[y]))  					{  						break;  					}  					  					y++;  				}    				z = y - x;    				if (z == 0)  				{  					// Ignore '//'.  				}  				else if (z == 1 && path[x] == '.')  				{  					// Ignore '/./'  				}  				else if (z == 2 && path[x] == '.' && path[x + 1] == '.')  				{  					if (x < 2)  					{  						throw new ArgumentException("Root (/) has no parent."' path);  					}    					if (builder.Length == 0)  					{  						throw new InvalidOperationException("Impossible attempt to go above path root (/).");  					}    					xi--;  					builder.Remove(StringUriUtils.backtrackStack[xi]' builder.Length - StringUriUtils.backtrackStack[xi]);  				}  				else  				{  					localBackTrackStack[xi++] = builder.Length;    					if (x == 0)  					{  						if (startsWithSeperator)  						{  							builder.Append('/');  						}  					}  					else  					{  						builder.Append('/');  					}    					builder.Append(path' x' z);  				}    				x = y + 1;  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Unescape,The following statement contains a magic number: var builder = new StringBuilder(s.Length + 10);
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,StringUriUtils,C:\repos\platformdotnet_Platform\src\Platform\StringUriUtils.cs,Escape,The following statement contains a magic number: while (charValue != -1)  			{  				if (((charValue >= 48) && (charValue <= 57)) // 0-9  					|| ((charValue >= 65) && (charValue <= 90)) // A-Z  					|| ((charValue >= 97) && (charValue <= 122))) // a-z  				{  					writer.Write((char)charValue);  				}  				else  				{  					writer.Write("%{0:x2}"' charValue);  				}    				charValue = reader.Read();  			}
Magic Number,Platform,WeakEventHandlerProxy<E;D>,C:\repos\platformdotnet_Platform\src\Platform\WeakEventHandlerProxy.cs,CreateProxyMethod,The following statement contains a magic number: if (!c_DynamicMethodCache.TryGetValue(typeof(D)' out dynamicMethod))  			{  				var handlerDelegate = (Delegate)((object)this.realHandlerRef.Target);    				var parameters = handlerDelegate.Method.GetParameters();    				dynamicMethod = new DynamicMethod  				(  					"Proxy"'  					handlerDelegate.Method.ReturnType'  					new[] { this.GetType() }.Concat(parameters.Select(value => value.ParameterType)).ToArray()'  					this.GetType()  				);    				var generator = dynamicMethod.GetILGenerator();    				var elselabel = generator.DefineLabel();    				generator.DeclareLocal(typeof(D));    				generator.Emit(OpCodes.Ldarg_0);  				generator.Emit(OpCodes.Callvirt' this.GetType().GetProperty("RealHandler").GetGetMethod());  				generator.Emit(OpCodes.Castclass' typeof(D));  				generator.Emit(OpCodes.Stloc_0);    				// if (local == null)    				generator.Emit(OpCodes.Ldloc_0);  				generator.Emit(OpCodes.Ldnull);  				generator.Emit(OpCodes.Ceq);  				generator.Emit(OpCodes.Brfalse' elselabel);    				// Call "deregister"    				generator.Emit(OpCodes.Ldarg_0);  				generator.Emit(OpCodes.Callvirt'  				               this.GetType().GetMethod("Deregister"' BindingFlags.Instance | BindingFlags.NonPublic));    				generator.Emit(OpCodes.Ret);    				// else  				generator.MarkLabel(elselabel);    				// load real delegate (the delegate's "this" pointer)    				generator.Emit(OpCodes.Ldloc_0);    				// load arguments    				for (int i = 0; i < parameters.Length; i++)  				{  					if (i == 0)  					{  						generator.Emit(OpCodes.Ldarg_1);  					}  					else if (i == 1)  					{  						generator.Emit(OpCodes.Ldarg_2);  					}  					else if (i == 2)  					{  						generator.Emit(OpCodes.Ldarg_3);  					}  					else if (i < 255)  					{  						generator.Emit(OpCodes.Ldarg_S' (byte)i + 1);  					}  					else  					{  						generator.Emit(OpCodes.Ldarg_S' i + 1);  					}  				}    				// Call invoke  				generator.Emit(OpCodes.Callvirt'  				               handlerDelegate.GetType().GetMethod("Invoke"' BindingFlags.Instance | BindingFlags.Public));    				// Return the result of the invoke  				generator.Emit(OpCodes.Ret);    				c_DynamicMethodCache[typeof(D)] = dynamicMethod;  			}
Magic Number,Platform,WeakEventHandlerProxy<E;D>,C:\repos\platformdotnet_Platform\src\Platform\WeakEventHandlerProxy.cs,CreateProxyMethod,The following statement contains a magic number: if (!c_DynamicMethodCache.TryGetValue(typeof(D)' out dynamicMethod))  			{  				var handlerDelegate = (Delegate)((object)this.realHandlerRef.Target);    				var parameters = handlerDelegate.Method.GetParameters();    				dynamicMethod = new DynamicMethod  				(  					"Proxy"'  					handlerDelegate.Method.ReturnType'  					new[] { this.GetType() }.Concat(parameters.Select(value => value.ParameterType)).ToArray()'  					this.GetType()  				);    				var generator = dynamicMethod.GetILGenerator();    				var elselabel = generator.DefineLabel();    				generator.DeclareLocal(typeof(D));    				generator.Emit(OpCodes.Ldarg_0);  				generator.Emit(OpCodes.Callvirt' this.GetType().GetProperty("RealHandler").GetGetMethod());  				generator.Emit(OpCodes.Castclass' typeof(D));  				generator.Emit(OpCodes.Stloc_0);    				// if (local == null)    				generator.Emit(OpCodes.Ldloc_0);  				generator.Emit(OpCodes.Ldnull);  				generator.Emit(OpCodes.Ceq);  				generator.Emit(OpCodes.Brfalse' elselabel);    				// Call "deregister"    				generator.Emit(OpCodes.Ldarg_0);  				generator.Emit(OpCodes.Callvirt'  				               this.GetType().GetMethod("Deregister"' BindingFlags.Instance | BindingFlags.NonPublic));    				generator.Emit(OpCodes.Ret);    				// else  				generator.MarkLabel(elselabel);    				// load real delegate (the delegate's "this" pointer)    				generator.Emit(OpCodes.Ldloc_0);    				// load arguments    				for (int i = 0; i < parameters.Length; i++)  				{  					if (i == 0)  					{  						generator.Emit(OpCodes.Ldarg_1);  					}  					else if (i == 1)  					{  						generator.Emit(OpCodes.Ldarg_2);  					}  					else if (i == 2)  					{  						generator.Emit(OpCodes.Ldarg_3);  					}  					else if (i < 255)  					{  						generator.Emit(OpCodes.Ldarg_S' (byte)i + 1);  					}  					else  					{  						generator.Emit(OpCodes.Ldarg_S' i + 1);  					}  				}    				// Call invoke  				generator.Emit(OpCodes.Callvirt'  				               handlerDelegate.GetType().GetMethod("Invoke"' BindingFlags.Instance | BindingFlags.Public));    				// Return the result of the invoke  				generator.Emit(OpCodes.Ret);    				c_DynamicMethodCache[typeof(D)] = dynamicMethod;  			}
Magic Number,Platform.Collections,ListUtils,C:\repos\platformdotnet_Platform\src\Platform\Collections\ListUtils.cs,MergeSort,The following statement contains a magic number: var a1 = SubArray(list' 0' list.Count/ 2 - 1);
Magic Number,Platform.Collections,ListUtils,C:\repos\platformdotnet_Platform\src\Platform\Collections\ListUtils.cs,MergeSort,The following statement contains a magic number: var a2 = SubArray(list' list.Count / 2' list.Count - 1);
Magic Number,Platform.Collections,ArrayQueue<T>,C:\repos\platformdotnet_Platform\src\Platform\Collections\ArrayQueue.cs,Grow,The following statement contains a magic number: if (oldArray.Length >= Int32.MaxValue / 2)  			{  				newLength = Int32.MaxValue;  			}  			else  			{  				newLength = oldArray.Length << 1;  			}
Magic Number,Platform.Collections,TimedReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\TimedReferenceDictionary.cs,TimedReferenceDictionary,The following statement contains a magic number: if (maximumCount != -1)  			{  				this.maximumCount = Math.Max(maximumCount' 16);  			}  			else  			{  				this.maximumCount = -1;  			}
Magic Number,Platform.Collections,TimedReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\TimedReferenceDictionary.cs,TimedReferenceDictionary,The following statement contains a magic number: timer = new System.Threading.Timer(OnTimer' null' (int)Math.Round(timeout.TotalMilliseconds / 2)' (int)Math.Round(timeout.TotalMilliseconds/ 2));
Magic Number,Platform.Collections,TimedReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\TimedReferenceDictionary.cs,TimedReferenceDictionary,The following statement contains a magic number: timer = new System.Threading.Timer(OnTimer' null' (int)Math.Round(timeout.TotalMilliseconds / 2)' (int)Math.Round(timeout.TotalMilliseconds/ 2));
Magic Number,Platform.Collections,TimedReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\TimedReferenceDictionary.cs,CheckMaximumCount,The following statement contains a magic number: lock (this)  			{  				if (maximumCount != -1 && dictionary.Count >= maximumCount + lastMaximumFlushCount)  				{  					var target = (int)Math.Round(Math.Min(this.Count' maximumCount) / 2.0);    					var removeCount = this.Count - target;    					if (removeCount > 0)  					{  						int originalCount = this.Count;  						int smallestIndex = -1;  						DateTime smallestTime = DateTime.MaxValue;  						IList<KeyedTimedReference> removeList;    						Action routine = delegate  						{  							removeList = new List<KeyedTimedReference>(removeCount);    							foreach (var reference in dictionary.Values)  							{  								if (removeList.Count < removeCount  									|| (removeList.Count >= removeCount && reference.LastAccess < smallestTime))  								{  									if (removeList.Count < removeCount)  									{  										removeList.Add(reference);    										if (reference.LastAccess < smallestTime)  										{  											smallestIndex = removeList.Count - 1;  											smallestTime = reference.LastAccess;  										}    										continue;  									}    									removeList[smallestIndex] = reference;    									if (reference.LastAccess < smallestTime)  									{  										smallestTime = reference.LastAccess;  									}  								}  							}    							foreach (var item in removeList)  							{  								item.HardReference = null;  							}    							removeList.Clear();  						};    						routine();    						base.CleanDeadReferences();    						lastMaximumFlushCount = Math.Max(this.Count - target' 0) * 2;  					}  				}  			}
Magic Number,Platform.Collections,TimedReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\TimedReferenceDictionary.cs,CheckMaximumCount,The following statement contains a magic number: lock (this)  			{  				if (maximumCount != -1 && dictionary.Count >= maximumCount + lastMaximumFlushCount)  				{  					var target = (int)Math.Round(Math.Min(this.Count' maximumCount) / 2.0);    					var removeCount = this.Count - target;    					if (removeCount > 0)  					{  						int originalCount = this.Count;  						int smallestIndex = -1;  						DateTime smallestTime = DateTime.MaxValue;  						IList<KeyedTimedReference> removeList;    						Action routine = delegate  						{  							removeList = new List<KeyedTimedReference>(removeCount);    							foreach (var reference in dictionary.Values)  							{  								if (removeList.Count < removeCount  									|| (removeList.Count >= removeCount && reference.LastAccess < smallestTime))  								{  									if (removeList.Count < removeCount)  									{  										removeList.Add(reference);    										if (reference.LastAccess < smallestTime)  										{  											smallestIndex = removeList.Count - 1;  											smallestTime = reference.LastAccess;  										}    										continue;  									}    									removeList[smallestIndex] = reference;    									if (reference.LastAccess < smallestTime)  									{  										smallestTime = reference.LastAccess;  									}  								}  							}    							foreach (var item in removeList)  							{  								item.HardReference = null;  							}    							removeList.Clear();  						};    						routine();    						base.CleanDeadReferences();    						lastMaximumFlushCount = Math.Max(this.Count - target' 0) * 2;  					}  				}  			}
Magic Number,Platform.Collections,WeakReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\WeakReferenceDictionary.cs,WeakReferenceDictionary,The following statement contains a magic number: if ((int)periodicCleanTimeout.TotalMilliseconds != -1)  			{  				cleanerTimer = new Timer(OnTimer' null' (int)Math.Round(periodicCleanTimeout.TotalMilliseconds / 2)' (int)Math.Round(periodicCleanTimeout.TotalMilliseconds / 2));  			}
Magic Number,Platform.Collections,WeakReferenceDictionary<K;V>,C:\repos\platformdotnet_Platform\src\Platform\Collections\WeakReferenceDictionary.cs,WeakReferenceDictionary,The following statement contains a magic number: if ((int)periodicCleanTimeout.TotalMilliseconds != -1)  			{  				cleanerTimer = new Timer(OnTimer' null' (int)Math.Round(periodicCleanTimeout.TotalMilliseconds / 2)' (int)Math.Round(periodicCleanTimeout.TotalMilliseconds / 2));  			}
Magic Number,Platform.IO,FifoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\FifoStream.cs,Rebuild,The following statement contains a magic number: var newCapacity = this.buffer.Length * 2;
Magic Number,Platform.IO,FifoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\FifoStream.cs,Rebuild,The following statement contains a magic number: while (newCapacity < minimumSize)  			{  				newCapacity *= 2;  			}
Magic Number,Platform.IO,PartialStream,C:\repos\platformdotnet_Platform\src\Platform\IO\PartialStream.cs,PartialStream,The following statement contains a magic number: if (stream.CanSeek)  			{  				stream.Position = offset;  			}  			else  			{  				if (stream.CanRead)  				{  				    var buffer = new byte[255];    					var bytesLeft = (int)offset;    					while (bytesLeft > 0)  					{  						int read = stream.Read(buffer' 0' bytesLeft);    						if (read == 0)  						{  							break;  						}    						bytesLeft -= read;  					}  				}  				else  				{  					throw new NotSupportedException();  				}  			}
Magic Number,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,ReadDynamicBlock,The following statement contains a magic number: if (dynamicBlockBuffer == null)  			{  				dynamicBlockBuffer = new byte[256];  			}
Magic Number,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,ReadDynamicBlock,The following statement contains a magic number: for (;;)  			{  				x = stream.ReadByte();    				if (x == -1 || !keepGoing((byte)x))  				{  					break;  				}    				if (length == buffer.Length)  				{  					byte[] newBuffer;    					newBuffer = new byte[buffer.Length * 2];    					Array.Copy(buffer' newBuffer' buffer.Length);    					buffer = newBuffer;  				}    				buffer[length++] = (byte)x;  			}
Magic Number,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,ReadLineUnbuffered,The following statement contains a magic number: if (t_CharBuffer == null  				|| (t_CharBuffer != null && maxCharCount > t_CharBuffer.Length))  			{  				int newLength = t_CharBuffer == null ? 64 : t_CharBuffer.Length;    				while (newLength < maxCharCount)  				{  					newLength *= 2;  				}    				Array.Resize(ref t_CharBuffer' newLength);  			}
Magic Number,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,ReadLineUnbuffered,The following statement contains a magic number: if (t_CharBuffer == null  				|| (t_CharBuffer != null && maxCharCount > t_CharBuffer.Length))  			{  				int newLength = t_CharBuffer == null ? 64 : t_CharBuffer.Length;    				while (newLength < maxCharCount)  				{  					newLength *= 2;  				}    				Array.Resize(ref t_CharBuffer' newLength);  			}
Magic Number,Platform.IO,StreamUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\StreamUtils.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: if (bufferSizeInBlocks > 255)  			{  				bufferSizeInBlocks = 255;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: if (bufferSizeInBlocks > 255)  			{  				bufferSizeInBlocks = 255;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: this.writeBuffer = new byte[2 + transform.InputBlockSize * bufferSizeInBlocks];
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: this.readPreBuffer = new byte[transform.OutputBlockSize * 5];
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: this.readBuffer = new byte[transform.InputBlockSize * 5];
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,InteractiveCryptoStream,The following statement contains a magic number: this.writeBufferCount = 2;
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Read,The following statement contains a magic number: while (true)  			{  				if (this.readBufferCount == 0)  				{  					while (true)  					{  						var x = this.ReadAndConvertBlocks();    						if (x == 0)  						{  							continue;  						}  						else if (x == -1)  						{  							this.readBufferIndex = 0;  							this.readBufferCount = 0;    							return 0;  						}    						this.readBufferIndex = 0;  						this.readBufferCount = x;    						break;  					}  				}    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.bytesLeftInSuperBlock = this.readBuffer[this.readBufferIndex];  					this.bytesLeftInSuperBlock |= this.readBuffer[this.readBufferIndex + 1] << 8;    					this.bytesLeftInSuperBlock += 2;  					  					if (this.bytesLeftInSuperBlock == 2)  					{  						this.bytesLeftInSuperBlock = 0;  						this.readBufferIndex += this.transform.InputBlockSize;  						this.readBufferCount -= this.transform.InputBlockSize;    						continue;  					}    					this.readBufferCount -= 2;  					this.readBufferIndex += 2;  					  					this.bytesPaddingSuperBlock = (((this.bytesLeftInSuperBlock + 15) / 16) * 16) - this.bytesLeftInSuperBlock;    					this.bytesLeftInSuperBlock -= 2;  				}    				var length = MathUtils.Min(this.bytesLeftInSuperBlock' this.readBufferCount' count);    				Array.Copy(this.readBuffer' this.readBufferIndex' buffer' offset' length);    				this.bytesLeftInSuperBlock -= length;  				this.readBufferCount -= length;  				this.readBufferIndex += length;    				if (this.bytesLeftInSuperBlock == 0)  				{  					this.readBufferIndex += this.bytesPaddingSuperBlock;  					this.readBufferCount -= this.bytesPaddingSuperBlock;  				}    				return length;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Flush,The following statement contains a magic number: for (int i = 2; i < this.transform.InputBlockSize; i++)  			{  				this.writeBuffer[i] = (byte)this.random.Next(0' 255);  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,Flush,The following statement contains a magic number: for (int i = 2; i < this.transform.InputBlockSize; i++)  			{  				this.writeBuffer[i] = (byte)this.random.Next(0' 255);  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The following statement contains a magic number: if (this.writeBufferCount == 2)  			{  				return;  			}
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The following statement contains a magic number: this.writeBuffer[0] = ((byte)((this.writeBufferCount - 2) & 0xff));
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The following statement contains a magic number: this.writeBuffer[1] = ((byte)(((this.writeBufferCount - 2) & 0xff00) >> 8));
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The following statement contains a magic number: this.writeBuffer[1] = ((byte)(((this.writeBufferCount - 2) & 0xff00) >> 8));
Magic Number,Platform.IO,InteractiveCryptoStream,C:\repos\platformdotnet_Platform\src\Platform\IO\InteractiveCryptoStream.cs,PrivateFlush,The following statement contains a magic number: this.writeBufferCount = 2;
Magic Number,Platform.IO,TextReaderUtils,C:\repos\platformdotnet_Platform\src\Platform\IO\TextReaderUtils.cs,ReadLine,The following statement contains a magic number: buffer = new StringBuilder(Math.Min(64' maximumLength));
Magic Number,Platform.IO,MergedLineReader,C:\repos\platformdotnet_Platform\src\Platform\IO\TextReaderUtils.cs,MergedLineReader,The following statement contains a magic number: Action<TextReader> routine = delegate(TextReader reader)  				                  {  				                      try  				                      {  				                          while (true)  				                          {  				                              bool exit = false;  				                              string line;    				                              lock (lockobject)  				                              {  				                                  while (newLine != null)  				                                  {  				                                      Monitor.Wait(lockobject' 500);    				                                      if (disposed)  				                                      {  				                                          exit = true;    				                                          break;  				                                      }  				                                  }  				                              }    				                              if (exit)  				                              {  				                                  break;  				                              }    				                              line = reader.ReadLine();    				                              lock (lockobject)  				                              {  				                                  while (newLine != null)  				                                  {  				                                      Monitor.Wait(lockobject' 500);    				                                      if (disposed)  				                                      {  				                                          exit = true;    				                                          break;  				                                      }  				                                  }    				                                  if (exit)  				                                  {  				                                      break;  				                                  }    				                                  newLine = line;    				                                  Monitor.PulseAll(lockobject);    				                                  if (newLine == null)  				                                  {  				                                      break;  				                                  }  				                              }  				                          }  				                      }  				                      catch (Exception e)  				                      {  				                          errorException = e;  				                      }  				                      finally  				                      {  				                          lock (lockobject)  				                          {  				                              newLine = null;    				                              Interlocked.Decrement(ref endOfInput);    				                              Monitor.PulseAll(lockobject);  				                          }  				                      }  				                  };
Magic Number,Platform.IO,MergedLineReader,C:\repos\platformdotnet_Platform\src\Platform\IO\TextReaderUtils.cs,MergedLineReader,The following statement contains a magic number: Action<TextReader> routine = delegate(TextReader reader)  				                  {  				                      try  				                      {  				                          while (true)  				                          {  				                              bool exit = false;  				                              string line;    				                              lock (lockobject)  				                              {  				                                  while (newLine != null)  				                                  {  				                                      Monitor.Wait(lockobject' 500);    				                                      if (disposed)  				                                      {  				                                          exit = true;    				                                          break;  				                                      }  				                                  }  				                              }    				                              if (exit)  				                              {  				                                  break;  				                              }    				                              line = reader.ReadLine();    				                              lock (lockobject)  				                              {  				                                  while (newLine != null)  				                                  {  				                                      Monitor.Wait(lockobject' 500);    				                                      if (disposed)  				                                      {  				                                          exit = true;    				                                          break;  				                                      }  				                                  }    				                                  if (exit)  				                                  {  				                                      break;  				                                  }    				                                  newLine = line;    				                                  Monitor.PulseAll(lockobject);    				                                  if (newLine == null)  				                                  {  				                                      break;  				                                  }  				                              }  				                          }  				                      }  				                      catch (Exception e)  				                      {  				                          errorException = e;  				                      }  				                      finally  				                      {  				                          lock (lockobject)  				                          {  				                              newLine = null;    				                              Interlocked.Decrement(ref endOfInput);    				                              Monitor.PulseAll(lockobject);  				                          }  				                      }  				                  };
Magic Number,Platform.Linq,ExpressionHasher,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionHasher.cs,Visit,The following statement contains a magic number: if (expression != null)  			{  				this.hashCode ^= this.prefilter?.Invoke(expression) ?? 0;  				this.hashCode ^= (int)expression.NodeType << 24;  			}
Magic Number,Platform.Linq,ExpressionHasher,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionHasher.cs,VisitElementInitializer,The following statement contains a magic number: this.hashCode ^= (int)initializer.Arguments.Count << 16;
Magic Number,Platform.Linq,ExpressionHasher,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionHasher.cs,VisitMemberInit,The following statement contains a magic number: this.hashCode ^= expression.Bindings.Count << 8;
Magic Number,Platform.Linq,ExpressionHasher,C:\repos\platformdotnet_Platform\src\Platform\Linq\ExpressionHasher.cs,VisitInvocation,The following statement contains a magic number: this.hashCode ^= expression.Arguments.Count << 8;
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,NtpNetworkTimeClient,The following statement contains a magic number: progress = new ProgressMeter(this' 0' 4' 0' "");
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,CreateUdpClient,The following statement contains a magic number: udpClient.Client.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 5000);
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,DoRun,The following statement contains a magic number: try  			{  				progress.SetState(1' "Connecting");    				System.Threading.Thread.Sleep(1000);    				var udpClient = this.CreateUdpClient();    				progress.SetState(2' "Connected");    				var packet = new NtpPacket();    				packet.VersionNumber = 4;  				packet.Mode = NtpMode.Client;  				packet.TransmitTimeSpamp = DateTime.Now;    				var remoteEndPoint = new IPEndPoint(IPAddress.Any' 0);    				var outdata = packet.ToRawByteArray();    				byte[] data = null;    				for (int i = 0; i < 5; i++)  				{  					data = null;    					progress.SetState(3' $"Requesting Time (Attempt {i + 1})");    					udpClient.Send(outdata' outdata.Length);    					try  					{  						data = udpClient.Receive(ref remoteEndPoint);    						break;  					}  					catch (SocketException)  					{  						continue;  					}  				}    				var now = DateTime.Now;    				if (data == null)  				{  					throw new TimeoutException();  				}    				var resultPacket = NtpPacket.ParseRawByteArray(data);  								  				var localOffset = NtpPacket.CalculateLocalClockOffset(resultPacket' now);    				value = localOffset;    				SetTaskState(TaskState.Finished);  				  				progress.SetState(4' "Finished");  			}  			finally  			{  				if (this.TaskState != TaskState.Finished)  				{  					SetTaskState(TaskState.Stopped);    					progress.SetState(4' "Stopped (Error)");  				}  			}
Magic Number,Platform.Network.Time,NtpNetworkTimeClient,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,OnTaskException,The following statement contains a magic number: progress.SetState(4' $"Stopped (Error {eventArgs.Exception.ToString()})");
Magic Number,Platform.Network.Time,ProgressMeter,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpNetworkTimeClient.cs,ToString,The following statement contains a magic number: return $"{this.state} ({this.Percentage * 100:0}%)";
Magic Number,Platform.Network.Time,NtpByteOctuple,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,FromDateTime,The following statement contains a magic number: var referenceTime = new DateTime(1900' 1' 1' 0' 0' 0);
Magic Number,Platform.Network.Time,NtpByteOctuple,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ToTimeSpan,The following statement contains a magic number: var milliseconds = intpart * 1000 + (fractpart * 1000) / 0x100000000UL;
Magic Number,Platform.Network.Time,NtpByteOctuple,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ToTimeSpan,The following statement contains a magic number: var milliseconds = intpart * 1000 + (fractpart * 1000) / 0x100000000UL;
Magic Number,Platform.Network.Time,NtpByteOctuple,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ToDateTime,The following statement contains a magic number: var time = new DateTime(1900' 1' 1' 0' 0' 0);
Magic Number,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,CalculateLocalClockOffset,The following statement contains a magic number: return TimeSpan.FromTicks(((resultPacket.ReceiveTimeSpamp - resultPacket.OriginateTimeSpamp) + (resultPacket.TransmitTimeSpamp - resultTime)).Ticks / 2);
Magic Number,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ReadPacket,The following statement contains a magic number: udpClient.Client.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.ReceiveTimeout' 5000);
Magic Number,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ReadPacket,The following statement contains a magic number: packet.VersionNumber = 4;
Magic Number,Platform.Network.Time,NtpPacket,C:\repos\platformdotnet_Platform\src\Platform\Network\Time\NtpPacket.cs,ReadPacket,The following statement contains a magic number: for (int i = 0; i < 5; i++)  			{  				data = packet.ToRawByteArray();  				udpClient.Send(data' data.Length);    				try  				{  					data = udpClient.Receive(ref remoteEndPoint);    					break;  				}  				catch (SocketException)  				{  					continue;  				}  			}
Magic Number,Platform.References,TimedReference<T>,C:\repos\platformdotnet_Platform\src\Platform\References\TimedReference.cs,CreateTimer,The following statement contains a magic number: lock (this)  			{  				timer = new Timer  				(  					delegate { Timedout(); }'  					null'  					TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)'  					TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)  				);  			}
Magic Number,Platform.References,TimedReference<T>,C:\repos\platformdotnet_Platform\src\Platform\References\TimedReference.cs,CreateTimer,The following statement contains a magic number: lock (this)  			{  				timer = new Timer  				(  					delegate { Timedout(); }'  					null'  					TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)'  					TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)  				);  			}
Magic Number,Platform.References,TimedReference<T>,C:\repos\platformdotnet_Platform\src\Platform\References\TimedReference.cs,ResetTimer,The following statement contains a magic number: lock (this)  			{  				if (timer == null)  				{  					CreateTimer();  				}  				else  				{  					timer.Change(TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)'  						TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2));  				}  			}
Magic Number,Platform.References,TimedReference<T>,C:\repos\platformdotnet_Platform\src\Platform\References\TimedReference.cs,ResetTimer,The following statement contains a magic number: lock (this)  			{  				if (timer == null)  				{  					CreateTimer();  				}  				else  				{  					timer.Change(TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2)'  						TimeSpan.FromMilliseconds(timeOut.TotalMilliseconds / 2));  				}  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,WriteSoundex,The following statement contains a magic number: if (value.Length > 0)  			{  				writer.Write(value[0]);    				for (var i = 1; i < value.Length && length < 4; i++)  				{  					var currentChar = Char.ToUpper(value[i]);    					if (currentChar >= 'A' && currentChar <= 'Z' && currentChar != previousChar)  					{  						var soundexChar = SoundexValues[currentChar - 'A'];    						if (soundexChar != '0')  						{  							length++;  							writer.Write(soundexChar);  						}    						previousChar = currentChar;  					}  				}  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,WriteSoundex,The following statement contains a magic number: while (length < 4)  			{  				length++;  				writer.Write('0');  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToSoundex,The following statement contains a magic number: var retval = new StringBuilder(4);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToSoundex,The following statement contains a magic number: if (value.Length > 0)  			{  				retval.Append(value[0]);    				for (var i = 1; i < value.Length && retval.Length < 4; i++)  				{  					var currentChar = Char.ToUpper(value[i]);    					if (currentChar >= 'A' && currentChar <= 'Z' && currentChar != previousChar)  					{  						var soundexChar = SoundexValues[currentChar - 'A'];    						if (soundexChar != '0')  						{  							retval.Append(soundexChar);  						}    						previousChar = currentChar;  					}  				}  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToSoundex,The following statement contains a magic number: while (retval.Length < 4)  			{  				retval.Append('0');  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToEscapedHexString,The following statement contains a magic number: var builder = new StringBuilder((int)(s.Length * 1.5));
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToEscapedHexString,The following statement contains a magic number: foreach (char c in s)  			{  				if (c == '%' || charsToEscape.IndexOf(c) >= 0)  				{  					builder.Append('%');  					builder.Append(HexValues[(c & '\x00f0') >> 4]);  					builder.Append(HexValues[c & '\x000f']);  				}  				else  				{  					builder.Append(c);  				}  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,IsStandardUrlUnEscapedChar,The following statement contains a magic number: return ((int)c) >= 21 && ((int)c) <= 126;
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,IsStandardUrlUnEscapedChar,The following statement contains a magic number: return ((int)c) >= 21 && ((int)c) <= 126;
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToReEscapedHexString,The following statement contains a magic number: return ToEscapedHexString  			(  				s'  				context =>  				{  					if (skip > 0)  					{  						skip--;    						return false;  					}    					var c = context.Left[context.Right];    					if (Uri.IsHexEncoding(context.Left' context.Right))  					{  						skip = 2;    						return false;  					}    					if (c == '%' || shouldEscape(c))  					{  						return true;  					}  					else  					{  						return false;  					}  				}  			);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToEscapedHexString,The following statement contains a magic number: var builder = new StringBuilder((int)(s.Length * 1.5));
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToEscapedHexString,The following statement contains a magic number: for (var i = 0; i < s.Length; i++)  			{			  				if (shouldEscapeChar(new Pair<string' int>(s' i)))  				{  					chars[0] = s[i];    					var bytecount = encoding.GetBytes(chars' 0' 1' buffer' 0);    					for (int j = 0; j < bytecount; j++)  					{  						builder.Append('%');  						builder.Append(HexValues[(buffer[j] & '\x00f0') >> 4]);  						builder.Append(HexValues[buffer[j] & '\x000f']);  					}  				}  				else  				{					  					builder.Append(s[i]);  				}  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,WriteEscapedHexString,The following statement contains a magic number: return reader.ConvertAndDump(writer' (c' w) =>  			{  				if (c == '%' || shouldEscapeChar(c))  				{  					chars[0] = c;    					var bytecount = encoding.GetBytes(chars' 0' 1' buffer' 0);    					for (int j = 0; j < bytecount; j++)  					{  						w.Write('%');  						w.Write(HexValues[(buffer[j] & '\x00f0') >> 4]);  						w.Write(HexValues[(buffer[j] & '\x00f0') >> 4]);  					}  				}  				else  				{  					w.Write(c);  				}  			});
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,WriteEscapedHexString,The following statement contains a magic number: return reader.ConvertAndDump(writer' (c' w) =>  			{  				if (c == '%' || shouldEscapeChar(c))  				{  					chars[0] = c;    					var bytecount = encoding.GetBytes(chars' 0' 1' buffer' 0);    					for (int j = 0; j < bytecount; j++)  					{  						w.Write('%');  						w.Write(HexValues[(buffer[j] & '\x00f0') >> 4]);  						w.Write(HexValues[(buffer[j] & '\x00f0') >> 4]);  					}  				}  				else  				{  					w.Write(c);  				}  			});
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  			{  				return c - '0';  			}  			else if (c >= 'A' && c <= 'Z')  			{  				return c - 'A' + 10;  			}  			else if (c >= 'a' && c <= 'z')  			{  				return c - 'a' + 10;  			}  			else  			{  				throw new ArgumentException("Not a hex char"' "c");  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  			{  				return c - '0';  			}  			else if (c >= 'A' && c <= 'Z')  			{  				return c - 'A' + 10;  			}  			else if (c >= 'a' && c <= 'z')  			{  				return c - 'a' + 10;  			}  			else  			{  				throw new ArgumentException("Not a hex char"' "c");  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexChar,The following statement contains a magic number: if (x < 0 || x > 16)  			{  				throw new ArgumentException("Not a hex char"' "c");  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHexString,The following statement contains a magic number: var bytes = new byte[s.Length / 2];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHexString,The following statement contains a magic number: for (int i = 0; i < s.Length; i += 2)  			{  				int x' y;  		  				if (!IsHexChar(s[i]) || !IsHexChar(s[i + 1]))  				{  					throw new ArgumentException("Contains invlaid hexadecimal values"' "s");  				}    				try  				{  					x = FromHex(s[i]);  					y = FromHex(s[i + 1]);  				}  				catch (Exception e)  				{  					Console.WriteLine(e);    					throw;  				}    				bytes[i / 2] = (byte)((x << 4) | y);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHexString,The following statement contains a magic number: for (int i = 0; i < s.Length; i += 2)  			{  				int x' y;  		  				if (!IsHexChar(s[i]) || !IsHexChar(s[i + 1]))  				{  					throw new ArgumentException("Contains invlaid hexadecimal values"' "s");  				}    				try  				{  					x = FromHex(s[i]);  					y = FromHex(s[i + 1]);  				}  				catch (Exception e)  				{  					Console.WriteLine(e);    					throw;  				}    				bytes[i / 2] = (byte)((x << 4) | y);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,FromHexString,The following statement contains a magic number: for (int i = 0; i < s.Length; i += 2)  			{  				int x' y;  		  				if (!IsHexChar(s[i]) || !IsHexChar(s[i + 1]))  				{  					throw new ArgumentException("Contains invlaid hexadecimal values"' "s");  				}    				try  				{  					x = FromHex(s[i]);  					y = FromHex(s[i + 1]);  				}  				catch (Exception e)  				{  					Console.WriteLine(e);    					throw;  				}    				bytes[i / 2] = (byte)((x << 4) | y);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: var bytes = new byte[8];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[7] = (byte)((value) >> 0 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[6] = (byte)((value) >> 8 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[6] = (byte)((value) >> 8 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[5] = (byte)((value) >> 16 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[5] = (byte)((value) >> 16 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[4] = (byte)((value) >> 24 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[4] = (byte)((value) >> 24 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[3] = (byte)((value) >> 32 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[3] = (byte)((value) >> 32 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[2] = (byte)((value) >> 40 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[2] = (byte)((value) >> 40 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[1] = (byte)((value) >> 48 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[0] = (byte)((value) >> 56 & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: var bytes = new byte[4];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[2] = (byte)((value >> 0) & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[3] = (byte)((value >> 8) & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[3] = (byte)((value >> 8) & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[1] = (byte)((value >> 16) & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: bytes[0] = (byte)((value >> 24) & 0xf);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: var builder = new StringBuilder(bytes.Length * 2);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: foreach (byte b in bytes)  			{  				builder.Append(hexValues[((int)b >> 4)]);  				builder.Append(hexValues[((int)b & 15)]);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToHexString,The following statement contains a magic number: foreach (byte b in bytes)  			{  				builder.Append(hexValues[((int)b >> 4)]);  				builder.Append(hexValues[((int)b & 15)]);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var data = new byte[8];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[1] = (byte)((x >> 8) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[2] = (byte)((x >> 16) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[2] = (byte)((x >> 16) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[3] = (byte)((x >> 24) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[3] = (byte)((x >> 24) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[4] = (byte)((x >> 32) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[4] = (byte)((x >> 32) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[5] = (byte)((x >> 40) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[5] = (byte)((x >> 40) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[6] = (byte)((x >> 48) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[6] = (byte)((x >> 48) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[7] = (byte)((x >> 56) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: data[7] = (byte)((x >> 56) & 0xff);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var out_block = new char[8];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var b1 = (byte)((x & 0xff00) >> 8);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var b2 = (byte)((x & 0xff0000) >> 16);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var b3 = (byte)((x & 0xff000000) >> 24);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: out_block[7] = Base32Alphabet[((b4 & 0x1f))];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var out_block = new char[8];
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: var buffer = new StringBuilder(input.Length * 2);
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Text,TextConversion,C:\repos\platformdotnet_Platform\src\Platform\Text\TextConversion.cs,ToBase32String,The following statement contains a magic number: for (int i = offset; i < offset + input.Length; i += 5)  			{  				if (i + 4 < input.Length)  				{  					b0 = input[i];  					b1 = input[i+1];  					b2 = input[i+2];  					b3 = input[i+3];  					b4 = input[i+4];  					  					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];  					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];  					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];  					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];  					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}  				else  				{  					b0 = b1 = b2 = b3 = b4 = 0;    					if (i < input.Length)  					{  						b0 = input[i];  					}    					if (i + 1 < input.Length)  					{  						b1 = input[i+1];  					}    					if (i + 2 < input.Length)  					{  						b2 = input[i+2];  					}    					if (i + 3 < input.Length)  					{  						b3 = input[i+3];  					}    					if (i + 4 < input.Length)  					{  						b4 = input[i+4];  					}    					out_block[0] = Base32Alphabet[((b0 & 0xF8) >> 3)];  					out_block[1] = Base32Alphabet[((b0 & 0x7) << 2) | ((b1 & 0xc0) >> 6)];    					if (i + 1 >= input.Length)  					{  						ex = 2;  						goto end;  					}    					out_block[2] = Base32Alphabet[((b1 & 0x3e) >> 1)];  					out_block[3] = Base32Alphabet[((b1 & 0x1) << 4) | ((b2 & 0xf0) >> 4)];    					if (i + 2 >= input.Length)  					{  						ex = 4;  						goto end;  					}    					out_block[4] = Base32Alphabet[((b2 & 0xf) << 1) | ((b3 & 0x80) >> 7)];    					if (i + 3 >= input.Length)  					{  						ex = 5;  						goto end;  					}    					out_block[5] = Base32Alphabet[((b3 & 0x7c) >> 2)];  					out_block[6] = Base32Alphabet[((b3 & 0x3) << 3) | ((b4 & 0xe0) >> 5)];    					if (i + 4 >= input.Length)  					{  						ex = 7;  						goto end;  					}    					out_block[7] = Base32Alphabet[((b4 & 0x1f))];  				}    			end:    				if (ex > -1)  				{  					for (int j = ex; j < out_block.Length; j++)  					{  						out_block[j] = '=';  					}  				}    				ex = -1;    				buffer.Append(out_block);  			}
Magic Number,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The following statement contains a magic number: foreach (var propertyInfo in GetProperties(typeof(T)))  			{  				var defaultValueAttribute = propertyInfo.GetFirstCustomAttribute<DefaultValueAttribute>(true);  				  				var propertyValue = Expression.Property(currentObject' propertyInfo.GetGetMethod());  				  				propertyInfos.Add(propertyInfo);    				if (defaultValueAttribute != null)  				{  					var unsetValueAttribute = propertyInfo.GetFirstCustomAttribute<UnsetValueAttribute>(true);  				  					defaultAttributes.Add(defaultValueAttribute);    					var propertyValidationContext = Expression.New  					(  						typeof(PropertyValidationContext<'>).MakeGenericType(typeof(T)' propertyInfo.PropertyType).GetConstructor  						(  							new[]  						 {  							validationContext.Type' typeof(PropertyInfo)' typeof(ValidationAttribute)' propertyInfo.PropertyType  						 }  						)'  						validationContext'  						Expression.Constant(propertyInfo)'  						Expression.Constant(defaultValueAttribute)'  						propertyValue  					);    					if (setDefaultsDynamicMethod == null)  					{  						setDefaultsDynamicMethod = new DynamicMethod("SetDefaults"' typeof(ValidationResult)' new[] { typeof(ValidationResult)' typeof(T)' typeof(List<Delegate>)' typeof(List<PropertyInfo>)' typeof(List<DefaultValueAttribute>)' typeof(ValidationContext<T>) });  						generator = setDefaultsDynamicMethod.GetILGenerator();  						endLabel = generator.DefineLabel();  					}    					var propertyValidationContextLocal = generator.DeclareLocal(propertyValidationContext.Type);    					var initPropertyValidationContext = (Action)  						delegate  						{  							if (validationContextInitiased)  							{  								return;  							}    							validationContextInitiased = true;    							generator.Emit(OpCodes.Ldloca' propertyValidationContextLocal);    							var constructor = typeof(PropertyValidationContext<'>).MakeGenericType(typeof(T)' propertyInfo.PropertyType).GetConstructor  							(  								new[]  							 {  								validationContext.Type' typeof(PropertyInfo)' typeof(ValidationAttribute)' propertyInfo.PropertyType  							 }  							);    							// Load ValidationContext  							generator.Emit(OpCodes.Ldarg_S' 5);    							// Load PropertyInfo  							generator.Emit(OpCodes.Ldarg_3);  							generator.Emit(OpCodes.Ldc_I4' propertyInfos.Count - 1);  							generator.Emit(OpCodes.Callvirt' typeof(List<PropertyInfo>).GetMethod("get_Item"));    							// Load ValidationAttribute  							generator.Emit(OpCodes.Ldarg_S' 4);  							generator.Emit(OpCodes.Ldc_I4' defaultAttributes.Count - 1);  							generator.Emit(OpCodes.Callvirt' typeof(List<DefaultValueAttribute>).GetMethod("get_Item"));    							// Load Value  							generator.Emit(OpCodes.Ldarg_1);  							generator.Emit(OpCodes.Call' propertyInfo.GetGetMethod());    							// Call constructor  							generator.Emit(OpCodes.Call' constructor);  						};    					generator.Emit(OpCodes.Ldarga' 0);  					generator.Emit(OpCodes.Call' typeof(ValidationResult).GetProperty("IsSuccess").GetGetMethod());  					generator.Emit(OpCodes.Brfalse' endLabel);    					var label = generator.DefineLabel();    					generator.Emit(OpCodes.Ldarg_1);  					generator.Emit(OpCodes.Callvirt' propertyInfo.GetGetMethod());    					var valueLocal = generator.DeclareLocal(propertyInfo.PropertyType);  					var currentPropertyValueLocal = generator.DeclareLocal(propertyInfo.PropertyType);    					generator.Emit(OpCodes.Stloc' currentPropertyValueLocal);  					  					if (unsetValueAttribute != null && unsetValueAttribute.ValueExpression != null)  					{  						initPropertyValidationContext();    						var unsetValueDelegate = GetDelegateFromExpression(unsetValueAttribute.ValueExpression' propertyValidationContext);    						delegates.Add(unsetValueDelegate);    						generator.Emit(OpCodes.Ldarg_2);  						generator.Emit(OpCodes.Ldc_I4' delegates.Count - 1);  						generator.Emit(OpCodes.Callvirt' typeof(List<Delegate>).GetMethod("get_Item"));  						generator.Emit(OpCodes.Castclass' unsetValueDelegate.GetType());  						  						generator.Emit(OpCodes.Ldloc' propertyValidationContextLocal);  						generator.Emit(OpCodes.Callvirt' unsetValueDelegate.GetType().GetMethod("Invoke"));    						if (unsetValueDelegate.Method.ReturnType != propertyInfo.PropertyType)  						{  							if (unsetValueDelegate.Method.ReturnType.IsValueType)  							{  								generator.Emit(OpCodes.Box' propertyInfo.PropertyType);  							}    							generator.Emit(OpCodes.Ldtoken' propertyInfo.PropertyType);  							generator.Emit(OpCodes.Call' typeof(Type).GetMethod("GetTypeFromHandle"' BindingFlags.Public | BindingFlags.Static));  							generator.Emit(OpCodes.Call' typeof(Convert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public' null' new[] { typeof(object)' typeof(Type) }' null));    							if (unsetValueDelegate.Method.ReturnType.IsValueType)  							{  								generator.Emit(OpCodes.Unbox_Any' propertyInfo.PropertyType);  							}  							else  							{  								generator.Emit(OpCodes.Castclass' propertyInfo.PropertyType);  							}  						}    						generator.Emit(OpCodes.Stloc' valueLocal  							);    					}  					else if (unsetValueAttribute != null && unsetValueAttribute.ValueExpression == null)  					{  						LoadValue(generator' propertyInfo.PropertyType' unsetValueAttribute.Value);  						generator.Emit(OpCodes.Stloc' valueLocal);  					}  					else  					{  						if (propertyInfo.PropertyType == typeof(string))  						{  							generator.Emit(OpCodes.Ldnull);  							generator.Emit(OpCodes.Stloc' valueLocal);  						}  						else if (propertyInfo.PropertyType.IsValueType)  						{  							generator.Emit(OpCodes.Ldloca' valueLocal);  							generator.Emit(OpCodes.Initobj' propertyInfo.PropertyType);  						}  						else  						{  							generator.Emit(OpCodes.Ldnull);  							generator.Emit(OpCodes.Stloc' valueLocal);  						}  					}    					if (propertyInfo.PropertyType.IsValueType)  					{  						if (propertyInfo.PropertyType.IsPrimitive)  						{  							generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  							generator.Emit(OpCodes.Ldloc' valueLocal);    							generator.Emit(OpCodes.Ceq);  						}  						else  						{  							generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  							generator.Emit(OpCodes.Box' currentPropertyValueLocal.LocalType);  							generator.Emit(OpCodes.Ldloc' valueLocal);  							generator.Emit(OpCodes.Box' valueLocal.LocalType);  							generator.Emit(OpCodes.Call' typeof(Object).GetMethod("Equals"' BindingFlags.Static | BindingFlags.Public' null' new [] { typeof(Object)' typeof(Object) }' null));  						}  					}  					else if (propertyInfo.PropertyType == typeof(string) && unsetValueAttribute == null)  					{  						generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  						generator.Emit(OpCodes.Call' typeof(String).GetMethod("IsNullOrEmpty"' BindingFlags.Public | BindingFlags.Static));  					}  					else  					{  						generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  						generator.Emit(OpCodes.Ldloc' valueLocal);  						generator.Emit(OpCodes.Ceq);  					}    					generator.Emit(OpCodes.Brfalse' label);    					generator.Emit(OpCodes.Ldarg_1);    					if (defaultValueAttribute.ValueExpression == null)  					{  						LoadValue(generator' propertyInfo.PropertyType' defaultValueAttribute.Value);  					}  					else  					{  						var defaultValueDelegate = GetDelegateFromExpression(defaultValueAttribute.ValueExpression' propertyValidationContext);  						  						delegates.Add(defaultValueDelegate);    						generator.Emit(OpCodes.Ldarg_2);  						generator.Emit(OpCodes.Ldc_I4' delegates.Count - 1);  						generator.Emit(OpCodes.Callvirt' typeof(List<Delegate>).GetMethod("get_Item"));  						generator.Emit(OpCodes.Castclass' defaultValueDelegate.GetType());    						initPropertyValidationContext();  						  						// Load PropertyValidationContext  						generator.Emit(OpCodes.Ldloc' propertyValidationContextLocal);    						generator.Emit(OpCodes.Callvirt' defaultValueDelegate.GetType().GetMethod("Invoke"));  						  						if (defaultValueDelegate.Method.ReturnType != propertyInfo.PropertyType)  						{  							generator.Emit(OpCodes.Ldtoken' propertyInfo.PropertyType);  							generator.Emit(OpCodes.Call' typeof(Type).GetMethod("GetTypeFromHandle"' BindingFlags.Public | BindingFlags.Static));  							generator.Emit(OpCodes.Call' typeof(Convert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public));  							generator.Emit(OpCodes.Castclass' propertyInfo.PropertyType);  						}  					}    					generator.Emit(OpCodes.Callvirt' propertyInfo.GetSetMethod());    					generator.MarkLabel(label);  				}  			}
Magic Number,Platform.Validation.Validators,ExpressionTreeBasedValidator<T>,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\ExpressionTreeBasedValidator.cs,BuildValidator,The following statement contains a magic number: foreach (var propertyInfo in GetProperties(typeof(T)))  			{  				var defaultValueAttribute = propertyInfo.GetFirstCustomAttribute<DefaultValueAttribute>(true);  				  				var propertyValue = Expression.Property(currentObject' propertyInfo.GetGetMethod());  				  				propertyInfos.Add(propertyInfo);    				if (defaultValueAttribute != null)  				{  					var unsetValueAttribute = propertyInfo.GetFirstCustomAttribute<UnsetValueAttribute>(true);  				  					defaultAttributes.Add(defaultValueAttribute);    					var propertyValidationContext = Expression.New  					(  						typeof(PropertyValidationContext<'>).MakeGenericType(typeof(T)' propertyInfo.PropertyType).GetConstructor  						(  							new[]  						 {  							validationContext.Type' typeof(PropertyInfo)' typeof(ValidationAttribute)' propertyInfo.PropertyType  						 }  						)'  						validationContext'  						Expression.Constant(propertyInfo)'  						Expression.Constant(defaultValueAttribute)'  						propertyValue  					);    					if (setDefaultsDynamicMethod == null)  					{  						setDefaultsDynamicMethod = new DynamicMethod("SetDefaults"' typeof(ValidationResult)' new[] { typeof(ValidationResult)' typeof(T)' typeof(List<Delegate>)' typeof(List<PropertyInfo>)' typeof(List<DefaultValueAttribute>)' typeof(ValidationContext<T>) });  						generator = setDefaultsDynamicMethod.GetILGenerator();  						endLabel = generator.DefineLabel();  					}    					var propertyValidationContextLocal = generator.DeclareLocal(propertyValidationContext.Type);    					var initPropertyValidationContext = (Action)  						delegate  						{  							if (validationContextInitiased)  							{  								return;  							}    							validationContextInitiased = true;    							generator.Emit(OpCodes.Ldloca' propertyValidationContextLocal);    							var constructor = typeof(PropertyValidationContext<'>).MakeGenericType(typeof(T)' propertyInfo.PropertyType).GetConstructor  							(  								new[]  							 {  								validationContext.Type' typeof(PropertyInfo)' typeof(ValidationAttribute)' propertyInfo.PropertyType  							 }  							);    							// Load ValidationContext  							generator.Emit(OpCodes.Ldarg_S' 5);    							// Load PropertyInfo  							generator.Emit(OpCodes.Ldarg_3);  							generator.Emit(OpCodes.Ldc_I4' propertyInfos.Count - 1);  							generator.Emit(OpCodes.Callvirt' typeof(List<PropertyInfo>).GetMethod("get_Item"));    							// Load ValidationAttribute  							generator.Emit(OpCodes.Ldarg_S' 4);  							generator.Emit(OpCodes.Ldc_I4' defaultAttributes.Count - 1);  							generator.Emit(OpCodes.Callvirt' typeof(List<DefaultValueAttribute>).GetMethod("get_Item"));    							// Load Value  							generator.Emit(OpCodes.Ldarg_1);  							generator.Emit(OpCodes.Call' propertyInfo.GetGetMethod());    							// Call constructor  							generator.Emit(OpCodes.Call' constructor);  						};    					generator.Emit(OpCodes.Ldarga' 0);  					generator.Emit(OpCodes.Call' typeof(ValidationResult).GetProperty("IsSuccess").GetGetMethod());  					generator.Emit(OpCodes.Brfalse' endLabel);    					var label = generator.DefineLabel();    					generator.Emit(OpCodes.Ldarg_1);  					generator.Emit(OpCodes.Callvirt' propertyInfo.GetGetMethod());    					var valueLocal = generator.DeclareLocal(propertyInfo.PropertyType);  					var currentPropertyValueLocal = generator.DeclareLocal(propertyInfo.PropertyType);    					generator.Emit(OpCodes.Stloc' currentPropertyValueLocal);  					  					if (unsetValueAttribute != null && unsetValueAttribute.ValueExpression != null)  					{  						initPropertyValidationContext();    						var unsetValueDelegate = GetDelegateFromExpression(unsetValueAttribute.ValueExpression' propertyValidationContext);    						delegates.Add(unsetValueDelegate);    						generator.Emit(OpCodes.Ldarg_2);  						generator.Emit(OpCodes.Ldc_I4' delegates.Count - 1);  						generator.Emit(OpCodes.Callvirt' typeof(List<Delegate>).GetMethod("get_Item"));  						generator.Emit(OpCodes.Castclass' unsetValueDelegate.GetType());  						  						generator.Emit(OpCodes.Ldloc' propertyValidationContextLocal);  						generator.Emit(OpCodes.Callvirt' unsetValueDelegate.GetType().GetMethod("Invoke"));    						if (unsetValueDelegate.Method.ReturnType != propertyInfo.PropertyType)  						{  							if (unsetValueDelegate.Method.ReturnType.IsValueType)  							{  								generator.Emit(OpCodes.Box' propertyInfo.PropertyType);  							}    							generator.Emit(OpCodes.Ldtoken' propertyInfo.PropertyType);  							generator.Emit(OpCodes.Call' typeof(Type).GetMethod("GetTypeFromHandle"' BindingFlags.Public | BindingFlags.Static));  							generator.Emit(OpCodes.Call' typeof(Convert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public' null' new[] { typeof(object)' typeof(Type) }' null));    							if (unsetValueDelegate.Method.ReturnType.IsValueType)  							{  								generator.Emit(OpCodes.Unbox_Any' propertyInfo.PropertyType);  							}  							else  							{  								generator.Emit(OpCodes.Castclass' propertyInfo.PropertyType);  							}  						}    						generator.Emit(OpCodes.Stloc' valueLocal  							);    					}  					else if (unsetValueAttribute != null && unsetValueAttribute.ValueExpression == null)  					{  						LoadValue(generator' propertyInfo.PropertyType' unsetValueAttribute.Value);  						generator.Emit(OpCodes.Stloc' valueLocal);  					}  					else  					{  						if (propertyInfo.PropertyType == typeof(string))  						{  							generator.Emit(OpCodes.Ldnull);  							generator.Emit(OpCodes.Stloc' valueLocal);  						}  						else if (propertyInfo.PropertyType.IsValueType)  						{  							generator.Emit(OpCodes.Ldloca' valueLocal);  							generator.Emit(OpCodes.Initobj' propertyInfo.PropertyType);  						}  						else  						{  							generator.Emit(OpCodes.Ldnull);  							generator.Emit(OpCodes.Stloc' valueLocal);  						}  					}    					if (propertyInfo.PropertyType.IsValueType)  					{  						if (propertyInfo.PropertyType.IsPrimitive)  						{  							generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  							generator.Emit(OpCodes.Ldloc' valueLocal);    							generator.Emit(OpCodes.Ceq);  						}  						else  						{  							generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  							generator.Emit(OpCodes.Box' currentPropertyValueLocal.LocalType);  							generator.Emit(OpCodes.Ldloc' valueLocal);  							generator.Emit(OpCodes.Box' valueLocal.LocalType);  							generator.Emit(OpCodes.Call' typeof(Object).GetMethod("Equals"' BindingFlags.Static | BindingFlags.Public' null' new [] { typeof(Object)' typeof(Object) }' null));  						}  					}  					else if (propertyInfo.PropertyType == typeof(string) && unsetValueAttribute == null)  					{  						generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  						generator.Emit(OpCodes.Call' typeof(String).GetMethod("IsNullOrEmpty"' BindingFlags.Public | BindingFlags.Static));  					}  					else  					{  						generator.Emit(OpCodes.Ldloc' currentPropertyValueLocal);  						generator.Emit(OpCodes.Ldloc' valueLocal);  						generator.Emit(OpCodes.Ceq);  					}    					generator.Emit(OpCodes.Brfalse' label);    					generator.Emit(OpCodes.Ldarg_1);    					if (defaultValueAttribute.ValueExpression == null)  					{  						LoadValue(generator' propertyInfo.PropertyType' defaultValueAttribute.Value);  					}  					else  					{  						var defaultValueDelegate = GetDelegateFromExpression(defaultValueAttribute.ValueExpression' propertyValidationContext);  						  						delegates.Add(defaultValueDelegate);    						generator.Emit(OpCodes.Ldarg_2);  						generator.Emit(OpCodes.Ldc_I4' delegates.Count - 1);  						generator.Emit(OpCodes.Callvirt' typeof(List<Delegate>).GetMethod("get_Item"));  						generator.Emit(OpCodes.Castclass' defaultValueDelegate.GetType());    						initPropertyValidationContext();  						  						// Load PropertyValidationContext  						generator.Emit(OpCodes.Ldloc' propertyValidationContextLocal);    						generator.Emit(OpCodes.Callvirt' defaultValueDelegate.GetType().GetMethod("Invoke"));  						  						if (defaultValueDelegate.Method.ReturnType != propertyInfo.PropertyType)  						{  							generator.Emit(OpCodes.Ldtoken' propertyInfo.PropertyType);  							generator.Emit(OpCodes.Call' typeof(Type).GetMethod("GetTypeFromHandle"' BindingFlags.Public | BindingFlags.Static));  							generator.Emit(OpCodes.Call' typeof(Convert).GetMethod("ChangeType"' BindingFlags.Static | BindingFlags.Public));  							generator.Emit(OpCodes.Castclass' propertyInfo.PropertyType);  						}  					}    					generator.Emit(OpCodes.Callvirt' propertyInfo.GetSetMethod());    					generator.MarkLabel(label);  				}  			}
Magic Number,Platform.Utilities,InvocationQueue,C:\repos\platformdotnet_Platform\src\Platform\Utilities\InvocationQueue.cs,InvocationQueue,The following statement contains a magic number: this.IdleWaitTime = TimeSpan.FromMilliseconds(250);
Missing Default,Platform,TaskAsyncStateAndImplementationHelper,C:\repos\platformdotnet_Platform\src\Platform\AbstractTask.cs,Start,The following switch statement is missing a default case: switch (task.TaskAsynchronisity)                      {                          case TaskAsynchronisity.AsyncWithSystemPoolThread:                              Action routine;                                routine = delegate                                        {                                            this.TaskThread = Thread.CurrentThread;                                              task.Run();                                        };                                routine.BeginInvoke(null' null);                                break;                          case TaskAsynchronisity.AsyncWithForegroundThread:                              thread = new Thread(task.Run);                                this.TaskThread = thread;                                thread.SetApartmentState(task.ApartmentState);                              thread.IsBackground = false;                              thread.Start();                                break;                          case TaskAsynchronisity.AsyncWithBackgroundThread:                              thread = new Thread(task.Run);                                this.TaskThread = thread;                              thread.SetApartmentState(task.ApartmentState);                              thread.IsBackground = true;                              thread.Start();                                break;                      }
Missing Default,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,IsRealType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.Single:  				case TypeCode.Double:  				case TypeCode.Decimal:  					return true;  			}
Missing Default,Platform,TypeUtils,C:\repos\platformdotnet_Platform\src\Platform\TypeUtils.cs,IsIntegerType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))  			{  				case TypeCode.SByte:  				case TypeCode.Byte:  				case TypeCode.UInt16:  				case TypeCode.Int16:  				case TypeCode.UInt32:  				case TypeCode.Int32:  				case TypeCode.UInt64:  				case TypeCode.Int64:  					return true;  			}
Missing Default,Platform.Validation.Validators,StringExpressionParser,C:\repos\platformdotnet_Platform\src\Platform\Validation\Validators\StringExpressionParser.cs,ParseComparison,The following switch statement is missing a default case: switch (operationToken)  				{  					case Token.Equals:  						retval = Expression.Equal(leftOperand' rightOperand);  						break;  					case Token.NotEquals:  						retval = Expression.NotEqual(leftOperand' rightOperand);  						break;  					case Token.GreaterThan:  						retval = Expression.GreaterThan(leftOperand' rightOperand);  						break;  					case Token.GreaterThanOrEqual:  						retval = Expression.GreaterThanOrEqual(leftOperand' rightOperand);  						break;  					case Token.LessThan:  						retval = Expression.LessThan(leftOperand' rightOperand);  						break;  					case Token.LessThanOrEqual:  						retval = Expression.LessThanOrEqual(leftOperand' rightOperand);  						break;  				}
