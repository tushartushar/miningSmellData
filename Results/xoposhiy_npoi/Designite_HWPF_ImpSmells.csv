Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The method has 203 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has 126 lines of code.
Long Method,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The method has 165 lines of code.
Long Method,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,The method has 123 lines of code.
Long Method,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The method has 104 lines of code.
Long Method,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The method has 125 lines of code.
Long Method,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,Serialize,The method has 108 lines of code.
Long Method,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The method has 204 lines of code.
Long Method,NPOI.HWPF.Model.Types,PAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,ToString,The method has 163 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The method has 195 lines of code.
Long Method,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The method has 461 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The method has 268 lines of code.
Long Method,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The method has 283 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The method has 149 lines of code.
Long Method,NPOI.HWPF.SPRM,SectionSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The method has 158 lines of code.
Long Method,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The method has 163 lines of code.
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,Cyclomatic complexity of the method is 47
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraphes,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,Cyclomatic complexity of the method is 26
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBulletText,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,Cyclomatic complexity of the method is 17
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,Cyclomatic complexity of the method is 18
Complex Method,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessTable,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,DefaultFontReplacer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF.Converter,NumberFormatter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\NumberFormatter.cs,ToLetters,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Model,BaseObject,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\BaseObject.cs,Clone,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 25
Complex Method,NPOI.HWPF.Model,Ffn,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Ffn.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.Model,ListTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListTables.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,Cyclomatic complexity of the method is 19
Complex Method,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,SectionTable,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,Cyclomatic complexity of the method is 57
Complex Method,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,Cyclomatic complexity of the method is 342
Complex Method,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,Cyclomatic complexity of the method is 64
Complex Method,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,Cyclomatic complexity of the method is 228
Complex Method,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,Cyclomatic complexity of the method is 47
Complex Method,NPOI.HWPF.SPRM,SectionSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,Cyclomatic complexity of the method is 151
Complex Method,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,Cyclomatic complexity of the method is 35
Complex Method,NPOI.HWPF.SPRM,TableSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,Cyclomatic complexity of the method is 51
Complex Method,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,Cyclomatic complexity of the method is 18
Complex Method,NPOI.HWPF.UserModel,FieldsImpl,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\FieldsImpl.cs,ParseFieldStructureImpl,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HWPF.UserModel,Range,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Range.cs,GetTable,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HWPF.UserModel,Range,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Range.cs,FindRange,Cyclomatic complexity of the method is 8
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,getTableCellEdgesIndexSkipCount,The method has 6 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessBookmarks,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 7 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDrawnObject,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessHyperlink,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessPageref,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraph,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessBookmarks,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessDrawnObject,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessHyperlink,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessPageref,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessParagraph,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The method has 7 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessBookmarks,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessDrawnObject,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessHyperlink,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessPageref,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessParagraph,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessBookmarks,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessDrawnObject,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessNoteAutonumbered,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessHyperlink,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessPageref,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The method has 7 parameters.
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 6 parameters.
Long Parameter List,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,CHPBinTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,ListLevel,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListLevel.cs,ListLevel,The method has 6 parameters.
Long Parameter List,NPOI.HWPF.Model,OldCHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\OldCHPBinTable.cs,OldCHPBinTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,OldPAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\OldPAPBinTable.cs,OldPAPBinTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,OldSectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 7 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,PAPBinTable,The method has 6 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,PAPFormattedDiskPage,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 6 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,PAPX,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,PicturesTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PicturesTable.cs,PicturesTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,SectionTable,The method has 7 parameters.
Long Parameter List,NPOI.HWPF.Model,TextPiece,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPiece.cs,TextPiece,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The method has 5 parameters.
Long Parameter List,NPOI.HWPF.UserModel,TableCell,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableCell.cs,TableCell,The method has 7 parameters.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,AddToStructures,The length of the statement  "		if ((structure.Start < another.Start && another.Start < structure.End) || (structure.Start < another.Start && another.End <= structure.End) || (structure.Start <= another.Start && another.End < structure.End)) { " is 211.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "		Dictionary<int' List<Bookmark>> rangeBookmarks = doc.GetBookmarks ().GetBookmarksStartedBetween (range.StartOffset' range.EndOffset); " is 133.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "			Field aliveField = ((HWPFDocument)wordDocument).GetFields ().GetFieldByStartOffset (FieldsDocumentPart.MAIN' characterRun.StartOffset); " is 135.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "			IEnumerator<List<Bookmark>> iterator = ((HWPFDocument)wordDocument).GetBookmarks ().GetBookmarksStartedBetween (structure.Start' structure.Start + 1).Values.GetEnumerator (); " is 174.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "			logger.Log (POILogger.WARN' "Latest structure in "' range' " ended at #" + previous' " after range boundaries ["' range.StartOffset + "; " + range.EndOffset' ")"); " is 163.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The length of the statement  "				Field aliveField = ((HWPFDocument)wordDocument).GetFields ().GetFieldByStartOffset (FieldsDocumentPart.MAIN' characterRun.StartOffset); " is 135.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessDeadField,The length of the statement  "	Range deadFieldValueSubrage = new Range (range.GetCharacterRun (separatorMark).StartOffset + 1' range.GetCharacterRun (endMark).StartOffset' range); " is 148.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessOle2,The length of the statement  "		logger.Log (POILogger.WARN' "Referenced OLE2 object '"' (characterRun.GetPicOffset ()).ToString ()' "' not found in ObjectPool"); " is 129.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessOle2,The length of the statement  "		logger.Log (POILogger.WARN' "Unable to convert internal OLE2 object '"' (characterRun.GetPicOffset ()).ToString ()' "': "' exc' exc); " is 133.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraphes,The length of the statement  "				throw new InvalidOperationException ("Trying to process table cell with higher level (" + paragraph.GetTableLevel () + ") than current table level (" + currentTableLevel + ") as inner table part"); " is 197.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessParagraphes,The length of the statement  "				logger.Log (POILogger.WARN' "Paragraph #" + paragraph.StartOffset + "-" + paragraph.EndOffset + " has reference to list structure #" + currentListInfo + "' but listTables not defined in file"); " is 193.
Long Statement,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,TryDeadField,The length of the statement  "			Field possibleField = ProcessDeadField (wordDocument' range' currentTableLevel' characterRun.StartOffset' currentBlock); " is 120.
Long Statement,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessImage,The length of the statement  "		String url = fileManager.SavePicture (picture.GetContent ()' picture.SuggestPictureType ()' picture.SuggestFullFileName ()); " is 124.
Long Statement,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessImage,The length of the statement  "	currentBlock.AppendChild (foDocumentFacade.Document.CreateComment ("Image link to '" + picture.SuggestFullFileName () + "' can be here")); " is 138.
Long Statement,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,ProcessTable,The length of the statement  "			WordToFoUtils.SetTableCellProperties (tableRow' tableCell' tableCellElement' r == 0' r == tableRows - 1' c == 0' c == rowCells - 1); " is 132.
Long Statement,NPOI.HWPF.Converter,FoDocumentFacade,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\FoDocumentFacade.cs,SetProperty,The length of the statement  "			if (!string.IsNullOrEmpty (childElement.NamespaceURI) && !string.IsNullOrEmpty (childElement.LocalName) && ns.Equals (childElement.NamespaceURI) && name.Equals (childElement.LocalName)) { " is 187.
Long Statement,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The length of the statement  "		graphicXmlElement.SetAttribute ("clip"' "rect(" + rectTop + "pt' " + rectRight + "pt' " + rectBottom + "pt' " + rectLeft + "pt)"); " is 130.
Long Statement,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The length of the statement  "	BorderCode top = tableCell.GetBrcTop () != null && tableCell.GetBrcTop ().BorderType != 0 ? tableCell.GetBrcTop () : toppest ? tableRow.GetTopBorder () : tableRow.GetHorizontalBorder (); " is 186.
Long Statement,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The length of the statement  "	BorderCode bottom = tableCell.GetBrcBottom () != null && tableCell.GetBrcBottom ().BorderType != 0 ? tableCell.GetBrcBottom () : bottomest ? tableRow.GetBottomBorder () : tableRow.GetHorizontalBorder (); " is 203.
Long Statement,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The length of the statement  "	BorderCode left = tableCell.GetBrcLeft () != null && tableCell.GetBrcLeft ().BorderType != 0 ? tableCell.GetBrcLeft () : leftest ? tableRow.GetLeftBorder () : tableRow.GetVerticalBorder (); " is 189.
Long Statement,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetTableCellProperties,The length of the statement  "	BorderCode right = tableCell.GetBrcRight () != null && tableCell.GetBrcRight ().BorderType != 0 ? tableCell.GetBrcRight () : rightest ? tableRow.GetRightBorder () : tableRow.GetVerticalBorder (); " is 195.
Long Statement,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessHyperlink,The length of the statement  "	currentBlock.AppendChild (textDocumentFacade.CreateText (" (" + UNICODECHAR_ZERO_WIDTH_SPACE + hyperlink.Replace ("\\/"' UNICODECHAR_ZERO_WIDTH_SPACE + "\\/" + UNICODECHAR_ZERO_WIDTH_SPACE) + UNICODECHAR_ZERO_WIDTH_SPACE + ")")); " is 229.
Long Statement,NPOI.HWPF.Converter,WordToTextConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToTextConverter.cs,ProcessNote,The length of the statement  "	block.AppendChild (textDocumentFacade.CreateText (UNICODECHAR_ZERO_WIDTH_SPACE + "[" + noteIndex + "]" + UNICODECHAR_ZERO_WIDTH_SPACE)); " is 136.
Long Statement,NPOI.HWPF.Converter,DefaultFontReplacer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,The length of the statement  "			fontName = AbstractWordUtils.SubstringBeforeLast (fontName' " \u041F\u043E\u043B\u0443\u0436\u0438\u0440\u043D\u044B\u0439") + " Bold"; " is 135.
Long Statement,NPOI.HWPF.Converter,DefaultFontReplacer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,The length of the statement  "		if (fontName.EndsWith (" \u041F\u043E\u043B\u0443\u0436\u0438\u0440\u043D\u044B\u0439 \u041A\u0443\u0440\u0441\u0438\u0432")) " is 125.
Long Statement,NPOI.HWPF.Converter,DefaultFontReplacer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\DefaultFontReplacer.cs,Update,The length of the statement  "			fontName = AbstractWordUtils.SubstringBeforeLast (fontName' " \u041F\u043E\u043B\u0443\u0436\u0438\u0440\u043D\u044B\u0439 \u041A\u0443\u0440\u0441\u0438\u0432") + " Bold Italic"; " is 179.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "		String url = fileManager.SavePicture (picture.GetContent ()' picture.SuggestPictureType ()' picture.SuggestFullFileName ()); " is 124.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "	currentBlock.AppendChild (htmlDocumentFacade.Document.CreateComment ("Image link to '" + picture.SuggestFullFileName () + "' can be here")); " is 140.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "		htmlDocumentFacade.AddStyleClass (root' "d"' "vertical-align:text-bottom;width:" + visibleWidth + "in;height:" + visibleHeight + "in;"); " is 136.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "		htmlDocumentFacade.AddStyleClass (inner' "d"' "position:relative;width:" + visibleWidth + "in;height:" + visibleHeight + "in;overflow:hidden;"); " is 144.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The length of the statement  "		htmlDocumentFacade.AddStyleClass (image' "i"' "position:absolute;left:-" + cropLeft + ";top:-" + cropTop + ";width:" + imageWidth + "in;height:" + imageHeight + "in;"); " is 168.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "			WordToHtmlUtils.AddTableCellProperties (tableRow' tableCell' r == 0' r == tableRows - 1' c == 0' c == rowCells - 1' tableCellStyle); " is 132.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "	tableElement.SetAttribute ("class"' htmlDocumentFacade.GetOrCreateCssClass (tableElement.LocalName' "t"' "table-layout:fixed;border-collapse:collapse;border-spacing:0;")); " is 171.
Long Statement,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessTable,The length of the statement  "		logger.Log (POILogger.WARN' "Table without body starting at ["' table.StartOffset.ToString ()' "; "' table.EndOffset.ToString ()' ")"); " is 135.
Long Statement,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The length of the statement  "	BorderCode top = tableCell.GetBrcTop () != null && tableCell.GetBrcTop ().BorderType != 0 ? tableCell.GetBrcTop () : toppest ? tableRow.GetTopBorder () : tableRow.GetHorizontalBorder (); " is 186.
Long Statement,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The length of the statement  "	BorderCode bottom = tableCell.GetBrcBottom () != null && tableCell.GetBrcBottom ().BorderType != 0 ? tableCell.GetBrcBottom () : bottomest ? tableRow.GetBottomBorder () : tableRow.GetHorizontalBorder (); " is 203.
Long Statement,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The length of the statement  "	BorderCode left = tableCell.GetBrcLeft () != null && tableCell.GetBrcLeft ().BorderType != 0 ? tableCell.GetBrcLeft () : leftest ? tableRow.GetLeftBorder () : tableRow.GetVerticalBorder (); " is 189.
Long Statement,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddTableCellProperties,The length of the statement  "	BorderCode right = tableCell.GetBrcRight () != null && tableCell.GetBrcRight ().BorderType != 0 ? tableCell.GetBrcRight () : rightest ? tableRow.GetRightBorder () : tableRow.GetVerticalBorder (); " is 195.
Long Statement,NPOI.HWPF.Model,BookmarksTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\BookmarksTables.cs,Read,The length of the statement  "		descriptorsFirst = new PlexOfCps (tableStream' firstDescriptorsStart' firstDescriptorsLength' BookmarkFirstDescriptor.GetSize ()); " is 130.
Long Statement,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Rebuild,The length of the statement  "		logger.Log (POILogger.DEBUG' "Merged with CHPX from complex file table in "' DateTime.Now.Ticks - start' " ms ("' _textRuns.Count' " elements in total)"); " is 154.
Long Statement,NPOI.HWPF.Model,FileInformationBlock,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FileInformationBlock.cs,FillVariableFields,The length of the statement  "	_fieldHandler = new FIBFieldHandler (mainDocument' FIBshortHandler.START + _shortHandler.SizeInBytes () + _longHandler.SizeInBytes ()' tableStream' knownFieldSet' true); " is 169.
Long Statement,NPOI.HWPF.Model,FileInformationBlock,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FileInformationBlock.cs,SetSubdocumentTextStreamLength,The length of the statement  "		throw new ArgumentException ("Subdocument length can't be less than 0 (passed value is " + length + "). " + "If there is no subdocument " + "length must be Set to zero."); " is 171.
Long Statement,NPOI.HWPF.Model,FileInformationBlock,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FileInformationBlock.cs,WriteTo,The length of the statement  "	_fieldHandler.WriteTo (mainStream' base.GetSize () + _shortHandler.SizeInBytes () + _longHandler.SizeInBytes ()' tableStream); " is 126.
Long Statement,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,Equals,The length of the statement  "	return lst._info == _info && Arrays.Equals (lst._levels' _levels) && lst._lsid == _lsid && lst._reserved == _reserved && lst._tplc == _tplc && Arrays.Equals (lst._rgistd' _rgistd); " is 180.
Long Statement,NPOI.HWPF.Model,ListFormatOverride,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListFormatOverride.cs,Equals,The length of the statement  "	return lfo._clfolvl == _clfolvl && lfo._lsid == _lsid && lfo._reserved1 == _reserved1 && lfo._reserved2 == _reserved2 && Arrays.Equals (lfo._reserved3' _reserved3) && Arrays.Equals (lfo._levelOverrides' _levelOverrides); " is 220.
Long Statement,NPOI.HWPF.Model,ListFormatOverrideLevel,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,Equals,The length of the statement  "	return lvlEquality && lfolvl._iStartAt == _iStartAt && lfolvl._info == _info && Arrays.Equals (lfolvl._reserved' _reserved); " is 124.
Long Statement,NPOI.HWPF.Model,ListLevel,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListLevel.cs,Equals,The length of the statement  "	return _cbGrpprlChpx == lvl._cbGrpprlChpx && lvl._cbGrpprlPapx == _cbGrpprlPapx && lvl._dxaIndent == _dxaIndent && lvl._dxaSpace == _dxaSpace && Arrays.Equals (lvl._grpprlChpx' _grpprlChpx) && Arrays.Equals (lvl._grpprlPapx' _grpprlPapx) && lvl._info == _info && lvl._iStartAt == _iStartAt && lvl._ixchFollow == _ixchFollow && lvl._nfc == _nfc && Arrays.Equals (lvl._numberText' _numberText) && Arrays.Equals (lvl._rgbxchNums' _rgbxchNums) && lvl._reserved == _reserved; " is 470.
Long Statement,NPOI.HWPF.Model,ListTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListTables.cs,GetLevel,The length of the statement  "	//log.log(POILogger.WARN' "Requested level " + level + " which was greater than the maximum defined (" + lst.numLevels() + ")"); " is 128.
Long Statement,NPOI.HWPF.Model,NotesTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\NotesTables.cs,Read,The length of the statement  "		this.descriptors = new PlexOfCps (tableStream' referencesStart' referencesLength' FootnoteReferenceDescriptor.GetSize ()); " is 122.
Long Statement,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The length of the statement  "		logger.Log (POILogger.DEBUG' "Merged (?) with PAPX from complex file table in "' DateTime.Now.Ticks - start' " ms ("' _paragraphs.Count' " elements in total)"); " is 160.
Long Statement,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The length of the statement  "	logger.Log (POILogger.DEBUG' "PAPX rebuilded from document text in "' DateTime.Now.Ticks - start' " ms ("' _paragraphs.Count' " elements)"); " is 140.
Long Statement,NPOI.HWPF.Model,ParagraphHeight,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ParagraphHeight.cs,Equals,The length of the statement  "	return infoField == ph.infoField && reserved == ph.reserved && dxaCol == ph.dxaCol && dymLineOrHeight == ph.dymLineOrHeight; " is 124.
Long Statement,NPOI.HWPF.Model,PicturesTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PicturesTable.cs,IsPictureRecognized,The length of the statement  "	return (blockType == TYPE_IMAGE || blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD || (blockType == TYPE_IMAGE_WORD2000 && mappingModeOfMETAFILEPICT == 0x64) || (blockType == TYPE_IMAGE_PASTED_FROM_CLIPBOARD_WORD2000 && mappingModeOfMETAFILEPICT == 0x64)); " is 254.
Long Statement,NPOI.HWPF.Model,PlexOfField,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PlexOfField.cs,ToString,The length of the statement  "	return string.Format ("[{0}' {1}) - FLD - 0x{2}; 0x{3}"' FcStart' FcEnd' StringUtil.ToHexString (0xff & fld.GetBoundaryType ())' StringUtil.ToHexString (0xff & fld.GetFlt ())); " is 176.
Long Statement,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The length of the statement  "		GenericPropertyNode property = new GenericPropertyNode (tpt.GetCharIndex (sepx.StartBytes)' tpt.GetCharIndex (sepx.EndBytes)' sed.ToArray ()); " is 142.
Long Statement,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The length of the statement  "		throw new NotSupportedException ("Non-extended character Pascal strings are not supported right now. " + "Please' contact POI developers for update."); " is 151.
Long Statement,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,Equals,The length of the statement  "	if (sd._infoshort == _infoshort && sd._infoshort2 == _infoshort2 && sd._infoshort3 == _infoshort3 && sd._bchUpe == _bchUpe && sd._infoshort4 == _infoshort4 && _name.Equals (sd._name)) { " is 185.
Long Statement,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The length of the statement  "	if (ss._baseLength == _baseLength && ss._flags == _flags && ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex && ss._rgftc [0] == _rgftc [0] && ss._rgftc [1] == _rgftc [1] && ss._rgftc [2] == _rgftc [2] && ss._stshiLength == _stshiLength && ss._stylenameVersion == _stylenameVersion) { " is 300.
Long Statement,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The length of the statement  "					throw new InvalidOperationException ("Pap style " + istd + " claimed to have itself as its parent' which isn't allowed"); " is 121.
Long Statement,NPOI.HWPF.Model,TextPiece,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPiece.cs,Substring,The length of the statement  "		throw new IndexOutOfRangeException ("Asked for text from " + start + " to " + end + "' which has an end before the start!"); " is 124.
Long Statement,NPOI.HWPF.Model,TextPiece,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPiece.cs,Equals,The length of the statement  "		return GetStringBuilder ().ToString ().Equals (tp.GetStringBuilder ().ToString ()) && tp._usesUnicode == _usesUnicode && _pd.Equals (tp._pd); " is 141.
Long Statement,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The length of the statement  "	return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4; " is 183.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,ToString,The length of the statement  "	buffer.Append ("         .oldfSuppressSpbfAfterPageBreak     = ").Append (IsOldfSuppressSpbfAfterPageBreak ()).Append ('\n'); " is 125.
Long Statement,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The length of the statement  "	return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2; " is 227.
Long Statement,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,ToString,The length of the statement  "	builder.Append ("         .fHtmlHangingIndentBeneathNumber     = ").Append (IsFHtmlHangingIndentBeneathNumber ()).Append ('\n'); " is 128.
Long Statement,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The length of the statement  "	if (newPAP.GetItbdMac () != oldPAP.GetItbdMac () || !Arrays.Equals (newPAP.GetRgdxaTab ()' oldPAP.GetRgdxaTab ()) || !Arrays.Equals (newPAP.GetRgtbd ()' oldPAP.GetRgtbd ())) { " is 175.
Long Statement,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The length of the statement  "	if (newPAP.IsFBackward () != oldPAP.IsFBackward () || newPAP.IsFVertical () != oldPAP.IsFVertical () || newPAP.IsFRotateFont () != oldPAP.IsFRotateFont ()) { " is 157.
Long Statement,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The length of the statement  "	if (newPAP.GetFPropRMark () != oldPAP.GetFPropRMark () || newPAP.GetIbstPropRMark () != oldPAP.GetIbstPropRMark () || !newPAP.GetDttmPropRMark ().Equals (oldPAP.GetDttmPropRMark ())) { " is 184.
Long Statement,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The length of the statement  "	if (newSEP.GetFPropMark () != DEFAULT_SEP.GetFPropMark () || newSEP.GetIbstPropRMark () != DEFAULT_SEP.GetIbstPropRMark () || !newSEP.GetDttmPropRMark ().Equals (DEFAULT_SEP.GetDttmPropRMark ())) { " is 197.
Long Statement,NPOI.HWPF.SPRM,TableSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmCompressor.cs,CompressTableProperty,The length of the statement  "			cellDescriptors [x].Serialize (buf' 1 + ((itcMac + 1) * LittleEndianConsts.SHORT_SIZE) + (x * TableCellDescriptor.SIZE)); " is 121.
Long Statement,NPOI.HWPF.UserModel,FieldImpl,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\FieldImpl.cs,ToString,The length of the statement  "	return "Field [" + GetFieldStartOffset () + "; " + GetFieldEndOffset () + "] (type: 0x" + StringUtil.ToHexString (Type) + " = " + GetType () + " )"; " is 148.
Long Statement,NPOI.HWPF.UserModel,FieldsImpl,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\FieldsImpl.cs,ParseFieldStructureImpl,The length of the statement  "			int endNodePositionInList = BinarySearch (plexOfFields' nextNodePositionInList' endOffsetExclusive' separatorPlexOfField.FcEnd); " is 128.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The length of the statement  "			ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress); " is 121.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetPictureBytesStartOffset,The length of the statement  "	int unknownHeaderOffset = (PICTF1BlockSize + PICTF1BlockOffset) < dataBlockEndOffset ? (PICTF1BlockSize + PICTF1BlockOffset) : PICTF1BlockOffset; " is 145.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The length of the statement  "			else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) { " is 123.
Long Statement,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The length of the statement  "	return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF)); " is 142.
Long Statement,NPOI.HWPF.UserModel,Range,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Range.cs,ReplaceText,The length of the statement  "	subRange = new Range ((absPlaceHolderIndex + pValue.Length)' (absPlaceHolderIndex + pPlaceHolder.Length + pValue.Length)' GetDocument ()); " is 138.
Long Statement,NPOI.HWPF.UserModel,Range,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Range.cs,GetCharacterRun,The length of the statement  "		throw new IndexOutOfRangeException ("CHPX #" + index + " (" + (index + _charStart) + ") not in range [" + _charStart + "; " + _charEnd + ")"); " is 142.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "		if (((s.Length > 0 && s [s.Length - 1] == TABLE_CELL_MARK) || paragraph.IsEmbeddedCellMark ()) && paragraph.GetTableLevel () == _levelNum) { " is 140.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "			TableCellDescriptor tableCellDescriptor = _tprops.GetRgtc () != null && _tprops.GetRgtc ().Length > cells.Count ? _tprops.GetRgtc () [cells.Count] : new TableCellDescriptor (); " is 176.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "			short leftEdge = (_tprops.GetRgdxaCenter () != null && _tprops.GetRgdxaCenter ().Length > cells.Count) ? (short)_tprops.GetRgdxaCenter () [cells.Count] : (short)0; " is 163.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "			short rightEdge = (_tprops.GetRgdxaCenter () != null && _tprops.GetRgdxaCenter ().Length > cells.Count + 1) ? (short)_tprops.GetRgdxaCenter () [cells.Count + 1] : (short)0; " is 172.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "			TableCell tableCell = new TableCell (GetParagraph (lastCellStart).StartOffset' GetParagraph (p).EndOffset' this' _levelNum' tableCellDescriptor' leftEdge' rightEdge - leftEdge); " is 177.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "		TableCellDescriptor tableCellDescriptor = _tprops.GetRgtc () != null && _tprops.GetRgtc ().Length > cells.Count ? _tprops.GetRgtc () [cells.Count] : new TableCellDescriptor (); " is 176.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "		short leftEdge = _tprops.GetRgdxaCenter () != null && _tprops.GetRgdxaCenter ().Length > cells.Count ? (short)_tprops.GetRgdxaCenter () [cells.Count] : (short)0; " is 161.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "		short rightEdge = _tprops.GetRgdxaCenter () != null && _tprops.GetRgdxaCenter ().Length > cells.Count + 1 ? (short)_tprops.GetRgdxaCenter () [cells.Count + 1] : (short)0; " is 170.
Long Statement,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The length of the statement  "		TableCell tableCell = new TableCell (lastCellStart' (NumParagraphs - 1)' this' _levelNum' tableCellDescriptor' leftEdge' rightEdge - leftEdge); " is 143.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,AddToStructures,The conditional expression  "(structure.Start < another.Start && another.Start < structure.End) || (structure.Start < another.Start && another.End <= structure.End) || (structure.Start <= another.Start && another.End < structure.End)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The conditional expression  "charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D"  is complex.
Complex Conditional,NPOI.HWPF.Converter,FoDocumentFacade,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\FoDocumentFacade.cs,SetProperty,The conditional expression  "!string.IsNullOrEmpty (childElement.NamespaceURI) && !string.IsNullOrEmpty (childElement.LocalName) && ns.Equals (childElement.NamespaceURI) && name.Equals (childElement.LocalName)"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The conditional expression  "picture.DyaCropTop != 0 || picture.DxaCropRight != 0 || picture.DyaCropBottom != 0 || picture.DxaCropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The conditional expression  "cropTop != 0 || cropRight != 0 || cropBottom != 0 || cropLeft != 0"  is complex.
Complex Conditional,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The conditional expression  "first6 [0] == '{' && first6 [1] == '\\' && first6 [2] == 'r' && first6 [3] == 't' && first6 [4] == 'f'"  is complex.
Complex Conditional,NPOI.HWPF.Model,FileInformationBlock,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FileInformationBlock.cs,ToString,The conditional expression  "!method.Name.StartsWith ("get") || !method.IsPublic || method.IsStatic || method.GetParameters ().Length > 0"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PicturesTable.cs,HasPicture,The conditional expression  "run.IsSpecialCharacter () && !run.IsObj () && !run.IsOle2 () && !run.IsData ()"  is complex.
Complex Conditional,NPOI.HWPF.Model,PicturesTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PicturesTable.cs,HasEscherPicture,The conditional expression  "run.IsSpecialCharacter () && !run.IsObj () && !run.IsOle2 () && !run.IsData () && run.Text.StartsWith ("\u0008")"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,Equals,The conditional expression  "sd._infoshort == _infoshort && sd._infoshort2 == _infoshort2 && sd._infoshort3 == _infoshort3 && sd._bchUpe == _bchUpe && sd._infoshort4 == _infoshort4 && _name.Equals (sd._name)"  is complex.
Complex Conditional,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The conditional expression  "ss._baseLength == _baseLength && ss._flags == _flags && ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex && ss._rgftc [0] == _rgftc [0] && ss._rgftc [1] == _rgftc [1] && ss._rgftc [2] == _rgftc [2] && ss._stshiLength == _stshiLength && ss._stylenameVersion == _stylenameVersion"  is complex.
Complex Conditional,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The conditional expression  "fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The conditional expression  "(secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,Range,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Range.cs,FindRange,The conditional expression  "startIndex < 0 || startIndex >= rpl.Count || startIndex > endIndex || endIndex < 0 || endIndex >= rpl.Count"  is complex.
Complex Conditional,NPOI.HWPF.UserModel,TableRow,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\TableRow.cs,initCells,The conditional expression  "((s.Length > 0 && s [s.Length - 1] == TABLE_CELL_MARK) || paragraph.IsEmbeddedCellMark ()) && paragraph.GetTableLevel () == _levelNum"  is complex.
Empty Catch Block,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAP,The method has an empty catch block.
Empty Catch Block,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The method has an empty catch block.
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++) {  	CharacterRun characterRun = range.GetCharacterRun (c);  	if (characterRun == null)  		throw new NullReferenceException ();  	if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable ().HasPicture (characterRun)) {  		HWPFDocument newFormat = (HWPFDocument)wordDocument;  		Picture picture = newFormat.GetPicturesTable ().ExtractPicture (characterRun' true);  		ProcessImage (block' characterRun.Text [0] == 0x01' picture);  		continue;  	}  	string text = characterRun.Text;  	byte[] textByte = System.Text.Encoding.GetEncoding ("iso-8859-1").GetBytes (text);  	//if ( text.getBytes().length == 0 )  	if (textByte.Length == 0)  		continue;  	if (characterRun.IsSpecialCharacter ()) {  		if (text [0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessNoteAnchor (doc' characterRun' block);  			continue;  		}  		if (text [0] == SPECCHAR_DRAWN_OBJECT && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessDrawnObject (doc' characterRun' block);  			continue;  		}  		if (characterRun.IsOle2 () && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessOle2 (doc' characterRun' block);  			continue;  		}  	}  	if (textByte [0] == FIELD_BEGIN_MARK)//if ( text.getBytes()[0] == FIELD_BEGIN_MARK )  	 {  		if (wordDocument is HWPFDocument) {  			Field aliveField = ((HWPFDocument)wordDocument).GetFields ().GetFieldByStartOffset (FieldsDocumentPart.MAIN' characterRun.StartOffset);  			if (aliveField != null) {  				ProcessField (((HWPFDocument)wordDocument)' range' currentTableLevel' aliveField' block);  				int continueAfter = aliveField.GetFieldEndOffset ();  				while (c < range.NumCharacterRuns && range.GetCharacterRun (c).EndOffset <= continueAfter)  					c++;  				if (c < range.NumCharacterRuns)  					c--;  				continue;  			}  		}  		int skipTo = TryDeadField (wordDocument' range' currentTableLevel' c' block);  		if (skipTo != c) {  			c = skipTo;  			continue;  		}  		continue;  	}  	if (textByte [0] == FIELD_SEPARATOR_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (textByte [0] == FIELD_END_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (characterRun.IsSpecialCharacter () || characterRun.IsObj () || characterRun.IsOle2 ()) {  		continue;  	}  	if (text.EndsWith ("\r") || (text [text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))  		text = text.Substring (0' text.Length - 1);  	{  		// line breaks  		StringBuilder stringBuilder = new StringBuilder ();  		foreach (char charChar in text.ToCharArray ()) {  			if (charChar == 11) {  				if (stringBuilder.Length > 0) {  					OutputCharacters (block' characterRun' stringBuilder.ToString ());  					stringBuilder.Length = 0;  				}  				ProcessLineBreak (block' characterRun);  			}  			else if (charChar == 30) {  				// Non-breaking hyphens are stored as ASCII 30  				stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  			}  			else if (charChar == 31) {  				// Non-required hyphens to zero-width space  				stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  			}  			else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  				stringBuilder.Append (charChar);  			}  		}  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  	}  	haveAnyText |= text.Trim ().Length != 0;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++) {  	CharacterRun characterRun = range.GetCharacterRun (c);  	if (characterRun == null)  		throw new NullReferenceException ();  	if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable ().HasPicture (characterRun)) {  		HWPFDocument newFormat = (HWPFDocument)wordDocument;  		Picture picture = newFormat.GetPicturesTable ().ExtractPicture (characterRun' true);  		ProcessImage (block' characterRun.Text [0] == 0x01' picture);  		continue;  	}  	string text = characterRun.Text;  	byte[] textByte = System.Text.Encoding.GetEncoding ("iso-8859-1").GetBytes (text);  	//if ( text.getBytes().length == 0 )  	if (textByte.Length == 0)  		continue;  	if (characterRun.IsSpecialCharacter ()) {  		if (text [0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessNoteAnchor (doc' characterRun' block);  			continue;  		}  		if (text [0] == SPECCHAR_DRAWN_OBJECT && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessDrawnObject (doc' characterRun' block);  			continue;  		}  		if (characterRun.IsOle2 () && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessOle2 (doc' characterRun' block);  			continue;  		}  	}  	if (textByte [0] == FIELD_BEGIN_MARK)//if ( text.getBytes()[0] == FIELD_BEGIN_MARK )  	 {  		if (wordDocument is HWPFDocument) {  			Field aliveField = ((HWPFDocument)wordDocument).GetFields ().GetFieldByStartOffset (FieldsDocumentPart.MAIN' characterRun.StartOffset);  			if (aliveField != null) {  				ProcessField (((HWPFDocument)wordDocument)' range' currentTableLevel' aliveField' block);  				int continueAfter = aliveField.GetFieldEndOffset ();  				while (c < range.NumCharacterRuns && range.GetCharacterRun (c).EndOffset <= continueAfter)  					c++;  				if (c < range.NumCharacterRuns)  					c--;  				continue;  			}  		}  		int skipTo = TryDeadField (wordDocument' range' currentTableLevel' c' block);  		if (skipTo != c) {  			c = skipTo;  			continue;  		}  		continue;  	}  	if (textByte [0] == FIELD_SEPARATOR_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (textByte [0] == FIELD_END_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (characterRun.IsSpecialCharacter () || characterRun.IsObj () || characterRun.IsOle2 ()) {  		continue;  	}  	if (text.EndsWith ("\r") || (text [text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))  		text = text.Substring (0' text.Length - 1);  	{  		// line breaks  		StringBuilder stringBuilder = new StringBuilder ();  		foreach (char charChar in text.ToCharArray ()) {  			if (charChar == 11) {  				if (stringBuilder.Length > 0) {  					OutputCharacters (block' characterRun' stringBuilder.ToString ());  					stringBuilder.Length = 0;  				}  				ProcessLineBreak (block' characterRun);  			}  			else if (charChar == 30) {  				// Non-breaking hyphens are stored as ASCII 30  				stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  			}  			else if (charChar == 31) {  				// Non-required hyphens to zero-width space  				stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  			}  			else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  				stringBuilder.Append (charChar);  			}  		}  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  	}  	haveAnyText |= text.Trim ().Length != 0;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: for (int c = 0; c < range.NumCharacterRuns; c++) {  	CharacterRun characterRun = range.GetCharacterRun (c);  	if (characterRun == null)  		throw new NullReferenceException ();  	if (wordDocument is HWPFDocument && ((HWPFDocument)wordDocument).GetPicturesTable ().HasPicture (characterRun)) {  		HWPFDocument newFormat = (HWPFDocument)wordDocument;  		Picture picture = newFormat.GetPicturesTable ().ExtractPicture (characterRun' true);  		ProcessImage (block' characterRun.Text [0] == 0x01' picture);  		continue;  	}  	string text = characterRun.Text;  	byte[] textByte = System.Text.Encoding.GetEncoding ("iso-8859-1").GetBytes (text);  	//if ( text.getBytes().length == 0 )  	if (textByte.Length == 0)  		continue;  	if (characterRun.IsSpecialCharacter ()) {  		if (text [0] == SPECCHAR_AUTONUMBERED_FOOTNOTE_REFERENCE && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessNoteAnchor (doc' characterRun' block);  			continue;  		}  		if (text [0] == SPECCHAR_DRAWN_OBJECT && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessDrawnObject (doc' characterRun' block);  			continue;  		}  		if (characterRun.IsOle2 () && (wordDocument is HWPFDocument)) {  			HWPFDocument doc = (HWPFDocument)wordDocument;  			ProcessOle2 (doc' characterRun' block);  			continue;  		}  	}  	if (textByte [0] == FIELD_BEGIN_MARK)//if ( text.getBytes()[0] == FIELD_BEGIN_MARK )  	 {  		if (wordDocument is HWPFDocument) {  			Field aliveField = ((HWPFDocument)wordDocument).GetFields ().GetFieldByStartOffset (FieldsDocumentPart.MAIN' characterRun.StartOffset);  			if (aliveField != null) {  				ProcessField (((HWPFDocument)wordDocument)' range' currentTableLevel' aliveField' block);  				int continueAfter = aliveField.GetFieldEndOffset ();  				while (c < range.NumCharacterRuns && range.GetCharacterRun (c).EndOffset <= continueAfter)  					c++;  				if (c < range.NumCharacterRuns)  					c--;  				continue;  			}  		}  		int skipTo = TryDeadField (wordDocument' range' currentTableLevel' c' block);  		if (skipTo != c) {  			c = skipTo;  			continue;  		}  		continue;  	}  	if (textByte [0] == FIELD_SEPARATOR_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (textByte [0] == FIELD_END_MARK) {  		// shall not appear without FIELD_BEGIN_MARK  		continue;  	}  	if (characterRun.IsSpecialCharacter () || characterRun.IsObj () || characterRun.IsOle2 ()) {  		continue;  	}  	if (text.EndsWith ("\r") || (text [text.Length - 1] == BEL_MARK && currentTableLevel != int.MinValue))  		text = text.Substring (0' text.Length - 1);  	{  		// line breaks  		StringBuilder stringBuilder = new StringBuilder ();  		foreach (char charChar in text.ToCharArray ()) {  			if (charChar == 11) {  				if (stringBuilder.Length > 0) {  					OutputCharacters (block' characterRun' stringBuilder.ToString ());  					stringBuilder.Length = 0;  				}  				ProcessLineBreak (block' characterRun);  			}  			else if (charChar == 30) {  				// Non-breaking hyphens are stored as ASCII 30  				stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  			}  			else if (charChar == 31) {  				// Non-required hyphens to zero-width space  				stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  			}  			else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  				stringBuilder.Append (charChar);  			}  		}  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  	}  	haveAnyText |= text.Trim ().Length != 0;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: foreach (char charChar in text.ToCharArray ()) {  	if (charChar == 11) {  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  		ProcessLineBreak (block' characterRun);  	}  	else if (charChar == 30) {  		// Non-breaking hyphens are stored as ASCII 30  		stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  	}  	else if (charChar == 31) {  		// Non-required hyphens to zero-width space  		stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  	}  	else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  		stringBuilder.Append (charChar);  	}  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: foreach (char charChar in text.ToCharArray ()) {  	if (charChar == 11) {  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  		ProcessLineBreak (block' characterRun);  	}  	else if (charChar == 30) {  		// Non-breaking hyphens are stored as ASCII 30  		stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  	}  	else if (charChar == 31) {  		// Non-required hyphens to zero-width space  		stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  	}  	else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  		stringBuilder.Append (charChar);  	}  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: foreach (char charChar in text.ToCharArray ()) {  	if (charChar == 11) {  		if (stringBuilder.Length > 0) {  			OutputCharacters (block' characterRun' stringBuilder.ToString ());  			stringBuilder.Length = 0;  		}  		ProcessLineBreak (block' characterRun);  	}  	else if (charChar == 30) {  		// Non-breaking hyphens are stored as ASCII 30  		stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  	}  	else if (charChar == 31) {  		// Non-required hyphens to zero-width space  		stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  	}  	else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  		stringBuilder.Append (charChar);  	}  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 11) {  	if (stringBuilder.Length > 0) {  		OutputCharacters (block' characterRun' stringBuilder.ToString ());  		stringBuilder.Length = 0;  	}  	ProcessLineBreak (block' characterRun);  }  else if (charChar == 30) {  	// Non-breaking hyphens are stored as ASCII 30  	stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  }  else if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 11) {  	if (stringBuilder.Length > 0) {  		OutputCharacters (block' characterRun' stringBuilder.ToString ());  		stringBuilder.Length = 0;  	}  	ProcessLineBreak (block' characterRun);  }  else if (charChar == 30) {  	// Non-breaking hyphens are stored as ASCII 30  	stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  }  else if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 11) {  	if (stringBuilder.Length > 0) {  		OutputCharacters (block' characterRun' stringBuilder.ToString ());  		stringBuilder.Length = 0;  	}  	ProcessLineBreak (block' characterRun);  }  else if (charChar == 30) {  	// Non-breaking hyphens are stored as ASCII 30  	stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  }  else if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 30) {  	// Non-breaking hyphens are stored as ASCII 30  	stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  }  else if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 30) {  	// Non-breaking hyphens are stored as ASCII 30  	stringBuilder.Append (UNICODECHAR_NONBREAKING_HYPHEN);  }  else if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessCharacters,The following statement contains a magic number: if (charChar == 31) {  	// Non-required hyphens to zero-width space  	stringBuilder.Append (UNICODECHAR_ZERO_WIDTH_SPACE);  }  else if (charChar >= 0x20 || charChar == 0x09 || charChar == 0x0A || charChar == 0x0D) {  	stringBuilder.Append (charChar);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type) {  case 37:// page reference   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex pagerefPattern = new Regex ("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		Match match = pagerefPattern.Match (formula);  		if (match.Success) {  			String pageref = match.Groups [1].Value;  			ProcessPageref (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' pageref);  			return;  		}  		//Pattern pagerefPattern = Pattern  		//        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		//Matcher matcher = pagerefPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String pageref = matcher.group(1);  		//    processPageref(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' pageref);  		//    return;  		//}  	}  	break;  }  case 58:// Embedded Object   {  	if (!field.HasSeparator ()) {  		logger.Log (POILogger.WARN' parentRange + " contains " + field + " with 'Embedded Object' but without separator mark");  		return;  	}  	CharacterRun separator = field.GetMarkSeparatorCharacterRun (parentRange);  	if (separator.IsOle2 ()) {  		// the only supported so far  		bool processed = ProcessOle2 (wordDocument' separator' currentBlock);  		// if we didn't output OLE - output field value  		if (!processed) {  			ProcessCharacters (wordDocument' currentTableLevel' field.SecondSubrange (parentRange)' currentBlock);  		}  		return;  	}  	break;  }  case 88:// hyperlink   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex hyperlinkPattern = new Regex ("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		Match match = hyperlinkPattern.Match (formula);  		if (match.Success) {  			String hyperlink = match.Groups [1].Value;  			ProcessHyperlink (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' hyperlink);  			return;  		}  		//Pattern hyperlinkPattern = Pattern  		//        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		//Matcher matcher = hyperlinkPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String hyperlink = matcher.group(1);  		//    processHyperlink(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' hyperlink);  		//    return;  		//}  	}  	break;  }  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type) {  case 37:// page reference   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex pagerefPattern = new Regex ("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		Match match = pagerefPattern.Match (formula);  		if (match.Success) {  			String pageref = match.Groups [1].Value;  			ProcessPageref (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' pageref);  			return;  		}  		//Pattern pagerefPattern = Pattern  		//        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		//Matcher matcher = pagerefPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String pageref = matcher.group(1);  		//    processPageref(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' pageref);  		//    return;  		//}  	}  	break;  }  case 58:// Embedded Object   {  	if (!field.HasSeparator ()) {  		logger.Log (POILogger.WARN' parentRange + " contains " + field + " with 'Embedded Object' but without separator mark");  		return;  	}  	CharacterRun separator = field.GetMarkSeparatorCharacterRun (parentRange);  	if (separator.IsOle2 ()) {  		// the only supported so far  		bool processed = ProcessOle2 (wordDocument' separator' currentBlock);  		// if we didn't output OLE - output field value  		if (!processed) {  			ProcessCharacters (wordDocument' currentTableLevel' field.SecondSubrange (parentRange)' currentBlock);  		}  		return;  	}  	break;  }  case 88:// hyperlink   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex hyperlinkPattern = new Regex ("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		Match match = hyperlinkPattern.Match (formula);  		if (match.Success) {  			String hyperlink = match.Groups [1].Value;  			ProcessHyperlink (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' hyperlink);  			return;  		}  		//Pattern hyperlinkPattern = Pattern  		//        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		//Matcher matcher = hyperlinkPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String hyperlink = matcher.group(1);  		//    processHyperlink(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' hyperlink);  		//    return;  		//}  	}  	break;  }  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following statement contains a magic number: switch (field.Type) {  case 37:// page reference   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex pagerefPattern = new Regex ("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		Match match = pagerefPattern.Match (formula);  		if (match.Success) {  			String pageref = match.Groups [1].Value;  			ProcessPageref (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' pageref);  			return;  		}  		//Pattern pagerefPattern = Pattern  		//        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		//Matcher matcher = pagerefPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String pageref = matcher.group(1);  		//    processPageref(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' pageref);  		//    return;  		//}  	}  	break;  }  case 58:// Embedded Object   {  	if (!field.HasSeparator ()) {  		logger.Log (POILogger.WARN' parentRange + " contains " + field + " with 'Embedded Object' but without separator mark");  		return;  	}  	CharacterRun separator = field.GetMarkSeparatorCharacterRun (parentRange);  	if (separator.IsOle2 ()) {  		// the only supported so far  		bool processed = ProcessOle2 (wordDocument' separator' currentBlock);  		// if we didn't output OLE - output field value  		if (!processed) {  			ProcessCharacters (wordDocument' currentTableLevel' field.SecondSubrange (parentRange)' currentBlock);  		}  		return;  	}  	break;  }  case 88:// hyperlink   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex hyperlinkPattern = new Regex ("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		Match match = hyperlinkPattern.Match (formula);  		if (match.Success) {  			String hyperlink = match.Groups [1].Value;  			ProcessHyperlink (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' hyperlink);  			return;  		}  		//Pattern hyperlinkPattern = Pattern  		//        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		//Matcher matcher = hyperlinkPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String hyperlink = matcher.group(1);  		//    processHyperlink(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' hyperlink);  		//    return;  		//}  	}  	break;  }  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderType,The following statement contains a magic number: switch (borderCode.BorderType) {  case 1:  case 2:  	return "solid";  case 3:  	return "double";  case 5:  	return "solid";  case 6:  	return "dotted";  case 7:  case 8:  	return "dashed";  case 9:  	return "dotted";  case 10:  case 11:  case 12:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  case 19:  	return "double";  case 20:  	return "solid";  case 21:  	return "double";  case 22:  	return "dashed";  case 23:  	return "dashed";  case 24:  	return "ridge";  case 25:  	return "grooved";  default:  	return "solid";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append (1000 / 8 * pte);  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBorderWidth,The following statement contains a magic number: stringBuilder.Append (1000 / 8 * pte);  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBulletText,The following statement contains a magic number: foreach (char element in xst) {  	if (element < 9)//todo:review_antony  	 {  		ListLevel numLevel = listTables.GetLevel (listId' element);  		int num = numLevel.GetStartAt ();  		bulletBuffer.Append (NumberFormatter.GetNumber (num' listLevel.GetNumberFormat ()));  		if (numLevel == listLevel) {  			numLevel.SetStartAt (numLevel.GetStartAt () + 1);  		}  	}  	else {  		bulletBuffer.Append (element);  	}  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetBulletText,The following statement contains a magic number: if (element < 9)//todo:review_antony   {  	ListLevel numLevel = listTables.GetLevel (listId' element);  	int num = numLevel.GetStartAt ();  	bulletBuffer.Append (NumberFormatter.GetNumber (num' listLevel.GetNumberFormat ()));  	if (numLevel == listLevel) {  		numLevel.SetStartAt (numLevel.GetStartAt () + 1);  	}  }  else {  	bulletBuffer.Append (element);  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor,The following statement contains a magic number: switch (ico) {  case 1:  	return "black";  case 2:  	return "blue";  case 3:  	return "cyan";  case 4:  	return "green";  case 5:  	return "magenta";  case 6:  	return "red";  case 7:  	return "yellow";  case 8:  	return "white";  case 9:  	return "darkblue";  case 10:  	return "darkcyan";  case 11:  	return "darkgreen";  case 12:  	return "darkmagenta";  case 13:  	return "darkred";  case 14:  	return "darkyellow";  case 15:  	return "darkgray";  case 16:  	return "lightgray";  default:  	return "black";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following statement contains a magic number: for (int i = hex.Length; i < 6; i++) {  	result.Append ('0');  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following statement contains a magic number: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode) {  case 1024:  	return string.Empty;  case 1033:  	return "en-us";  case 1049:  	return "ru-ru";  case 2057:  	return "en-uk";  default:  	logger.Log (POILogger.WARN' "Uknown or unmapped language code: "' languageCode);  	return string.Empty;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode) {  case 1024:  	return string.Empty;  case 1033:  	return "en-us";  case 1049:  	return "ru-ru";  case 2057:  	return "en-uk";  default:  	logger.Log (POILogger.WARN' "Uknown or unmapped language code: "' languageCode);  	return string.Empty;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode) {  case 1024:  	return string.Empty;  case 1033:  	return "en-us";  case 1049:  	return "ru-ru";  case 2057:  	return "en-uk";  default:  	logger.Log (POILogger.WARN' "Uknown or unmapped language code: "' languageCode);  	return string.Empty;  }  
Magic Number,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetLanguage,The following statement contains a magic number: switch (languageCode) {  case 1024:  	return string.Empty;  case 1033:  	return "en-us";  case 1049:  	return "ru-ru";  case 2057:  	return "en-uk";  default:  	logger.Log (POILogger.WARN' "Uknown or unmapped language code: "' languageCode);  	return string.Empty;  }  
Magic Number,NPOI.HWPF.Converter,WordToFoConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoConverter.cs,OutputCharacters,The following statement contains a magic number: WordToFoUtils.SetFontSize (inline' characterRun.GetFontSize () / 2);  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: if (characterRun.IsShadowed ()) {  	inline.SetAttribute ("text-shadow"' characterRun.GetFontSize () / 24 + "pt");  }  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: inline.SetAttribute ("text-shadow"' characterRun.GetFontSize () / 24 + "pt");  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetCharactersProperties,The following statement contains a magic number: if (characterRun.GetSubSuperScriptIndex () == 2) {  	inline.SetAttribute ("baseline-shift"' "sub");  	inline.SetAttribute ("font-size"' "smaller");  }  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: if (horizontalScale > 0) {  	graphicXmlElement.SetAttribute ("content-width"' ((picture.DxaGoal * horizontalScale / 1000) / TWIPS_PER_PT) + "pt");  }  else  	graphicXmlElement.SetAttribute ("content-width"' (picture.DxaGoal / TWIPS_PER_PT) + "pt");  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: graphicXmlElement.SetAttribute ("content-width"' ((picture.DxaGoal * horizontalScale / 1000) / TWIPS_PER_PT) + "pt");  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: if (verticalScale > 0)  	graphicXmlElement.SetAttribute ("content-height"' ((picture.DyaGoal * verticalScale / 1000) / TWIPS_PER_PT) + "pt");  else  	graphicXmlElement.SetAttribute ("content-height"' (picture.DyaGoal / TWIPS_PER_PT) + "pt");  
Magic Number,NPOI.HWPF.Converter,WordToFoUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToFoUtils.cs,SetPictureProperties,The following statement contains a magic number: graphicXmlElement.SetAttribute ("content-height"' ((picture.DyaGoal * verticalScale / 1000) / TWIPS_PER_PT) + "pt");  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: if (characterRun.GetFontSize () / 2 != blockProperies.pFontSize) {  	style.Append ("font-size:" + characterRun.GetFontSize () / 2 + "pt;");  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: if (characterRun.GetFontSize () / 2 != blockProperies.pFontSize) {  	style.Append ("font-size:" + characterRun.GetFontSize () / 2 + "pt;");  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,OutputCharacters,The following statement contains a magic number: style.Append ("font-size:" + characterRun.GetFontSize () / 2 + "pt;");  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0) {  	imageWidth = picture.DxaGoal * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0) {  	imageWidth = picture.DxaGoal * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioX > 0) {  	imageWidth = picture.DxaGoal * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageWidth = picture.DxaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropRight = picture.DxaCropRight / AbstractWordUtils.TWIPS_PER_INCH;  	cropLeft = picture.DxaCropLeft / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: imageWidth = picture.DxaGoal * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropRight = picture.DxaCropRight * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropLeft = picture.DxaCropLeft * aspectRatioX / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0) {  	imageHeight = picture.DyaGoal * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0) {  	imageHeight = picture.DyaGoal * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: if (aspectRatioY > 0) {  	imageHeight = picture.DyaGoal * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  }  else {  	imageHeight = picture.DyaGoal / AbstractWordUtils.TWIPS_PER_INCH;  	cropTop = picture.DyaCropTop / AbstractWordUtils.TWIPS_PER_INCH;  	cropBottom = picture.DyaCropBottom / AbstractWordUtils.TWIPS_PER_INCH;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: imageHeight = picture.DyaGoal * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropTop = picture.DyaCropTop * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessImage,The following statement contains a magic number: cropBottom = picture.DyaCropBottom * aspectRatioY / 1000 / AbstractWordUtils.TWIPS_PER_INCH;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The following statement contains a magic number: if (characterRun != null) {  	Triplet triplet = GetCharacterRunTriplet (characterRun);  	pFontSize = characterRun.GetFontSize () / 2;  	pFontName = triplet.fontName;  	WordToHtmlUtils.AddFontFamily (pFontName' style);  	WordToHtmlUtils.AddFontSize (pFontSize' style);  }  else {  	pFontSize = -1;  	pFontName = string.Empty;  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlConverter.cs,ProcessParagraph,The following statement contains a magic number: pFontSize = characterRun.GetFontSize () / 2;  
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddBorder,The following statement contains a magic number: if (borderCode.LineWidth < 8)  	style.Append ("thin");  else  	style.Append (GetBorderWidth (borderCode));  
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: if (characterRun.IsShadowed ()) {  	style.Append ("text-shadow:" + characterRun.GetFontSize () / 24 + "pt;");  }  
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: style.Append ("text-shadow:" + characterRun.GetFontSize () / 24 + "pt;");  
Magic Number,NPOI.HWPF.Converter,WordToHtmlUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\WordToHtmlUtils.cs,AddCharactersProperties,The following statement contains a magic number: if (characterRun.GetSubSuperScriptIndex () == 2) {  	style.Append ("vertical-align:sub;");  	style.Append ("font-size:smaller;");  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,HWPFDocument,The following statement contains a magic number: if (_fib.GetNFib () < 106) {  	throw new OldWordFileFormatException ("The document is too old - Word 95 or older. Try HWPFOldDocument instead?");  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (mainBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (mainBuf' 0' tempBuf' 0' mainBuf.Length);  	mainBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (mainBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (mainBuf' 0' tempBuf' 0' mainBuf.Length);  	mainBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (tableBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (tableBuf' 0' tempBuf' 0' tableBuf.Length);  	tableBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (tableBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (tableBuf' 0' tempBuf' 0' tableBuf.Length);  	tableBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf == null) {  	dataBuf = new byte[4096];  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: dataBuf = new byte[4096];  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (dataBuf' 0' tempBuf' 0' dataBuf.Length);  	dataBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocument.cs,Write,The following statement contains a magic number: if (dataBuf.Length < 4096) {  	byte[] tempBuf = new byte[4096];  	Array.Copy (dataBuf' 0' tempBuf' 0' dataBuf.Length);  	dataBuf = tempBuf;  }  
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Read (first6' 0' 6);  
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6 [0] == '{' && first6 [1] == '\\' && first6 [2] == 'r' && first6 [3] == 't' && first6 [4] == 'f') {  	throw new ArgumentException ("The document is really a RTF file");  }  
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6 [0] == '{' && first6 [1] == '\\' && first6 [2] == 'r' && first6 [3] == 't' && first6 [4] == 'f') {  	throw new ArgumentException ("The document is really a RTF file");  }  
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: if (first6 [0] == '{' && first6 [1] == '\\' && first6 [2] == 'r' && first6 [3] == 't' && first6 [4] == 'f') {  	throw new ArgumentException ("The document is really a RTF file");  }  
Magic Number,NPOI.HWPF,HWPFDocumentCore,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFDocumentCore.cs,VerifyAndBuildPOIFS,The following statement contains a magic number: pis.Unread (6);  
Magic Number,NPOI.HWPF,HWPFOldDocument,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\HWPFOldDocument.cs,HWPFOldDocument,The following statement contains a magic number: if (_fib.IsFComplex ()) {  	ComplexFileTable cft = new ComplexFileTable (_mainStream' _mainStream' complexTableOffset' _fib.GetFcMin ());  	tpt = cft.GetTextPieceTable ();  	foreach (TextPiece tp in tpt.TextPieces) {  		text.Append (tp.GetStringBuilder ());  	}  }  else {  	// TODO Discover if these older documents can ever hold Unicode Strings?  	//  (We think not' because they seem to lack a Piece table)  	// TODO Build the Piece Descriptor properly  	//  (We have to fake it' as they don't seem to have a proper Piece table)  	PieceDescriptor pd = new PieceDescriptor (new byte[] {  		0'  		0'  		0'  		0'  		0'  		127'  		0'  		0  	}' 0);  	pd.FilePosition = _fib.GetFcMin ();  	// Generate a single Text Piece Table' with a single Text Piece  	//  which covers all the (8 bit only) text in the file  	tpt = new TextPieceTable ();  	byte[] textData = new byte[_fib.GetFcMac () - _fib.GetFcMin ()];  	Array.Copy (_mainStream' _fib.GetFcMin ()' textData' 0' textData.Length);  	TextPiece tp = new TextPiece (0' textData.Length' textData' pd);  	tpt.Add (tp);  	text.Append (tp.GetStringBuilder ());  }  
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Insert,The following statement contains a magic number: if (listIndex == _textRuns.Count) {  	_textRuns.Add (insertChpx);  }  else {  	CHPX chpx = _textRuns [listIndex];  	if (chpx.Start < cpStart) {  		// Copy the properties of the one before to afterwards  		// Will go:  		//  Original' until insert at point  		//  New one  		//  Clone of original' on to the old end  		CHPX clone = new CHPX (0' 0' chpx.GetSprmBuf ());  		// Again ensure Contains character based OffSets no matter what  		clone.Start = (cpStart);  		clone.End = (chpx.End);  		chpx.End = (cpStart);  		_textRuns.Insert (listIndex + 1' insertChpx);  		_textRuns.Insert (listIndex + 2' clone);  	}  	else {  		_textRuns.Insert (listIndex' insertChpx);  	}  }  
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Insert,The following statement contains a magic number: if (chpx.Start < cpStart) {  	// Copy the properties of the one before to afterwards  	// Will go:  	//  Original' until insert at point  	//  New one  	//  Clone of original' on to the old end  	CHPX clone = new CHPX (0' 0' chpx.GetSprmBuf ());  	// Again ensure Contains character based OffSets no matter what  	clone.Start = (cpStart);  	clone.End = (chpx.End);  	chpx.End = (cpStart);  	_textRuns.Insert (listIndex + 1' insertChpx);  	_textRuns.Insert (listIndex + 2' clone);  }  else {  	_textRuns.Insert (listIndex' insertChpx);  }  
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,Insert,The following statement contains a magic number: _textRuns.Insert (listIndex + 2' clone);  
Magic Number,NPOI.HWPF.Model,CHPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPBinTable.cs,WriteTo,The following statement contains a magic number: do {  	PropertyNode startingProp = (PropertyNode)overflow [0];  	int start = startingProp.Start + fcMin;  	CHPFormattedDiskPage cfkp = new CHPFormattedDiskPage ();  	cfkp.Fill (overflow);  	byte[] bufFkp = cfkp.ToArray (fcMin);  	docStream.Write (bufFkp);  	overflow = cfkp.GetOverflow ();  	int end = endingFc;  	if (overflow != null) {  		end = ((PropertyNode)overflow [0]).Start + fcMin;  	}  	byte[] intHolder = new byte[4];  	LittleEndian.PutInt (intHolder' pageNum++);  	binTable.AddProperty (new GenericPropertyNode (start' end' intHolder));  }  while (overflow != null);  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++) {  	int grpprlLength = (_chpxList [index]).GetGrpprl ().Length;  	// check to see if we have enough room for an FC' the grpprl offset'  	// the grpprl size byte and the grpprl.  	totalSize += (FC_SIZE + 2 + grpprlLength);  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= (FC_SIZE + 2 + grpprlLength);  		break;  	}  	// grpprls must fall on word boundaries  	if ((1 + grpprlLength) % 2 > 0) {  		totalSize += 1;  	}  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++) {  	int grpprlLength = (_chpxList [index]).GetGrpprl ().Length;  	// check to see if we have enough room for an FC' the grpprl offset'  	// the grpprl size byte and the grpprl.  	totalSize += (FC_SIZE + 2 + grpprlLength);  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= (FC_SIZE + 2 + grpprlLength);  		break;  	}  	// grpprls must fall on word boundaries  	if ((1 + grpprlLength) % 2 > 0) {  		totalSize += 1;  	}  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++) {  	int grpprlLength = (_chpxList [index]).GetGrpprl ().Length;  	// check to see if we have enough room for an FC' the grpprl offset'  	// the grpprl size byte and the grpprl.  	totalSize += (FC_SIZE + 2 + grpprlLength);  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= (FC_SIZE + 2 + grpprlLength);  		break;  	}  	// grpprls must fall on word boundaries  	if ((1 + grpprlLength) % 2 > 0) {  		totalSize += 1;  	}  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++) {  	int grpprlLength = (_chpxList [index]).GetGrpprl ().Length;  	// check to see if we have enough room for an FC' the grpprl offset'  	// the grpprl size byte and the grpprl.  	totalSize += (FC_SIZE + 2 + grpprlLength);  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= (FC_SIZE + 2 + grpprlLength);  		break;  	}  	// grpprls must fall on word boundaries  	if ((1 + grpprlLength) % 2 > 0) {  		totalSize += 1;  	}  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (; index < size; index++) {  	int grpprlLength = (_chpxList [index]).GetGrpprl ().Length;  	// check to see if we have enough room for an FC' the grpprl offset'  	// the grpprl size byte and the grpprl.  	totalSize += (FC_SIZE + 2 + grpprlLength);  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= (FC_SIZE + 2 + grpprlLength);  		break;  	}  	// grpprls must fall on word boundaries  	if ((1 + grpprlLength) % 2 > 0) {  		totalSize += 1;  	}  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize += (FC_SIZE + 2 + grpprlLength);  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: if (totalSize > 511 + (index % 2)) {  	totalSize -= (FC_SIZE + 2 + grpprlLength);  	break;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: if (totalSize > 511 + (index % 2)) {  	totalSize -= (FC_SIZE + 2 + grpprlLength);  	break;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: if (totalSize > 511 + (index % 2)) {  	totalSize -= (FC_SIZE + 2 + grpprlLength);  	break;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: totalSize -= (FC_SIZE + 2 + grpprlLength);  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: if ((1 + grpprlLength) % 2 > 0) {  	totalSize += 1;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: buf [511] = (byte)index;  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	chpx = (CHPX)_chpxList [x];  	byte[] grpprl = chpx.GetGrpprl ();  	LittleEndian.PutInt (buf' fcOffset' chpx.StartBytes + fcMin);  	grpprlOffset -= (1 + grpprl.Length);  	grpprlOffset -= (grpprlOffset % 2);  	buf [offsetOffset] = (byte)(grpprlOffset / 2);  	buf [grpprlOffset] = (byte)grpprl.Length;  	Array.Copy (grpprl' 0' buf' grpprlOffset + 1' grpprl.Length);  	offsetOffset += 1;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	chpx = (CHPX)_chpxList [x];  	byte[] grpprl = chpx.GetGrpprl ();  	LittleEndian.PutInt (buf' fcOffset' chpx.StartBytes + fcMin);  	grpprlOffset -= (1 + grpprl.Length);  	grpprlOffset -= (grpprlOffset % 2);  	buf [offsetOffset] = (byte)(grpprlOffset / 2);  	buf [grpprlOffset] = (byte)grpprl.Length;  	Array.Copy (grpprl' 0' buf' grpprlOffset + 1' grpprl.Length);  	offsetOffset += 1;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: grpprlOffset -= (grpprlOffset % 2);  
Magic Number,NPOI.HWPF.Model,CHPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\CHPFormattedDiskPage.cs,ToArray,The following statement contains a magic number: buf [offsetOffset] = (byte)(grpprlOffset / 2);  
Magic Number,NPOI.HWPF.Model,PictureDescriptor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PictureDescriptor.cs,PictureDescriptor,The following statement contains a magic number: this.offset14 = LittleEndian.GetByteArray (_dataStream' startOffset + 0x0E' 14);  
Magic Number,NPOI.HWPF.Model,Ffn,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Ffn.cs,Ffn,The following statement contains a magic number: _xszFfnLength = (this.GetSize () - offsetTmp) / 2;  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields = new int[numFields * 2];  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: for (int x = 0; x < numFields; x++) {  	int fieldOffset = (x * FIELD_SIZE) + offset;  	int dsOffset = LittleEndian.GetInt (mainStream' fieldOffset);  	fieldOffset += LittleEndianConsts.INT_SIZE;  	int dsSize = LittleEndian.GetInt (mainStream' fieldOffset);  	if (offsetList.Contains (x) ^ areKnown) {  		if (dsSize > 0) {  			if (dsOffset + dsSize > tableStream.Length) {  				//log.log(POILogger.WARN' "Unhandled data structure points to outside the buffer. " +  				//                        "offset = " + dsOffset + "' length = " + dsSize +  				//                        "' buffer length = " + tableStream.Length);  			}  			else {  				UnhandledDataStructure unhandled = new UnhandledDataStructure (tableStream' dsOffset' dsSize);  				_unknownMap.Add (x' unhandled);  			}  		}  	}  	_fields [x * 2] = dsOffset;  	_fields [(x * 2) + 1] = dsSize;  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: for (int x = 0; x < numFields; x++) {  	int fieldOffset = (x * FIELD_SIZE) + offset;  	int dsOffset = LittleEndian.GetInt (mainStream' fieldOffset);  	fieldOffset += LittleEndianConsts.INT_SIZE;  	int dsSize = LittleEndian.GetInt (mainStream' fieldOffset);  	if (offsetList.Contains (x) ^ areKnown) {  		if (dsSize > 0) {  			if (dsOffset + dsSize > tableStream.Length) {  				//log.log(POILogger.WARN' "Unhandled data structure points to outside the buffer. " +  				//                        "offset = " + dsOffset + "' length = " + dsSize +  				//                        "' buffer length = " + tableStream.Length);  			}  			else {  				UnhandledDataStructure unhandled = new UnhandledDataStructure (tableStream' dsOffset' dsSize);  				_unknownMap.Add (x' unhandled);  			}  		}  	}  	_fields [x * 2] = dsOffset;  	_fields [(x * 2) + 1] = dsSize;  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields [x * 2] = dsOffset;  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,FIBFieldHandler,The following statement contains a magic number: _fields [(x * 2) + 1] = dsSize;  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldOffset,The following statement contains a magic number: return _fields [field * 2];  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,GetFieldSize,The following statement contains a magic number: return _fields [(field * 2) + 1];  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldOffset,The following statement contains a magic number: _fields [field * 2] = offset;  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,SetFieldSize,The following statement contains a magic number: _fields [(field * 2) + 1] = size;  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < length; x++) {  	UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap [x];  	if (ds != null) {  		LittleEndian.PutInt (mainStream' offset' tableStream.Offset);  		offset += LittleEndianConsts.INT_SIZE;  		byte[] buf = ds.GetBuf ();  		tableStream.Write (buf);  		LittleEndian.PutInt (mainStream' offset' buf.Length);  		offset += LittleEndianConsts.INT_SIZE;  	}  	else {  		LittleEndian.PutInt (mainStream' offset' _fields [x * 2]);  		offset += LittleEndianConsts.INT_SIZE;  		LittleEndian.PutInt (mainStream' offset' _fields [(x * 2) + 1]);  		offset += LittleEndianConsts.INT_SIZE;  	}  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < length; x++) {  	UnhandledDataStructure ds = (UnhandledDataStructure)_unknownMap [x];  	if (ds != null) {  		LittleEndian.PutInt (mainStream' offset' tableStream.Offset);  		offset += LittleEndianConsts.INT_SIZE;  		byte[] buf = ds.GetBuf ();  		tableStream.Write (buf);  		LittleEndian.PutInt (mainStream' offset' buf.Length);  		offset += LittleEndianConsts.INT_SIZE;  	}  	else {  		LittleEndian.PutInt (mainStream' offset' _fields [x * 2]);  		offset += LittleEndianConsts.INT_SIZE;  		LittleEndian.PutInt (mainStream' offset' _fields [(x * 2) + 1]);  		offset += LittleEndianConsts.INT_SIZE;  	}  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: if (ds != null) {  	LittleEndian.PutInt (mainStream' offset' tableStream.Offset);  	offset += LittleEndianConsts.INT_SIZE;  	byte[] buf = ds.GetBuf ();  	tableStream.Write (buf);  	LittleEndian.PutInt (mainStream' offset' buf.Length);  	offset += LittleEndianConsts.INT_SIZE;  }  else {  	LittleEndian.PutInt (mainStream' offset' _fields [x * 2]);  	offset += LittleEndianConsts.INT_SIZE;  	LittleEndian.PutInt (mainStream' offset' _fields [(x * 2) + 1]);  	offset += LittleEndianConsts.INT_SIZE;  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: if (ds != null) {  	LittleEndian.PutInt (mainStream' offset' tableStream.Offset);  	offset += LittleEndianConsts.INT_SIZE;  	byte[] buf = ds.GetBuf ();  	tableStream.Write (buf);  	LittleEndian.PutInt (mainStream' offset' buf.Length);  	offset += LittleEndianConsts.INT_SIZE;  }  else {  	LittleEndian.PutInt (mainStream' offset' _fields [x * 2]);  	offset += LittleEndianConsts.INT_SIZE;  	LittleEndian.PutInt (mainStream' offset' _fields [(x * 2) + 1]);  	offset += LittleEndianConsts.INT_SIZE;  }  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt (mainStream' offset' _fields [x * 2]);  
Magic Number,NPOI.HWPF.Model,FIBFieldHandler,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FIBFieldHandler.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt (mainStream' offset' _fields [(x * 2) + 1]);  
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FormattedDiskPage.cs,FormattedDiskPage,The following statement contains a magic number: _crun = LittleEndian.GetUByte (documentStream' offset + 511);  
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetStart,The following statement contains a magic number: return LittleEndian.GetInt (_fkp' _offset + (index * 4));  
Magic Number,NPOI.HWPF.Model,FormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\FormattedDiskPage.cs,GetEnd,The following statement contains a magic number: return LittleEndian.GetInt (_fkp' _offset + ((index + 1) * 4));  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: for (int x = 0; x < 9; x++) {  	_rgistd [x] = (short)StyleSheet.NIL_STYLE;  }  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _levels = new ListLevel[9];  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _rgistd = new short[9];  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: for (int x = 0; x < 9; x++) {  	_rgistd [x] = LittleEndian.GetShort (buf' offset);  	offset += LittleEndianConsts.SHORT_SIZE;  }  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: if (_fSimpleList.GetValue (_info) > 0) {  	_levels = new ListLevel[1];  }  else {  	_levels = new ListLevel[9];  }  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ListData,The following statement contains a magic number: _levels = new ListLevel[9];  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random ((int)DateTime.Now.Ticks)).Next (0' 100) / 100 * DateTime.Now.Millisecond);  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ResetListID,The following statement contains a magic number: _lsid = (int)((new Random ((int)DateTime.Now.Ticks)).Next (0' 100) / 100 * DateTime.Now.Millisecond);  
Magic Number,NPOI.HWPF.Model,ListData,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListData.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < 9; x++) {  	LittleEndian.PutShort (buf' offset' _rgistd [x]);  	offset += LittleEndianConsts.SHORT_SIZE;  }  
Magic Number,NPOI.HWPF.Model,ListFormatOverride,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListFormatOverride.cs,ToArray,The following statement contains a magic number: Array.Copy (_reserved3' 0' buf' offset' 3);  
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: Array.Copy (_reserved' 0' buf' offset' 3);  
Magic Number,NPOI.HWPF.Model,ListFormatOverrideLevel,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListFormatOverrideLevel.cs,ToArray,The following statement contains a magic number: offset += 3;  
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListTables.cs,ListTables,The following statement contains a magic number: for (int x = 0; x < length; x++) {  	ListFormatOverride lfo = new ListFormatOverride (tableStream' lfoOffset);  	lfoOffset += LIST_FORMAT_OVERRIDE_SIZE;  	int num = lfo.numOverrides ();  	for (int y = 0; y < num; y++) {  		while (tableStream [lfolvlOffset] == 255) {  			lfolvlOffset++;  		}  		ListFormatOverrideLevel lfolvl = new ListFormatOverrideLevel (tableStream' lfolvlOffset);  		lfo.SetOverride (y' lfolvl);  		lfolvlOffset += lfolvl.GetSizeInBytes ();  	}  	_overrideList.Add (lfo);  }  
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListTables.cs,ListTables,The following statement contains a magic number: for (int y = 0; y < num; y++) {  	while (tableStream [lfolvlOffset] == 255) {  		lfolvlOffset++;  	}  	ListFormatOverrideLevel lfolvl = new ListFormatOverrideLevel (tableStream' lfolvlOffset);  	lfo.SetOverride (y' lfolvl);  	lfolvlOffset += lfolvl.GetSizeInBytes ();  }  
Magic Number,NPOI.HWPF.Model,ListTables,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\ListTables.cs,ListTables,The following statement contains a magic number: while (tableStream [lfolvlOffset] == 255) {  	lfolvlOffset++;  }  
Magic Number,NPOI.HWPF.Model,OldSectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The following statement contains a magic number: for (int x = 0; x < length; x++) {  	GenericPropertyNode node = sedPlex.GetProperty (x);  	SectionDescriptor sed = new SectionDescriptor (node.Bytes' 0);  	int fileOffset = sed.GetFc ();  	int startAt = node.Start;  	int endAt = node.End;  	SEPX sepx;  	// check for the optimization  	if (fileOffset == unchecked((int)0xffffffff)) {  		sepx = new SEPX (sed' startAt' endAt' new byte[0]);  	}  	else {  		// The first short at the offset is the size of the grpprl.  		int sepxSize = LittleEndian.GetShort (documentStream' fileOffset);  		// Because we don't properly know about all the details of the old  		//  section properties' and we're trying to decode them as if they  		//  were the new ones' we sometimes "need" more data than we have.  		// As a workaround' have a few extra 0 bytes on the end!  		byte[] buf = new byte[sepxSize + 2];  		fileOffset += LittleEndianConsts.SHORT_SIZE;  		Array.Copy (documentStream' fileOffset' buf' 0' buf.Length);  		sepx = new SEPX (sed' startAt' endAt' buf);  	}  	_sections.Add (sepx);  }  
Magic Number,NPOI.HWPF.Model,OldSectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\OldSectionTable.cs,OldSectionTable,The following statement contains a magic number: if (fileOffset == unchecked((int)0xffffffff)) {  	sepx = new SEPX (sed' startAt' endAt' new byte[0]);  }  else {  	// The first short at the offset is the size of the grpprl.  	int sepxSize = LittleEndian.GetShort (documentStream' fileOffset);  	// Because we don't properly know about all the details of the old  	//  section properties' and we're trying to decode them as if they  	//  were the new ones' we sometimes "need" more data than we have.  	// As a workaround' have a few extra 0 bytes on the end!  	byte[] buf = new byte[sepxSize + 2];  	fileOffset += LittleEndianConsts.SHORT_SIZE;  	Array.Copy (documentStream' fileOffset' buf' 0' buf.Length);  	sepx = new SEPX (sed' startAt' endAt' buf);  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Insert,The following statement contains a magic number: if (listIndex == _paragraphs.Count) {  	_paragraphs.Add (forInsert);  }  else {  	PAPX currentPap = _paragraphs [listIndex];  	if (currentPap != null && currentPap.Start < cpStart) {  		SprmBuffer ClonedBuf = null;  		ClonedBuf = (SprmBuffer)currentPap.GetSprmBuf ().Clone ();  		// Copy the properties of the one before to afterwards  		// Will go:  		//  Original' until insert at point  		//  New one  		//  Clone of original' on to the old end  		PAPX clone = new PAPX (0' 0' ClonedBuf);  		// Again ensure Contains character based OffSets no matter what  		clone.Start = (cpStart);  		clone.End = (currentPap.End);  		currentPap.End = cpStart;  		_paragraphs.Insert (listIndex + 1' forInsert);  		_paragraphs.Insert (listIndex + 2' clone);  	}  	else {  		_paragraphs.Insert (listIndex' forInsert);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Insert,The following statement contains a magic number: if (currentPap != null && currentPap.Start < cpStart) {  	SprmBuffer ClonedBuf = null;  	ClonedBuf = (SprmBuffer)currentPap.GetSprmBuf ().Clone ();  	// Copy the properties of the one before to afterwards  	// Will go:  	//  Original' until insert at point  	//  New one  	//  Clone of original' on to the old end  	PAPX clone = new PAPX (0' 0' ClonedBuf);  	// Again ensure Contains character based OffSets no matter what  	clone.Start = (cpStart);  	clone.End = (currentPap.End);  	currentPap.End = cpStart;  	_paragraphs.Insert (listIndex + 1' forInsert);  	_paragraphs.Insert (listIndex + 2' clone);  }  else {  	_paragraphs.Insert (listIndex' forInsert);  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Insert,The following statement contains a magic number: _paragraphs.Insert (listIndex + 2' clone);  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (complexFileTable != null) {  	SprmBuffer[] sprmBuffers = complexFileTable.GetGrpprls ();  	// adding PAPX from fast-saved SPRMs  	foreach (TextPiece textPiece in complexFileTable.GetTextPieceTable ().TextPieces) {  		PropertyModifier prm = textPiece.PieceDescriptor.Prm;  		if (!prm.IsComplex ())  			continue;  		int igrpprl = prm.GetIgrpprl ();  		if (igrpprl < 0 || igrpprl >= sprmBuffers.Length) {  			logger.Log (POILogger.WARN' textPiece + "'s PRM references to unknown grpprl");  			continue;  		}  		bool hasPap = false;  		SprmBuffer sprmBuffer = sprmBuffers [igrpprl];  		for (SprmIterator iterator = sprmBuffer.Iterator (); iterator.HasNext ();) {  			SprmOperation sprmOperation = iterator.Next ();  			if (sprmOperation.Type == SprmOperation.TYPE_PAP) {  				hasPap = true;  				break;  			}  		}  		if (hasPap) {  			SprmBuffer newSprmBuffer = new SprmBuffer (2);  			newSprmBuffer.Append (sprmBuffer.ToByteArray ());  			PAPX papx = new PAPX (textPiece.Start' textPiece.End' newSprmBuffer);  			_paragraphs.Add (papx);  		}  	}  	logger.Log (POILogger.DEBUG' "Merged (?) with PAPX from complex file table in "' DateTime.Now.Ticks - start' " ms ("' _paragraphs.Count' " elements in total)");  	start = DateTime.Now.Ticks;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: foreach (TextPiece textPiece in complexFileTable.GetTextPieceTable ().TextPieces) {  	PropertyModifier prm = textPiece.PieceDescriptor.Prm;  	if (!prm.IsComplex ())  		continue;  	int igrpprl = prm.GetIgrpprl ();  	if (igrpprl < 0 || igrpprl >= sprmBuffers.Length) {  		logger.Log (POILogger.WARN' textPiece + "'s PRM references to unknown grpprl");  		continue;  	}  	bool hasPap = false;  	SprmBuffer sprmBuffer = sprmBuffers [igrpprl];  	for (SprmIterator iterator = sprmBuffer.Iterator (); iterator.HasNext ();) {  		SprmOperation sprmOperation = iterator.Next ();  		if (sprmOperation.Type == SprmOperation.TYPE_PAP) {  			hasPap = true;  			break;  		}  	}  	if (hasPap) {  		SprmBuffer newSprmBuffer = new SprmBuffer (2);  		newSprmBuffer.Append (sprmBuffer.ToByteArray ());  		PAPX papx = new PAPX (textPiece.Start' textPiece.End' newSprmBuffer);  		_paragraphs.Add (papx);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (hasPap) {  	SprmBuffer newSprmBuffer = new SprmBuffer (2);  	newSprmBuffer.Append (sprmBuffer.ToByteArray ());  	PAPX papx = new PAPX (textPiece.Start' textPiece.End' newSprmBuffer);  	_paragraphs.Add (papx);  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++) {  	char c = docText [charIndex];  	if (c != 13 && c != 7 && c != 12)  		continue;  	int startInclusive = lastParStart;  	int endExclusive = charIndex + 1;  	bool broken = false;  	List<PAPX> papxs = new List<PAPX> ();  	for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos.Count; papxIndex++) {  		broken = false;  		PAPX papx = oldPapxSortedByEndPos [papxIndex];  		if (papx.End - 1 > charIndex) {  			lastPapxIndex = papxIndex;  			broken = true;  			break;  		}  		papxs.Add (papx);  	}  	if (!broken) {  		lastPapxIndex = oldPapxSortedByEndPos.Count - 1;  	}  	if (papxs.Count == 0) {  		logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  		// create it manually  		PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  		newPapxs.Add (papx);  		lastParStart = endExclusive;  		continue;  	}  	if (papxs.Count == 1) {  		// can we reuse existing?  		PAPX existing = papxs [0];  		if (existing.Start == startInclusive && existing.End == endExclusive) {  			newPapxs.Add (existing);  			lastParStart = endExclusive;  			continue;  		}  	}  	PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer (papxToFileOrder);  	// restore file order of PAPX  	papxs.Sort (papxFileOrderComparator);  	SprmBuffer sprmBuffer = null;  	foreach (PAPX papx in papxs) {  		if (sprmBuffer == null)  			sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  		else  			sprmBuffer.Append (papx.GetGrpprl ()' 2);  	}  	PAPX newPapx = new PAPX (startInclusive' endExclusive' sprmBuffer);  	newPapxs.Add (newPapx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++) {  	char c = docText [charIndex];  	if (c != 13 && c != 7 && c != 12)  		continue;  	int startInclusive = lastParStart;  	int endExclusive = charIndex + 1;  	bool broken = false;  	List<PAPX> papxs = new List<PAPX> ();  	for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos.Count; papxIndex++) {  		broken = false;  		PAPX papx = oldPapxSortedByEndPos [papxIndex];  		if (papx.End - 1 > charIndex) {  			lastPapxIndex = papxIndex;  			broken = true;  			break;  		}  		papxs.Add (papx);  	}  	if (!broken) {  		lastPapxIndex = oldPapxSortedByEndPos.Count - 1;  	}  	if (papxs.Count == 0) {  		logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  		// create it manually  		PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  		newPapxs.Add (papx);  		lastParStart = endExclusive;  		continue;  	}  	if (papxs.Count == 1) {  		// can we reuse existing?  		PAPX existing = papxs [0];  		if (existing.Start == startInclusive && existing.End == endExclusive) {  			newPapxs.Add (existing);  			lastParStart = endExclusive;  			continue;  		}  	}  	PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer (papxToFileOrder);  	// restore file order of PAPX  	papxs.Sort (papxFileOrderComparator);  	SprmBuffer sprmBuffer = null;  	foreach (PAPX papx in papxs) {  		if (sprmBuffer == null)  			sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  		else  			sprmBuffer.Append (papx.GetGrpprl ()' 2);  	}  	PAPX newPapx = new PAPX (startInclusive' endExclusive' sprmBuffer);  	newPapxs.Add (newPapx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++) {  	char c = docText [charIndex];  	if (c != 13 && c != 7 && c != 12)  		continue;  	int startInclusive = lastParStart;  	int endExclusive = charIndex + 1;  	bool broken = false;  	List<PAPX> papxs = new List<PAPX> ();  	for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos.Count; papxIndex++) {  		broken = false;  		PAPX papx = oldPapxSortedByEndPos [papxIndex];  		if (papx.End - 1 > charIndex) {  			lastPapxIndex = papxIndex;  			broken = true;  			break;  		}  		papxs.Add (papx);  	}  	if (!broken) {  		lastPapxIndex = oldPapxSortedByEndPos.Count - 1;  	}  	if (papxs.Count == 0) {  		logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  		// create it manually  		PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  		newPapxs.Add (papx);  		lastParStart = endExclusive;  		continue;  	}  	if (papxs.Count == 1) {  		// can we reuse existing?  		PAPX existing = papxs [0];  		if (existing.Start == startInclusive && existing.End == endExclusive) {  			newPapxs.Add (existing);  			lastParStart = endExclusive;  			continue;  		}  	}  	PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer (papxToFileOrder);  	// restore file order of PAPX  	papxs.Sort (papxFileOrderComparator);  	SprmBuffer sprmBuffer = null;  	foreach (PAPX papx in papxs) {  		if (sprmBuffer == null)  			sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  		else  			sprmBuffer.Append (papx.GetGrpprl ()' 2);  	}  	PAPX newPapx = new PAPX (startInclusive' endExclusive' sprmBuffer);  	newPapxs.Add (newPapx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++) {  	char c = docText [charIndex];  	if (c != 13 && c != 7 && c != 12)  		continue;  	int startInclusive = lastParStart;  	int endExclusive = charIndex + 1;  	bool broken = false;  	List<PAPX> papxs = new List<PAPX> ();  	for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos.Count; papxIndex++) {  		broken = false;  		PAPX papx = oldPapxSortedByEndPos [papxIndex];  		if (papx.End - 1 > charIndex) {  			lastPapxIndex = papxIndex;  			broken = true;  			break;  		}  		papxs.Add (papx);  	}  	if (!broken) {  		lastPapxIndex = oldPapxSortedByEndPos.Count - 1;  	}  	if (papxs.Count == 0) {  		logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  		// create it manually  		PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  		newPapxs.Add (papx);  		lastParStart = endExclusive;  		continue;  	}  	if (papxs.Count == 1) {  		// can we reuse existing?  		PAPX existing = papxs [0];  		if (existing.Start == startInclusive && existing.End == endExclusive) {  			newPapxs.Add (existing);  			lastParStart = endExclusive;  			continue;  		}  	}  	PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer (papxToFileOrder);  	// restore file order of PAPX  	papxs.Sort (papxFileOrderComparator);  	SprmBuffer sprmBuffer = null;  	foreach (PAPX papx in papxs) {  		if (sprmBuffer == null)  			sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  		else  			sprmBuffer.Append (papx.GetGrpprl ()' 2);  	}  	PAPX newPapx = new PAPX (startInclusive' endExclusive' sprmBuffer);  	newPapxs.Add (newPapx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: for (int charIndex = 0; charIndex < docText.Length; charIndex++) {  	char c = docText [charIndex];  	if (c != 13 && c != 7 && c != 12)  		continue;  	int startInclusive = lastParStart;  	int endExclusive = charIndex + 1;  	bool broken = false;  	List<PAPX> papxs = new List<PAPX> ();  	for (int papxIndex = lastPapxIndex; papxIndex < oldPapxSortedByEndPos.Count; papxIndex++) {  		broken = false;  		PAPX papx = oldPapxSortedByEndPos [papxIndex];  		if (papx.End - 1 > charIndex) {  			lastPapxIndex = papxIndex;  			broken = true;  			break;  		}  		papxs.Add (papx);  	}  	if (!broken) {  		lastPapxIndex = oldPapxSortedByEndPos.Count - 1;  	}  	if (papxs.Count == 0) {  		logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  		// create it manually  		PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  		newPapxs.Add (papx);  		lastParStart = endExclusive;  		continue;  	}  	if (papxs.Count == 1) {  		// can we reuse existing?  		PAPX existing = papxs [0];  		if (existing.Start == startInclusive && existing.End == endExclusive) {  			newPapxs.Add (existing);  			lastParStart = endExclusive;  			continue;  		}  	}  	PAPXToFileComparer papxFileOrderComparator = new PAPXToFileComparer (papxToFileOrder);  	// restore file order of PAPX  	papxs.Sort (papxFileOrderComparator);  	SprmBuffer sprmBuffer = null;  	foreach (PAPX papx in papxs) {  		if (sprmBuffer == null)  			sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  		else  			sprmBuffer.Append (papx.GetGrpprl ()' 2);  	}  	PAPX newPapx = new PAPX (startInclusive' endExclusive' sprmBuffer);  	newPapxs.Add (newPapx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (c != 13 && c != 7 && c != 12)  	continue;  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (c != 13 && c != 7 && c != 12)  	continue;  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (c != 13 && c != 7 && c != 12)  	continue;  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (papxs.Count == 0) {  	logger.Log (POILogger.WARN' "Paragraph ["' startInclusive' "; "' endExclusive' ") has no PAPX. Creating new one.");  	// create it manually  	PAPX papx = new PAPX (startInclusive' endExclusive' new SprmBuffer (2));  	newPapxs.Add (papx);  	lastParStart = endExclusive;  	continue;  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: foreach (PAPX papx in papxs) {  	if (sprmBuffer == null)  		sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  	else  		sprmBuffer.Append (papx.GetGrpprl ()' 2);  }  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: if (sprmBuffer == null)  	sprmBuffer = (SprmBuffer)papx.GetSprmBuf ().Clone ();  else  	sprmBuffer.Append (papx.GetGrpprl ()' 2);  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,Rebuild,The following statement contains a magic number: sprmBuffer.Append (papx.GetGrpprl ()' 2);  
Magic Number,NPOI.HWPF.Model,PAPBinTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPBinTable.cs,WriteTo,The following statement contains a magic number: do {  	PropertyNode startingProp = (PropertyNode)overflow [0];  	int start = translator.GetByteIndex (startingProp.Start);  	PAPFormattedDiskPage pfkp = new PAPFormattedDiskPage (_dataStream);  	pfkp.Fill (overflow);  	byte[] bufFkp = pfkp.ToByteArray (tableStream' translator);  	docStream.Write (bufFkp);  	overflow = pfkp.GetOverflow ();  	int end = endingFc;  	if (overflow != null) {  		end = translator.GetByteIndex (overflow [0].Start);  	}  	byte[] intHolder = new byte[4];  	LittleEndian.PutInt (intHolder' pageNum++);  	binTable.AddProperty (new GenericPropertyNode (start' end' intHolder));  }  while (overflow != null);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: if (size == 0) {  	size = 2 * LittleEndian.GetUByte (_fkp' _offset + ++papxOffset);  }  else {  	size--;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,GetGrpprl,The following statement contains a magic number: size = 2 * LittleEndian.GetUByte (_fkp' _offset + ++papxOffset);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (; index < size; index++) {  	byte[] grpprl = ((PAPX)_papxList [index]).GetGrpprl ();  	int grpprlLength = grpprl.Length;  	// is grpprl huge?  	if (grpprlLength > 488) {  		grpprlLength = 8;  		// set equal to size of sprmPHugePapx grpprl  	}  	// check to see if we have enough room for an FC' a BX' and the grpprl  	// and the 1 byte size of the grpprl.  	int addition = 0;  	if (!Arrays.Equals (grpprl' lastGrpprl)) {  		addition = (FC_SIZE + BX_SIZE + grpprlLength + 1);  	}  	else {  		addition = (FC_SIZE + BX_SIZE);  	}  	totalSize += addition;  	// if size is uneven we will have to add one so the first grpprl falls  	// on a word boundary  	if (totalSize > 511 + (index % 2)) {  		totalSize -= addition;  		break;  	}  	// grpprls must fall on word boundaries  	if (grpprlLength % 2 > 0) {  		totalSize += 1;  	}  	else {  		totalSize += 2;  	}  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprlLength > 488) {  	grpprlLength = 8;  	// set equal to size of sprmPHugePapx grpprl  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprlLength > 488) {  	grpprlLength = 8;  	// set equal to size of sprmPHugePapx grpprl  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlLength = 8;  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (totalSize > 511 + (index % 2)) {  	totalSize -= addition;  	break;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (totalSize > 511 + (index % 2)) {  	totalSize -= addition;  	break;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprlLength % 2 > 0) {  	totalSize += 1;  }  else {  	totalSize += 2;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprlLength % 2 > 0) {  	totalSize += 1;  }  else {  	totalSize += 2;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: totalSize += 2;  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf [511] = (byte)index;  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset = 511;  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: for (int x = 0; x < index; x++) {  	papx = _papxList [x];  	byte[] phe = papx.GetParagraphHeight ().ToArray ();  	byte[] grpprl = papx.GetGrpprl ();  	// is grpprl huge?  	if (grpprl.Length > 488) {  		/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  		System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  		int dataStreamOffset = dataStream.Offset;  		dataStream.Write (hugePapx);  		// grpprl = grpprl Containing only a sprmPHugePapx2  		int istd = LittleEndian.GetUShort (grpprl' 0);  		grpprl = new byte[8];  		LittleEndian.PutUShort (grpprl' 0' istd);  		LittleEndian.PutUShort (grpprl' 2' 0x6646);  		// sprmPHugePapx2  		LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  	}  	bool same = Arrays.Equals (lastGrpprl' grpprl);  	if (!same) {  		grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  		grpprlOffset -= (grpprlOffset % 2);  	}  	LittleEndian.PutInt (buf' fcOffset' translator.GetByteIndex (papx.Start));  	buf [bxOffset] = (byte)(grpprlOffset / 2);  	Array.Copy (phe' 0' buf' bxOffset + 1' phe.Length);  	// refer to the section on PAPX in the spec. Places a size on the front  	// of the PAPX. Has to do with how the grpprl stays on word  	// boundaries.  	if (!same) {  		int copyOffset = grpprlOffset;  		if ((grpprl.Length % 2) > 0) {  			buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  		}  		else {  			buf [++copyOffset] = (byte)((grpprl.Length) / 2);  			copyOffset++;  		}  		Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  		lastGrpprl = grpprl;  	}  	bxOffset += BX_SIZE;  	fcOffset += FC_SIZE;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (grpprl.Length > 488) {  	/*                     // if so do we have storage at GetHugeGrpprloffset()                     int hugeGrpprlOffset = papx.GetHugeGrpprlOffset();                     if (hugeGrpprlOffset == -1) // then we have no storage...                     {                         throw new InvalidOperationException(                               "This Paragraph has no dataStream storage.");                     }                     // we have some storage...                      // get the size of the existing storage                     int maxHugeGrpprlSize = LittleEndian.GetUShort(_dataStream' hugeGrpprlOffset);                      if (maxHugeGrpprlSize < grpprl.Length - 2)                     { // grpprl.Length-2 because we don't store the istd                         throw new InvalidOperationException(                             "This Paragraph's dataStream storage is too small.");                     }                                          // store grpprl at hugeGrpprlOffset                     Array.Copy(grpprl' 2' _dataStream' hugeGrpprlOffset + 2'                                      grpprl.Length - 2); // grpprl.Length-2 because we don't store the istd                     LittleEndian.PutUShort(_dataStream' hugeGrpprlOffset' grpprl.Length - 2);                       */byte[] hugePapx = new byte[grpprl.Length - 2];  	System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  	int dataStreamOffset = dataStream.Offset;  	dataStream.Write (hugePapx);  	// grpprl = grpprl Containing only a sprmPHugePapx2  	int istd = LittleEndian.GetUShort (grpprl' 0);  	grpprl = new byte[8];  	LittleEndian.PutUShort (grpprl' 0' istd);  	LittleEndian.PutUShort (grpprl' 2' 0x6646);  	// sprmPHugePapx2  	LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: System.Array.Copy (grpprl' 2' hugePapx' 0' grpprl.Length - 2);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprl = new byte[8];  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: LittleEndian.PutUShort (grpprl' 2' 0x6646);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: LittleEndian.PutInt (grpprl' 4' dataStreamOffset);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  	grpprlOffset -= (grpprlOffset % 2);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  	grpprlOffset -= (grpprlOffset % 2);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  	grpprlOffset -= (grpprlOffset % 2);  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprl.Length + (2 - grpprl.Length % 2));  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: grpprlOffset -= (grpprlOffset % 2);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf [bxOffset] = (byte)(grpprlOffset / 2);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	int copyOffset = grpprlOffset;  	if ((grpprl.Length % 2) > 0) {  		buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  	}  	else {  		buf [++copyOffset] = (byte)((grpprl.Length) / 2);  		copyOffset++;  	}  	Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	int copyOffset = grpprlOffset;  	if ((grpprl.Length % 2) > 0) {  		buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  	}  	else {  		buf [++copyOffset] = (byte)((grpprl.Length) / 2);  		copyOffset++;  	}  	Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if (!same) {  	int copyOffset = grpprlOffset;  	if ((grpprl.Length % 2) > 0) {  		buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  	}  	else {  		buf [++copyOffset] = (byte)((grpprl.Length) / 2);  		copyOffset++;  	}  	Array.Copy (grpprl' 0' buf' copyOffset' grpprl.Length);  	lastGrpprl = grpprl;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if ((grpprl.Length % 2) > 0) {  	buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  }  else {  	buf [++copyOffset] = (byte)((grpprl.Length) / 2);  	copyOffset++;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if ((grpprl.Length % 2) > 0) {  	buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  }  else {  	buf [++copyOffset] = (byte)((grpprl.Length) / 2);  	copyOffset++;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: if ((grpprl.Length % 2) > 0) {  	buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  }  else {  	buf [++copyOffset] = (byte)((grpprl.Length) / 2);  	copyOffset++;  }  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf [copyOffset++] = (byte)((grpprl.Length + 1) / 2);  
Magic Number,NPOI.HWPF.Model,PAPFormattedDiskPage,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPFormattedDiskPage.cs,ToByteArray,The following statement contains a magic number: buf [++copyOffset] = (byte)((grpprl.Length) / 2);  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (grpprl.Length == 8 && datastream != null)// then check for sprmPHugePapx   {  	SprmOperation sprm = new SprmOperation (grpprl' 2);  	if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  		int hugeGrpprlOffset = sprm.Operand;  		if (hugeGrpprlOffset + 1 < datastream.Length) {  			int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  			if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  				byte[] hugeGrpprl = new byte[grpprlSize + 2];  				// copy original istd into huge Grpprl  				hugeGrpprl [0] = grpprl [0];  				hugeGrpprl [1] = grpprl [1];  				// copy Grpprl from dataStream  				Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  				return new SprmBuffer (hugeGrpprl' 2);  			}  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  	int hugeGrpprlOffset = sprm.Operand;  	if (hugeGrpprlOffset + 1 < datastream.Length) {  		int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  		if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  			byte[] hugeGrpprl = new byte[grpprlSize + 2];  			// copy original istd into huge Grpprl  			hugeGrpprl [0] = grpprl [0];  			hugeGrpprl [1] = grpprl [1];  			// copy Grpprl from dataStream  			Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  			return new SprmBuffer (hugeGrpprl' 2);  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  	int hugeGrpprlOffset = sprm.Operand;  	if (hugeGrpprlOffset + 1 < datastream.Length) {  		int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  		if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  			byte[] hugeGrpprl = new byte[grpprlSize + 2];  			// copy original istd into huge Grpprl  			hugeGrpprl [0] = grpprl [0];  			hugeGrpprl [1] = grpprl [1];  			// copy Grpprl from dataStream  			Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  			return new SprmBuffer (hugeGrpprl' 2);  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  	int hugeGrpprlOffset = sprm.Operand;  	if (hugeGrpprlOffset + 1 < datastream.Length) {  		int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  		if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  			byte[] hugeGrpprl = new byte[grpprlSize + 2];  			// copy original istd into huge Grpprl  			hugeGrpprl [0] = grpprl [0];  			hugeGrpprl [1] = grpprl [1];  			// copy Grpprl from dataStream  			Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  			return new SprmBuffer (hugeGrpprl' 2);  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  	int hugeGrpprlOffset = sprm.Operand;  	if (hugeGrpprlOffset + 1 < datastream.Length) {  		int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  		if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  			byte[] hugeGrpprl = new byte[grpprlSize + 2];  			// copy original istd into huge Grpprl  			hugeGrpprl [0] = grpprl [0];  			hugeGrpprl [1] = grpprl [1];  			// copy Grpprl from dataStream  			Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  			return new SprmBuffer (hugeGrpprl' 2);  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if ((sprm.Operation == 0x45 || sprm.Operation == 0x46) && sprm.SizeCode == 3) {  	int hugeGrpprlOffset = sprm.Operand;  	if (hugeGrpprlOffset + 1 < datastream.Length) {  		int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  		if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  			byte[] hugeGrpprl = new byte[grpprlSize + 2];  			// copy original istd into huge Grpprl  			hugeGrpprl [0] = grpprl [0];  			hugeGrpprl [1] = grpprl [1];  			// copy Grpprl from dataStream  			Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  			return new SprmBuffer (hugeGrpprl' 2);  		}  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + 1 < datastream.Length) {  	int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  	if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  		byte[] hugeGrpprl = new byte[grpprlSize + 2];  		// copy original istd into huge Grpprl  		hugeGrpprl [0] = grpprl [0];  		hugeGrpprl [1] = grpprl [1];  		// copy Grpprl from dataStream  		Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  		return new SprmBuffer (hugeGrpprl' 2);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + 1 < datastream.Length) {  	int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  	if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  		byte[] hugeGrpprl = new byte[grpprlSize + 2];  		// copy original istd into huge Grpprl  		hugeGrpprl [0] = grpprl [0];  		hugeGrpprl [1] = grpprl [1];  		// copy Grpprl from dataStream  		Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  		return new SprmBuffer (hugeGrpprl' 2);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + 1 < datastream.Length) {  	int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  	if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  		byte[] hugeGrpprl = new byte[grpprlSize + 2];  		// copy original istd into huge Grpprl  		hugeGrpprl [0] = grpprl [0];  		hugeGrpprl [1] = grpprl [1];  		// copy Grpprl from dataStream  		Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  		return new SprmBuffer (hugeGrpprl' 2);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + 1 < datastream.Length) {  	int grpprlSize = LittleEndian.GetShort (datastream' hugeGrpprlOffset);  	if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  		byte[] hugeGrpprl = new byte[grpprlSize + 2];  		// copy original istd into huge Grpprl  		hugeGrpprl [0] = grpprl [0];  		hugeGrpprl [1] = grpprl [1];  		// copy Grpprl from dataStream  		Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  		return new SprmBuffer (hugeGrpprl' 2);  	}  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  	byte[] hugeGrpprl = new byte[grpprlSize + 2];  	// copy original istd into huge Grpprl  	hugeGrpprl [0] = grpprl [0];  	hugeGrpprl [1] = grpprl [1];  	// copy Grpprl from dataStream  	Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  	return new SprmBuffer (hugeGrpprl' 2);  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  	byte[] hugeGrpprl = new byte[grpprlSize + 2];  	// copy original istd into huge Grpprl  	hugeGrpprl [0] = grpprl [0];  	hugeGrpprl [1] = grpprl [1];  	// copy Grpprl from dataStream  	Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  	return new SprmBuffer (hugeGrpprl' 2);  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  	byte[] hugeGrpprl = new byte[grpprlSize + 2];  	// copy original istd into huge Grpprl  	hugeGrpprl [0] = grpprl [0];  	hugeGrpprl [1] = grpprl [1];  	// copy Grpprl from dataStream  	Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  	return new SprmBuffer (hugeGrpprl' 2);  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: if (hugeGrpprlOffset + grpprlSize < datastream.Length) {  	byte[] hugeGrpprl = new byte[grpprlSize + 2];  	// copy original istd into huge Grpprl  	hugeGrpprl [0] = grpprl [0];  	hugeGrpprl [1] = grpprl [1];  	// copy Grpprl from dataStream  	Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  	return new SprmBuffer (hugeGrpprl' 2);  }  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: Array.Copy (datastream' hugeGrpprlOffset + 2' hugeGrpprl' 2' grpprlSize);  
Magic Number,NPOI.HWPF.Model,PAPX,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PAPX.cs,FindHuge,The following statement contains a magic number: return new SprmBuffer (hugeGrpprl' 2);  
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PieceDescriptor.cs,PieceDescriptor,The following statement contains a magic number: if ((fc & 0x40000000) == 0) {  	unicode = true;  }  else {  	unicode = false;  	fc &= ~(0x40000000);  	//gives me FC in doc stream  	fc /= 2;  }  
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PieceDescriptor.cs,PieceDescriptor,The following statement contains a magic number: fc /= 2;  
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: if (!unicode) {  	tempFc *= 2;  	tempFc |= (0x40000000);  }  
Magic Number,NPOI.HWPF.Model,PieceDescriptor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PieceDescriptor.cs,ToByteArray,The following statement contains a magic number: tempFc *= 2;  
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);  
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PlexOfCps.cs,PlexOfCps,The following statement contains a magic number: _iMac = (size - 4) / (4 + sizeOfStruct);  
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PlexOfCps.cs,GetIntOffset,The following statement contains a magic number: return index * 4;  
Magic Number,NPOI.HWPF.Model,PlexOfCps,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PlexOfCps.cs,GetStructOffset,The following statement contains a magic number: return (4 * (_iMac + 1)) + (_sizeOfStruct * index);  
Magic Number,NPOI.HWPF.Model,PropertyNode,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\PropertyNode.cs,GetHashCode,The following statement contains a magic number: return this._cpStart * 31 + this._buf.GetHashCode ();  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: for (int i = 0; i < cData; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String name = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = name;  }  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: for (int i = 0; i < cData; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String name = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = name;  }  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,RevisionMarkAuthorTable,The following statement contains a magic number: offset += len * 2;  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort (header' 2' cData);  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort (header' 4' cbExtra);  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries) {  	byte[] buf = new byte[name.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)name.Length);  	StringUtil.PutUnicodeLE (name' buf' 2);  	tableStream.Write (buf);  }  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries) {  	byte[] buf = new byte[name.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)name.Length);  	StringUtil.PutUnicodeLE (name' buf' 2);  	tableStream.Write (buf);  }  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: foreach (String name in entries) {  	byte[] buf = new byte[name.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)name.Length);  	StringUtil.PutUnicodeLE (name' buf' 2);  	tableStream.Write (buf);  }  
Magic Number,NPOI.HWPF.Model,RevisionMarkAuthorTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\RevisionMarkAuthorTable.cs,WriteTo,The following statement contains a magic number: StringUtil.PutUnicodeLE (name' buf' 2);  
Magic Number,NPOI.HWPF.Model,SavedByEntry,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + userName.GetHashCode ();  
Magic Number,NPOI.HWPF.Model,SavedByEntry,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByEntry.cs,GetHashCode,The following statement contains a magic number: hash = hash * 13 + saveLocation.GetHashCode ();  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 4;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String userName = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String saveLocation = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = new SavedByEntry (userName' saveLocation);  }  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String userName = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String saveLocation = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = new SavedByEntry (userName' saveLocation);  }  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String userName = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String saveLocation = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = new SavedByEntry (userName' saveLocation);  }  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String userName = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	len = LittleEndian.GetShort (tableStream' offset);  	offset += 2;  	String saveLocation = StringUtil.GetFromUnicodeLE (tableStream' offset' len);  	offset += len * 2;  	entries [i] = new SavedByEntry (userName' saveLocation);  }  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += len * 2;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,SavedByTable,The following statement contains a magic number: offset += len * 2;  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt (header' 2' entries.Length * 2);  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutInt (header' 2' entries.Length * 2);  
Magic Number,NPOI.HWPF.Model,SavedByTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SavedByTable.cs,WriteStringValue,The following statement contains a magic number: StringUtil.PutUnicodeLE (value' buf' 2);  
Magic Number,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,CPtoFC,The following statement contains a magic number: if (TP.IsUnicode) {  	offset = offset * 2;  }  
Magic Number,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,CPtoFC,The following statement contains a magic number: offset = offset * 2;  
Magic Number,NPOI.HWPF.Model,SectionTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SectionTable.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < len; x++) {  	SEPX sepx = _sections [x];  	byte[] grpprl = sepx.GetGrpprl ();  	// write the sepx to the document stream. starts with a 2 byte size  	// followed by the grpprl  	byte[] shortBuf = new byte[2];  	LittleEndian.PutShort (shortBuf' (short)grpprl.Length);  	docStream.Write (shortBuf);  	docStream.Write (grpprl);  	// set the fc in the section descriptor  	SectionDescriptor sed = sepx.GetSectionDescriptor ();  	sed.SetFc (offset);  	// add the section descriptor bytes to the PlexOfCps.  	// original line -  	//GenericPropertyNode property = new GenericPropertyNode(sepx.Start' sepx.End' sed.ToArray());  	// Line using Ryan's FCtoCP() conversion method -  	// unable to observe any effect on our testcases when using this code - piers  	GenericPropertyNode property = new GenericPropertyNode (tpt.GetCharIndex (sepx.StartBytes)' tpt.GetCharIndex (sepx.EndBytes)' sed.ToArray ());  	plex.AddProperty (property);  	offset = docStream.Offset;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += 4;  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (data' offset);  	offset += 2;  	String value = StringUtil.GetFromUnicodeLE (data' offset' len);  	offset += len * 2;  	entries [i] = value;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: for (int i = 0; i < numEntries; i++) {  	int len = LittleEndian.GetShort (data' offset);  	offset += 2;  	String value = StringUtil.GetFromUnicodeLE (data' offset' len);  	offset += len * 2;  	entries [i] = value;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Read,The following statement contains a magic number: offset += len * 2;  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: if (entries == null || entries.Length == 0) {  	LittleEndian.PutInt (header' 2' 0);  	tableStream.Write (header);  	return 6;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: if (entries == null || entries.Length == 0) {  	LittleEndian.PutInt (header' 2' 0);  	tableStream.Write (header);  	return 6;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: LittleEndian.PutInt (header' 2' 0);  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: return 6;  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: LittleEndian.PutInt (header' 2' entries.Length);  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries) {  	byte[] buf = new byte[entry.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)entry.Length);  	StringUtil.PutUnicodeLE (entry' buf' 2);  	tableStream.Write (buf);  	size += buf.Length;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries) {  	byte[] buf = new byte[entry.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)entry.Length);  	StringUtil.PutUnicodeLE (entry' buf' 2);  	tableStream.Write (buf);  	size += buf.Length;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: foreach (String entry in entries) {  	byte[] buf = new byte[entry.Length * 2 + 2];  	LittleEndian.PutShort (buf' 0' (short)entry.Length);  	StringUtil.PutUnicodeLE (entry' buf' 2);  	tableStream.Write (buf);  	size += buf.Length;  }  
Magic Number,NPOI.HWPF.Model,SttbfUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\SttbfUtils.cs,Write,The following statement contains a magic number: StringUtil.PutUnicodeLE (entry' buf' 2);  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: if (word9) {  	nameLength = LittleEndian.GetShort (std' nameStart);  	multiplier = 2;  	nameStart += LittleEndianConsts.SHORT_SIZE;  }  else {  	nameLength = std [nameStart];  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: multiplier = 2;  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: for (int x = 0; x < numUPX; x++) {  	int upxSize = LittleEndian.GetShort (std' varoffset);  	varoffset += LittleEndianConsts.SHORT_SIZE;  	byte[] upx = new byte[upxSize];  	Array.Copy (std' varoffset' upx' 0' upxSize);  	_upxs [x] = new UPX (upx);  	varoffset += upxSize;  	// the upx will always start on a word boundary.  	if (upxSize % 2 == 1) {  		++varoffset;  	}  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,StyleDescription,The following statement contains a magic number: if (upxSize % 2 == 1) {  	++varoffset;  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs [0].Size + 2;  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 1; x < _upxs.Length; x++) {  	size += _upxs [x - 1].Size % 2;  	size += _upxs [x].Size + 2;  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 1; x < _upxs.Length; x++) {  	size += _upxs [x - 1].Size % 2;  	size += _upxs [x].Size + 2;  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs [x - 1].Size % 2;  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: size += _upxs [x].Size + 2;  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: for (int x = 0; x < _upxs.Length; x++) {  	short upxSize = (short)_upxs [x].Size;  	LittleEndian.PutShort (buf' offset' upxSize);  	offset += LittleEndianConsts.SHORT_SIZE;  	Array.Copy (_upxs [x].GetUPX ()' 0' buf' offset' upxSize);  	offset += upxSize + (upxSize % 2);  }  
Magic Number,NPOI.HWPF.Model,StyleDescription,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleDescription.cs,ToArray,The following statement contains a magic number: offset += upxSize + (upxSize % 2);  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc = new int[3];  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: _rgftc [2] = LittleEndian.GetShort (tableStream' offset);  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: for (int x = 0; x < stdCount; x++) {  	int stdSize = LittleEndian.GetShort (tableStream' offset);  	//get past the size  	offset += 2;  	if (stdSize > 0) {  		//byte[] std = new byte[stdSize];  		StyleDescription aStyle = new StyleDescription (tableStream' _baseLength' offset' true);  		_styleDescriptions [x] = aStyle;  	}  	offset += stdSize;  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,StyleSheet,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort (buf' offset' (short)_rgftc [2]);  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < _styleDescriptions.Length; x++) {  	if (_styleDescriptions [x] != null) {  		byte[] std = _styleDescriptions [x].ToArray ();  		// adjust the size so it is always on a word boundary  		LittleEndian.PutShort (sizeHolder' (short)((std.Length) + (std.Length % 2)));  		out1.Write (sizeHolder);  		out1.Write (std);  		// Must always start on a word boundary.  		if (std.Length % 2 == 1) {  			out1.Write ('\0');  		}  	}  	else {  		sizeHolder [0] = 0;  		sizeHolder [1] = 0;  		out1.Write (sizeHolder);  	}  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: for (int x = 0; x < _styleDescriptions.Length; x++) {  	if (_styleDescriptions [x] != null) {  		byte[] std = _styleDescriptions [x].ToArray ();  		// adjust the size so it is always on a word boundary  		LittleEndian.PutShort (sizeHolder' (short)((std.Length) + (std.Length % 2)));  		out1.Write (sizeHolder);  		out1.Write (std);  		// Must always start on a word boundary.  		if (std.Length % 2 == 1) {  			out1.Write ('\0');  		}  	}  	else {  		sizeHolder [0] = 0;  		sizeHolder [1] = 0;  		out1.Write (sizeHolder);  	}  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: if (_styleDescriptions [x] != null) {  	byte[] std = _styleDescriptions [x].ToArray ();  	// adjust the size so it is always on a word boundary  	LittleEndian.PutShort (sizeHolder' (short)((std.Length) + (std.Length % 2)));  	out1.Write (sizeHolder);  	out1.Write (std);  	// Must always start on a word boundary.  	if (std.Length % 2 == 1) {  		out1.Write ('\0');  	}  }  else {  	sizeHolder [0] = 0;  	sizeHolder [1] = 0;  	out1.Write (sizeHolder);  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: if (_styleDescriptions [x] != null) {  	byte[] std = _styleDescriptions [x].ToArray ();  	// adjust the size so it is always on a word boundary  	LittleEndian.PutShort (sizeHolder' (short)((std.Length) + (std.Length % 2)));  	out1.Write (sizeHolder);  	out1.Write (std);  	// Must always start on a word boundary.  	if (std.Length % 2 == 1) {  		out1.Write ('\0');  	}  }  else {  	sizeHolder [0] = 0;  	sizeHolder [1] = 0;  	out1.Write (sizeHolder);  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: LittleEndian.PutShort (sizeHolder' (short)((std.Length) + (std.Length % 2)));  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,WriteTo,The following statement contains a magic number: if (std.Length % 2 == 1) {  	out1.Write ('\0');  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: if (ss._baseLength == _baseLength && ss._flags == _flags && ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex && ss._rgftc [0] == _rgftc [0] && ss._rgftc [1] == _rgftc [1] && ss._rgftc [2] == _rgftc [2] && ss._stshiLength == _stshiLength && ss._stylenameVersion == _stylenameVersion) {  	if (ss._styleDescriptions.Length == _styleDescriptions.Length) {  		for (int x = 0; x < _styleDescriptions.Length; x++) {  			// check for null  			if (ss._styleDescriptions [x] != _styleDescriptions [x]) {  				// check for Equality  				if (!ss._styleDescriptions [x].Equals (_styleDescriptions [x])) {  					return false;  				}  			}  		}  		return true;  	}  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,Equals,The following statement contains a magic number: if (ss._baseLength == _baseLength && ss._flags == _flags && ss._maxFixedIndex == _maxFixedIndex && ss._maxIndex == _maxIndex && ss._rgftc [0] == _rgftc [0] && ss._rgftc [1] == _rgftc [1] && ss._rgftc [2] == _rgftc [2] && ss._stshiLength == _stshiLength && ss._stylenameVersion == _stylenameVersion) {  	if (ss._styleDescriptions.Length == _styleDescriptions.Length) {  		for (int x = 0; x < _styleDescriptions.Length; x++) {  			// check for null  			if (ss._styleDescriptions [x] != _styleDescriptions [x]) {  				// check for Equality  				if (!ss._styleDescriptions [x].Equals (_styleDescriptions [x])) {  					return false;  				}  			}  		}  		return true;  	}  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The following statement contains a magic number: if (pap == null && papx != null) {  	ParagraphProperties parentPAP = new ParagraphProperties ();  	if (baseIndex != NIL_STYLE) {  		parentPAP = _styleDescriptions [baseIndex].GetPAP ();  		if (parentPAP == null) {  			if (baseIndex == istd) {  				// Oh dear' style claims that it is its own parent  				throw new InvalidOperationException ("Pap style " + istd + " claimed to have itself as its parent' which isn't allowed");  			}  			// Create the parent style  			CreatePap (baseIndex);  			parentPAP = _styleDescriptions [baseIndex].GetPAP ();  		}  	}  	pap = ParagraphSprmUncompressor.UncompressPAP (parentPAP' papx' 2);  	sd.SetPAP (pap);  }  
Magic Number,NPOI.HWPF.Model,StyleSheet,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\StyleSheet.cs,CreatePap,The following statement contains a magic number: pap = ParagraphSprmUncompressor.UncompressPAP (parentPAP' papx' 2);  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The following statement contains a magic number: for (int x = 0; x < pieces.Length; x++) {  	int start = pieces [x].FilePosition;  	PropertyNode node = pieceTable.GetProperty (x);  	// Grab the start and end' which are in characters  	int nodeStartChars = node.Start;  	int nodeEndChars = node.End;  	// What's the relationship between bytes and characters?  	bool unicode = pieces [x].IsUnicode;  	int multiple = 1;  	if (unicode) {  		multiple = 2;  	}  	// Figure out the Length' in bytes and chars  	int textSizeChars = (nodeEndChars - nodeStartChars);  	int textSizeBytes = textSizeChars * multiple;  	// Grab the data that Makes up the piece  	byte[] buf = new byte[textSizeBytes];  	Array.Copy (documentStream' start' buf' 0' textSizeBytes);  	// And now build the piece  	_textPieces.Add (new TextPiece (nodeStartChars' nodeEndChars' buf' pieces [x]' node.Start));  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The following statement contains a magic number: if (unicode) {  	multiple = 2;  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,TextPieceTable,The following statement contains a magic number: multiple = 2;  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces) {  	if (charPos >= tp.End) {  		byteCount = tp.PieceDescriptor.FilePosition + (tp.End - tp.Start) * (tp.IsUnicode ? 2 : 1);  		if (charPos == tp.End)  			break;  		continue;  	}  	if (charPos < tp.End) {  		int left = charPos - tp.Start;  		byteCount = tp.PieceDescriptor.FilePosition + left * (tp.IsUnicode ? 2 : 1);  		break;  	}  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces) {  	if (charPos >= tp.End) {  		byteCount = tp.PieceDescriptor.FilePosition + (tp.End - tp.Start) * (tp.IsUnicode ? 2 : 1);  		if (charPos == tp.End)  			break;  		continue;  	}  	if (charPos < tp.End) {  		int left = charPos - tp.Start;  		byteCount = tp.PieceDescriptor.FilePosition + left * (tp.IsUnicode ? 2 : 1);  		break;  	}  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: if (charPos >= tp.End) {  	byteCount = tp.PieceDescriptor.FilePosition + (tp.End - tp.Start) * (tp.IsUnicode ? 2 : 1);  	if (charPos == tp.End)  		break;  	continue;  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: byteCount = tp.PieceDescriptor.FilePosition + (tp.End - tp.Start) * (tp.IsUnicode ? 2 : 1);  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: if (charPos < tp.End) {  	int left = charPos - tp.Start;  	byteCount = tp.PieceDescriptor.FilePosition + left * (tp.IsUnicode ? 2 : 1);  	break;  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetByteIndex,The following statement contains a magic number: byteCount = tp.PieceDescriptor.FilePosition + left * (tp.IsUnicode ? 2 : 1);  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetCharIndex,The following statement contains a magic number: foreach (TextPiece tp in _textPieces) {  	int pieceStart = tp.PieceDescriptor.FilePosition;  	int bytesLength = tp.BytesLength;  	int pieceEnd = pieceStart + bytesLength;  	int toAdd;  	if (bytePos < pieceStart || bytePos > pieceEnd) {  		toAdd = bytesLength;  	}  	else if (bytePos > pieceStart && bytePos < pieceEnd) {  		toAdd = (bytePos - pieceStart);  	}  	else {  		toAdd = bytesLength - (pieceEnd - bytePos);  	}  	if (tp.IsUnicode) {  		charCount += toAdd / 2;  	}  	else {  		charCount += toAdd;  	}  	if (bytePos >= pieceStart && bytePos <= pieceEnd && charCount >= startCP) {  		break;  	}  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetCharIndex,The following statement contains a magic number: if (tp.IsUnicode) {  	charCount += toAdd / 2;  }  else {  	charCount += toAdd;  }  
Magic Number,NPOI.HWPF.Model,TextPieceTable,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\TextPieceTable.cs,GetCharIndex,The following statement contains a magic number: charCount += toAdd / 2;  
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,BKFAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\BKFAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,CHPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\CHPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 1 + 2 + 2 + 2 + 1 + 2 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 2 + 2 + 2 + 2 + 4 + 1 + 1 + 2 + 4 + 32 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_35_doptypography = LittleEndian.GetByteArray (data' 0x5a + offset' 310);  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_36_dogrid = LittleEndian.GetByteArray (data' 0x190 + offset' 10);  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_39_asumyi = LittleEndian.GetByteArray (data' 0x19e + offset' 12);  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,FillFields,The following statement contains a magic number: field_44_Spare = LittleEndian.GetByteArray (data' 0x1ba + offset' 30);  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,DOPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\DOPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 4 + 4 + 4 + 2 + 4 + 2 + 310 + 10 + 2 + 2 + 12 + 4 + 4 + 4 + 4 + 30 + 4 + 4 + 4 + 4 + 4 + 2 + 2 + 2 + 2;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FIBAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FIBAbstractType.cs,GetSize,The following statement contains a magic number: return 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FLDAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FLDAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;  
Magic Number,NPOI.HWPF.Model.Types,FRDAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FRDAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 2;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,FSPAAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\FSPAAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 4 + 4 + 2 + 4;  
Magic Number,NPOI.HWPF.Model.Types,HRESIAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\HRESIAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +1 + 1;  
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;  
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;  
Magic Number,NPOI.HWPF.Model.Types,LFOAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\LFOAbstractType.cs,GetSize,The following statement contains a magic number: return 0 + 4 + 4 + 4 + 1 + 1 + 1 + 1;  
Magic Number,NPOI.HWPF.Model.Types,PAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\PAPAbstractType.cs,PAPAbstractType,The following statement contains a magic number: this.field_41_lvl = 9;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_1_bkc = 2;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_13_dxaPgn = 720;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_14_dyaPgn = 720;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_39_xaPage = 12240;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_40_yaPage = 15840;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_41_xaPageNUp = 12240;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_42_yaPageNUp = 15840;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_43_dxaLeft = 1800;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_44_dxaRight = 1800;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_45_dyaTop = 1440;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_46_dyaBottom = 1440;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_48_dyaHdrTop = 720;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_49_dyaHdrBottom = 720;  
Magic Number,NPOI.HWPF.Model.Types,SEPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\SEPAbstractType.cs,SEPAbstractType,The following statement contains a magic number: this.field_53_dxaColumns = 720;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TAPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TAPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 4 + 4 + 0 + 0 + 4 + 2 + 130 + 0 + 0 + 4 + 4 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TCAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TCAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 2 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 2 + 2 + 2 + 2 + 1 + 1 + 1 + 1 + 4 + 4 + 4 + 4;  
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;  
Magic Number,NPOI.HWPF.Model.Types,TLPAbstractType,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Model\Types\TLPAbstractType.cs,GetSize,The following statement contains a magic number: return 4 + +2 + 1;  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (!newCHP.GetDttmRMark ().Equals (oldCHP.GetDttmRMark ())) {  	byte[] buf = new byte[4];  	newCHP.GetDttmRMark ().Serialize (buf' 0);  	size += SprmUtils.AddSprm ((short)0x6805' LittleEndian.GetInt (buf)' null' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (newCHP.IsFSpec () && newCHP.GetFtcSym () != 0) {  	byte[] varParam = new byte[4];  	LittleEndian.PutShort (varParam' 0' (short)newCHP.GetFtcSym ());  	LittleEndian.PutShort (varParam' 2' (short)newCHP.GetXchSym ());  	size += SprmUtils.AddSprm ((short)0x6a09' 0' varParam' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: if (newCHP.IsFSpec () && newCHP.GetFtcSym () != 0) {  	byte[] varParam = new byte[4];  	LittleEndian.PutShort (varParam' 0' (short)newCHP.GetFtcSym ());  	LittleEndian.PutShort (varParam' 2' (short)newCHP.GetXchSym ());  	size += SprmUtils.AddSprm ((short)0x6a09' 0' varParam' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmCompressor.cs,CompressCharacterProperty,The following statement contains a magic number: LittleEndian.PutShort (varParam' 2' (short)newCHP.GetXchSym ());  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (cInc != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (cInc != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (sprm.Operand != 0) {  	if (oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  }  else {  	if (oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (sprm.Operand != 0) {  	if (oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  }  else {  	if (oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (sprm.Operand != 0) {  	if (oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  }  else {  	if (oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (sprm.Operand != 0) {  	if (oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  }  else {  	if (oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (oldCHP.GetHpsPos () == 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (oldCHP.GetHpsPos () == 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (oldCHP.GetHpsPos () != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: if (oldCHP.GetHpsPos () != 0) {  	newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  }  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  
Magic Number,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following statement contains a magic number: Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (!newPAP.GetLspd ().Equals (oldPAP.GetLspd ())) {  	// sprmPDyaLine  	byte[] buf = new byte[4];  	newPAP.GetLspd ().Serialize (buf' 0);  	size += SprmUtils.AddSprm ((short)0x6412' LittleEndian.GetInt (buf)' null' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (newPAP.GetFPropRMark () != oldPAP.GetFPropRMark () || newPAP.GetIbstPropRMark () != oldPAP.GetIbstPropRMark () || !newPAP.GetDttmPropRMark ().Equals (oldPAP.GetDttmPropRMark ())) {  	// sprmPPropRMark  	byte[] buf = new byte[7];  	buf [0] = (byte)(newPAP.GetFPropRMark () ? 1 : 0);  	LittleEndian.PutShort (buf' 1' (short)newPAP.GetIbstPropRMark ());  	newPAP.GetDttmPropRMark ().Serialize (buf' 3);  	size += SprmUtils.AddSprm (unchecked((short)0xC63F)' 0' buf' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: if (newPAP.GetFPropRMark () != oldPAP.GetFPropRMark () || newPAP.GetIbstPropRMark () != oldPAP.GetIbstPropRMark () || !newPAP.GetDttmPropRMark ().Equals (oldPAP.GetDttmPropRMark ())) {  	// sprmPPropRMark  	byte[] buf = new byte[7];  	buf [0] = (byte)(newPAP.GetFPropRMark () ? 1 : 0);  	LittleEndian.PutShort (buf' 1' (short)newPAP.GetIbstPropRMark ());  	newPAP.GetDttmPropRMark ().Serialize (buf' 3);  	size += SprmUtils.AddSprm (unchecked((short)0xC63F)' 0' buf' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmCompressor.cs,CompressParagraphProperty,The following statement contains a magic number: newPAP.GetDttmPropRMark ().Serialize (buf' 3);  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newPAP.SetIstd (sprm.Operand);  	break;  case 0x1:  	// Used only for piece table grpprl's not for PAPX  	//        int istdFirst = LittleEndian.Getshort (varParam' 2);  	//        int istdLast = LittleEndian.Getshort (varParam' 4);  	//        if ((newPAP.GetIstd () > istdFirst) || (newPAP.GetIstd () <= istdLast))  	//        {  	//          permuteIstd (newPAP' varParam' opSize);  	//        }  	break;  case 0x2:  	if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  		byte paramTmp = (byte)sprm.Operand;  		newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  		newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  		if (((paramTmp >> 7) & 0x01) == 1) {  			newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  		}  		else {  			newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  		}  	}  	break;  case 0x3:  	// Physical justification of the paragraph  	newPAP.SetJc ((byte)sprm.Operand);  	break;  case 0x4:  	newPAP.SetFSideBySide (sprm.Operand != 0);  	break;  case 0x5:  	newPAP.SetFKeep (sprm.Operand != 0);  	break;  case 0x6:  	newPAP.SetFKeepFollow (sprm.Operand != 0);  	break;  case 0x7:  	newPAP.SetFPageBreakBefore (sprm.Operand != 0);  	break;  case 0x8:  	newPAP.SetBrcl ((byte)sprm.Operand);  	break;  case 0x9:  	newPAP.SetBrcp ((byte)sprm.Operand);  	break;  case 0xa:  	newPAP.SetIlvl ((byte)sprm.Operand);  	break;  case 0xb:  	newPAP.SetIlfo (sprm.Operand);  	break;  case 0xc:  	newPAP.SetFNoLnn (sprm.Operand != 0);  	break;  case 0xd:  	/**handle tabs . variable parameter. seperate Processing needed*/handleTabs (newPAP' sprm);  	break;  case 0xe:  	newPAP.SetDxaRight (sprm.Operand);  	break;  case 0xf:  	newPAP.SetDxaLeft (sprm.Operand);  	break;  case 0x10:  	// sprmPNest is only stored in grpprls linked to a piece table.  	newPAP.SetDxaLeft (newPAP.GetDxaLeft () + sprm.Operand);  	newPAP.SetDxaLeft (Math.Max (0' newPAP.GetDxaLeft ()));  	break;  case 0x11:  	newPAP.SetDxaLeft1 (sprm.Operand);  	break;  case 0x12:  	newPAP.SetLspd (new LineSpacingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x13:  	newPAP.SetDyaBefore (sprm.Operand);  	break;  case 0x14:  	newPAP.SetDyaAfter (sprm.Operand);  	break;  case 0x15:  	// fast saved only  	//ApplySprmPChgTabs (newPAP' varParam' opSize);  	break;  case 0x16:  	newPAP.SetFInTable (sprm.Operand != 0);  	break;  case 0x17:  	newPAP.SetFTtp (sprm.Operand != 0);  	break;  case 0x18:  	newPAP.SetDxaAbs (sprm.Operand);  	break;  case 0x19:  	newPAP.SetDyaAbs (sprm.Operand);  	break;  case 0x1a:  	newPAP.SetDxaWidth (sprm.Operand);  	break;  case 0x1b:  	byte param = (byte)sprm.Operand;  	/** @todo handle paragraph postioning*/byte pcVert = (byte)((param & 0x0c) >> 2);  	byte pcHorz = (byte)(param & 0x03);  	if (pcVert != 3) {  		newPAP.SetPcVert (pcVert);  	}  	if (pcHorz != 3) {  		newPAP.SetPcHorz (pcHorz);  	}  	break;  // BrcXXX1 is older Version. Brc is used  case 0x1c:  	//newPAP.SetBrcTop1((short)param);  	break;  case 0x1d:  	//newPAP.SetBrcLeft1((short)param);  	break;  case 0x1e:  	//newPAP.SetBrcBottom1((short)param);  	break;  case 0x1f:  	//newPAP.SetBrcRight1((short)param);  	break;  case 0x20:  	//newPAP.SetBrcBetween1((short)param);  	break;  case 0x21:  	//newPAP.SetBrcBar1((byte)param);  	break;  case 0x22:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x23:  	newPAP.SetWr ((byte)sprm.Operand);  	break;  case 0x24:  	newPAP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x25:  	newPAP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x26:  	newPAP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x27:  	newPAP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x28:  	newPAP.SetBrcBetween (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x29:  	newPAP.SetBrcBar (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2a:  	newPAP.SetFNoAutoHyph (sprm.Operand != 0);  	break;  case 0x2b:  	newPAP.SetDyaHeight (sprm.Operand);  	break;  case 0x2c:  	newPAP.SetDcs (new DropCapSpecifier ((short)sprm.Operand));  	break;  case 0x2d:  	newPAP.SetShd (new ShadingDescriptor ((short)sprm.Operand));  	break;  case 0x2e:  	newPAP.SetDyaFromText (sprm.Operand);  	break;  case 0x2f:  	newPAP.SetDxaFromText (sprm.Operand);  	break;  case 0x30:  	newPAP.SetFLocked (sprm.Operand != 0);  	break;  case 0x31:  	newPAP.SetFWidowControl (sprm.Operand != 0);  	break;  case 0x32:  	//undocumented  	break;  case 0x33:  	newPAP.SetFKinsoku (sprm.Operand != 0);  	break;  case 0x34:  	newPAP.SetFWordWrap (sprm.Operand != 0);  	break;  case 0x35:  	newPAP.SetFOverflowPunct (sprm.Operand != 0);  	break;  case 0x36:  	newPAP.SetFTopLinePunct (sprm.Operand != 0);  	break;  case 0x37:  	newPAP.SetFAutoSpaceDE (sprm.Operand != 0);  	break;  case 0x38:  	newPAP.SetFAutoSpaceDN (sprm.Operand != 0);  	break;  case 0x39:  	newPAP.SetWAlignFont (sprm.Operand);  	break;  case 0x3a:  	newPAP.SetFontAlign ((short)sprm.Operand);  	break;  case 0x3b:  	//obsolete  	break;  case 0x3e:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (buf' 0' sprm.Grpprl' sprm.GrpprlOffset' buf.Length);  	newPAP.SetAnld (buf);  	break;  case 0x3f:  	//don't really need this. spec is confusing regarding this  	//sprm  	byte[] varParam = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newPAP.SetFPropRMark (varParam [offset] != 0);  	newPAP.SetIbstPropRMark (LittleEndian.GetShort (varParam' offset + 1));  	newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  	break;  case 0x40:  	// This condition commented out' as Word seems to set outline levels even for   	//  paragraph with other styles than Heading 1..9' even though specification   	//  does not say so. See bug 49820 for discussion.  	//if (newPAP.GetIstd () < 1 && newPAP.GetIstd () > 9)  	//{  	newPAP.SetLvl ((byte)sprm.Operand);  	//}  	break;  case 0x41:  	// undocumented  	break;  case 0x43:  	//pap.fNumRMIns  	newPAP.SetFNumRMIns (sprm.Operand != 0);  	break;  case 0x44:  	//undocumented  	break;  case 0x45:  	if (sprm.SizeCode == 6) {  		byte[] buf1 = new byte[sprm.Size - 3];  		Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  		newPAP.SetNumrm (buf1);  	}  	else {  		/**@todo handle large PAPX from data stream*/}  	break;  case 0x47:  	newPAP.SetFUsePgsuSettings (sprm.Operand != 0);  	break;  case 0x48:  	newPAP.SetFAdjustRight (sprm.Operand != 0);  	break;  case 0x49:  	// sprmPItap -- 0x6649  	newPAP.SetItap (sprm.Operand);  	break;  case 0x4a:  	// sprmPDtap -- 0x664a  	newPAP.SetItap ((byte)(newPAP.GetItap () + sprm.Operand));  	break;  case 0x4b:  	// sprmPFInnerTableCell -- 0x244b  	newPAP.SetFInnerTableCell (sprm.Operand != 0);  	break;  case 0x4c:  	// sprmPFInnerTtp -- 0x244c  	newPAP.SetFTtpEmbedded (sprm.Operand != 0);  	break;  case 0x61:  	// sprmPJc   	newPAP.SetJustificationLogical ((byte)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  	byte paramTmp = (byte)sprm.Operand;  	newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  	newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  	if (((paramTmp >> 7) & 0x01) == 1) {  		newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  	}  	else {  		newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  	}  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  	byte paramTmp = (byte)sprm.Operand;  	newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  	newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  	if (((paramTmp >> 7) & 0x01) == 1) {  		newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  	}  	else {  		newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  	}  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (newPAP.GetIstd () <= 9 || newPAP.GetIstd () >= 1) {  	byte paramTmp = (byte)sprm.Operand;  	newPAP.SetIstd (newPAP.GetIstd () + paramTmp);  	newPAP.SetLvl ((byte)(newPAP.GetLvl () + paramTmp));  	if (((paramTmp >> 7) & 0x01) == 1) {  		newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  	}  	else {  		newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  	}  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (((paramTmp >> 7) & 0x01) == 1) {  	newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  }  else {  	newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (((paramTmp >> 7) & 0x01) == 1) {  	newPAP.SetIstd (Math.Max (newPAP.GetIstd ()' 1));  }  else {  	newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: newPAP.SetIstd (Math.Min (newPAP.GetIstd ()' 9));  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (pcVert != 3) {  	newPAP.SetPcVert (pcVert);  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (pcHorz != 3) {  	newPAP.SetPcHorz (pcHorz);  }  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: newPAP.SetDttmPropRMark (new DateAndTime (varParam' offset + 3));  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (sprm.SizeCode == 6) {  	byte[] buf1 = new byte[sprm.Size - 3];  	Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  	newPAP.SetNumrm (buf1);  }  else {  	/**@todo handle large PAPX from data stream*/}  
Magic Number,NPOI.HWPF.SPRM,ParagraphSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\ParagraphSprmUncompressor.cs,UncompressPAPOperation,The following statement contains a magic number: if (sprm.SizeCode == 6) {  	byte[] buf1 = new byte[sprm.Size - 3];  	Array.Copy (buf1' 0' sprm.Grpprl' sprm.GrpprlOffset' buf1.Length);  	newPAP.SetNumrm (buf1);  }  else {  	/**@todo handle large PAPX from data stream*/}  
Magic Number,NPOI.HWPF.SPRM,SectionSprmCompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmCompressor.cs,CompressSectionProperty,The following statement contains a magic number: if (newSEP.GetFPropMark () != DEFAULT_SEP.GetFPropMark () || newSEP.GetIbstPropRMark () != DEFAULT_SEP.GetIbstPropRMark () || !newSEP.GetDttmPropRMark ().Equals (DEFAULT_SEP.GetDttmPropRMark ())) {  	byte[] buf = new byte[7];  	buf [0] = (byte)(newSEP.GetFPropMark () ? 1 : 0);  	int offset = LittleEndianConsts.BYTE_SIZE;  	LittleEndian.PutShort (buf' (short)newSEP.GetIbstPropRMark ());  	offset += LittleEndianConsts.SHORT_SIZE;  	newSEP.GetDttmPropRMark ().Serialize (buf' offset);  	size += SprmUtils.AddSprm (unchecked((short)0xD227)' -1' buf' sprmList);  }  
Magic Number,NPOI.HWPF.SPRM,SectionSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SectionSprmUncompressor.cs,UncompressSEPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newSEP.SetCnsPgn ((byte)sprm.Operand);  	break;  case 0x1:  	newSEP.SetIHeadingPgn ((byte)sprm.Operand);  	break;  case 0x2:  	byte[] buf = new byte[sprm.Size - 3];  	Array.Copy (sprm.Grpprl' sprm.GrpprlOffset' buf' 0' buf.Length);  	newSEP.SetOlstAnm (buf);  	break;  case 0x3:  	//not quite sure  	break;  case 0x4:  	//not quite sure  	break;  case 0x5:  	newSEP.SetFEvenlySpaced (GetFlag (sprm.Operand));  	break;  case 0x6:  	newSEP.SetFUnlocked (GetFlag (sprm.Operand));  	break;  case 0x7:  	newSEP.SetDmBinFirst ((short)sprm.Operand);  	break;  case 0x8:  	newSEP.SetDmBinOther ((short)sprm.Operand);  	break;  case 0x9:  	newSEP.SetBkc ((byte)sprm.Operand);  	break;  case 0xa:  	newSEP.SetFTitlePage (GetFlag (sprm.Operand));  	break;  case 0xb:  	newSEP.SetCcolM1 ((short)sprm.Operand);  	break;  case 0xc:  	newSEP.SetDxaColumns (sprm.Operand);  	break;  case 0xd:  	newSEP.SetFAutoPgn (GetFlag (sprm.Operand));  	break;  case 0xe:  	newSEP.SetNfcPgn ((byte)sprm.Operand);  	break;  case 0xf:  	newSEP.SetDyaPgn ((short)sprm.Operand);  	break;  case 0x10:  	newSEP.SetDxaPgn ((short)sprm.Operand);  	break;  case 0x11:  	newSEP.SetFPgnRestart (GetFlag (sprm.Operand));  	break;  case 0x12:  	newSEP.SetFEndNote (GetFlag (sprm.Operand));  	break;  case 0x13:  	newSEP.SetLnc ((byte)sprm.Operand);  	break;  case 0x14:  	newSEP.SetGrpfIhdt ((byte)sprm.Operand);  	break;  case 0x15:  	newSEP.SetNLnnMod ((short)sprm.Operand);  	break;  case 0x16:  	newSEP.SetDxaLnn (sprm.Operand);  	break;  case 0x17:  	newSEP.SetDyaHdrTop (sprm.Operand);  	break;  case 0x18:  	newSEP.SetDyaHdrBottom (sprm.Operand);  	break;  case 0x19:  	newSEP.SetFLBetween (GetFlag (sprm.Operand));  	break;  case 0x1a:  	newSEP.SetVjc ((byte)sprm.Operand);  	break;  case 0x1b:  	newSEP.SetLnnMin ((short)sprm.Operand);  	break;  case 0x1c:  	newSEP.SetPgnStart ((short)sprm.Operand);  	break;  case 0x1d:  	newSEP.SetDmOrientPage (sprm.Operand != 0);  	break;  case 0x1e:  	//nothing  	break;  case 0x1f:  	newSEP.SetXaPage (sprm.Operand);  	break;  case 0x20:  	newSEP.SetYaPage (sprm.Operand);  	break;  case 0x21:  	newSEP.SetDxaLeft (sprm.Operand);  	break;  case 0x22:  	newSEP.SetDxaRight (sprm.Operand);  	break;  case 0x23:  	newSEP.SetDyaTop (sprm.Operand);  	break;  case 0x24:  	newSEP.SetDyaBottom (sprm.Operand);  	break;  case 0x25:  	newSEP.SetDzaGutter (sprm.Operand);  	break;  case 0x26:  	newSEP.SetDmPaperReq ((short)sprm.Operand);  	break;  case 0x27:  	newSEP.SetFPropMark (GetFlag (sprm.Operand));  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	newSEP.SetBrcTop (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2c:  	newSEP.SetBrcLeft (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2d:  	newSEP.SetBrcBottom (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2e:  	newSEP.SetBrcRight (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x2f:  	newSEP.SetPgbProp (sprm.Operand);  	break;  case 0x30:  	newSEP.SetDxtCharSpace (sprm.Operand);  	break;  case 0x31:  	newSEP.SetDyaLinePitch (sprm.Operand);  	break;  case 0x33:  	newSEP.SetWTextFlow ((short)sprm.Operand);  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[sprmsStartOffset + 4];  
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmBuffer.cs,SprmBuffer,The following statement contains a magic number: _buf = new byte[4];  
Magic Number,NPOI.HWPF.SPRM,SprmBuffer,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmBuffer.cs,EnsureCapacity,The following statement contains a magic number: if (_offset + Addition >= _buf.Length) {  	// Add 6 more than they need for use the next iteration  	byte[] newBuf = new byte[_offset + Addition + 6];  	Array.Copy (_buf' 0' newBuf' 0' _buf.Length);  	_buf = newBuf;  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,SprmOperation,The following statement contains a magic number: _gOffset = offset + 2;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: switch (_sizeCode) {  case 0:  case 1:  	return 3;  case 2:  case 4:  case 5:  	return 4;  case 3:  	return 6;  case 6:  	if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  		int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  		_gOffset += 2;  		return retVal;  	}  	else {  		return (0x000000ff & _grpprl [_gOffset++]) + 3;  	}  case 7:  	return 5;  default:  	throw new ArgumentException ("SPRM contains an invalid size code");  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: return 3;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: return 4;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: return 6;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  	int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  	_gOffset += 2;  	return retVal;  }  else {  	return (0x000000ff & _grpprl [_gOffset++]) + 3;  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  	int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  	_gOffset += 2;  	return retVal;  }  else {  	return (0x000000ff & _grpprl [_gOffset++]) + 3;  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: if (sprm == LONG_SPRM_TABLE || sprm == LONG_SPRM_PARAGRAPH) {  	int retVal = (0x0000ffff & LittleEndian.GetShort (_grpprl' _gOffset)) + 3;  	_gOffset += 2;  	return retVal;  }  else {  	return (0x000000ff & _grpprl [_gOffset++]) + 3;  }  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: _gOffset += 2;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: return (0x000000ff & _grpprl [_gOffset++]) + 3;  
Magic Number,NPOI.HWPF.SPRM,SprmOperation,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmOperation.cs,InitSize,The following statement contains a magic number: return 5;  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: System.Array.Copy (varParam' 0' sprm' 4' varParam.Length);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSpecialSprm,The following statement contains a magic number: LittleEndian.PutShort (sprm' 2' (short)(varParam.Length + 1));  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: switch (type) {  case 0:  case 1:  	sprm = new byte[3];  	sprm [2] = (byte)param;  	break;  case 2:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 3:  	sprm = new byte[6];  	LittleEndian.PutInt (sprm' 2' param);  	break;  case 4:  case 5:  	sprm = new byte[4];  	LittleEndian.PutShort (sprm' 2' (short)param);  	break;  case 6:  	int varLength = 0;  	if (varParam != null) {  		varLength = varParam.Length;  	}  	sprm = new byte[3 + varLength];  	sprm [2] = (byte)varLength;  	if (varLength != 0) {  		System.Array.Copy (varParam' 0' sprm' 3' varLength);  	}  	break;  case 7:  	sprm = new byte[5];  	// this Is a three byte int so it has to be handled special  	byte[] temp = new byte[4];  	LittleEndian.PutInt (temp' 0' param);  	System.Array.Copy (temp' 0' sprm' 2' 3);  	break;  default:  	//should never happen  	break;  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[3];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm [2] = (byte)param;  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[4];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: LittleEndian.PutShort (sprm' 2' (short)param);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[6];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: LittleEndian.PutInt (sprm' 2' param);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[4];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: LittleEndian.PutShort (sprm' 2' (short)param);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[3 + varLength];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm [2] = (byte)varLength;  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: if (varLength != 0) {  	System.Array.Copy (varParam' 0' sprm' 3' varLength);  }  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: System.Array.Copy (varParam' 0' sprm' 3' varLength);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: sprm = new byte[5];  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: System.Array.Copy (temp' 0' sprm' 2' 3);  
Magic Number,NPOI.HWPF.SPRM,SprmUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\SprmUtils.cs,AddSprm,The following statement contains a magic number: System.Array.Copy (temp' 0' sprm' 2' 3);  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: switch (sprm.Operation) {  case 0:  	newTAP.SetJc ((short)sprm.Operand);  	break;  case 0x01: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	short itcMac = newTAP.GetItcMac ();  	int adjust = sprm.Operand - (rgdxaCenter [0] + newTAP.GetDxaGapHalf ());  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] += (short)adjust;  	}  	break;  }  case 0x02: {  	short[] rgdxaCenter = newTAP.GetRgdxaCenter ();  	if (rgdxaCenter != null) {  		int adjust = newTAP.GetDxaGapHalf () - sprm.Operand;  		rgdxaCenter [0] += (short)adjust;  	}  	newTAP.SetDxaGapHalf (sprm.Operand);  	break;  }  case 0x03:  	newTAP.SetFCantSplit (GetFlag (sprm.Operand));  	break;  case 0x04:  	newTAP.SetFTableHeader (GetFlag (sprm.Operand));  	break;  case 0x05: {  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newTAP.SetBrcTop (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcLeft (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcBottom (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcRight (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcHorizontal (new BorderCode (buf' offset));  	offset += BorderCode.SIZE;  	newTAP.SetBrcVertical (new BorderCode (buf' offset));  	break;  }  case 0x06:  	//obsolete' used in word 1.x  	break;  case 0x07:  	newTAP.SetDyaRowHeight (sprm.Operand);  	break;  case 0x08: {  	byte[] grpprl = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	short itcMac = grpprl [offset];  	short[] rgdxaCenter = new short[itcMac + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac];  	//I use varParam[0] and newTAP._itcMac interchangably  	newTAP.SetItcMac (itcMac);  	newTAP.SetRgdxaCenter (rgdxaCenter);  	newTAP.SetRgtc (rgtc);  	// get the rgdxaCenters  	for (int x = 0; x < itcMac; x++) {  		rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  	}  	// only try to get the TC entries if they exist...  	int endOfSprm = offset + sprm.Size - 6;  	// -2 bytes for sprm - 2 for size short - 2 to correct Offsets being 0 based  	int startOfTCs = offset + (1 + (itcMac + 1) * 2);  	bool hasTCs = startOfTCs < endOfSprm;  	for (int x = 0; x < itcMac; x++) {  		// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  		if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  			rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  		else  			rgtc [x] = new TableCellDescriptor ();  	}  	rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  	break;  }  case 0x09:  	/** @todo handle cell shading*/break;  case 0x0a:  	/** @todo handle word defined table styles*/break;  case 0x20:  	//      {  	//        TableCellDescriptor[] rgtc = newTAP.GetRgtc();  	//  	//        for (int x = varParam[0]; x < varParam[1]; x++)  	//        {  	//  	//          if ((varParam[2] & 0x08) > 0)  	//          {  	//            short[] brcRight = rgtc[x].GetBrcRight ();  	//            brcRight[0] = LittleEndian.Getshort (varParam' 6);  	//            brcRight[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x04) > 0)  	//          {  	//            short[] brcBottom = rgtc[x].GetBrcBottom ();  	//            brcBottom[0] = LittleEndian.Getshort (varParam' 6);  	//            brcBottom[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x02) > 0)  	//          {  	//            short[] brcLeft = rgtc[x].GetBrcLeft ();  	//            brcLeft[0] = LittleEndian.Getshort (varParam' 6);  	//            brcLeft[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//          else if ((varParam[2] & 0x01) > 0)  	//          {  	//            short[] brcTop = rgtc[x].GetBrcTop ();  	//            brcTop[0] = LittleEndian.Getshort (varParam' 6);  	//            brcTop[1] = LittleEndian.Getshort (varParam' 8);  	//          }  	//        }  	//        break;  	//      }  	break;  case 0x21: {  	int param = sprm.Operand;  	int index = (int)(param & 0xff000000) >> 24;  	int count = (param & 0x00ff0000) >> 16;  	int width = (param & 0x0000ffff);  	int itcMac = newTAP.GetItcMac ();  	short[] rgdxaCenter = new short[itcMac + count + 1];  	TableCellDescriptor[] rgtc = new TableCellDescriptor[itcMac + count];  	if (index >= itcMac) {  		index = itcMac;  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' itcMac + 1);  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' itcMac);  	}  	else {  		//copy rgdxaCenter  		Array.Copy (newTAP.GetRgdxaCenter ()' 0' rgdxaCenter' 0' index + 1);  		Array.Copy (newTAP.GetRgdxaCenter ()' index + 1' rgdxaCenter' index + count' itcMac - (index));  		//copy rgtc  		Array.Copy (newTAP.GetRgtc ()' 0' rgtc' 0' index);  		Array.Copy (newTAP.GetRgtc ()' index' rgtc' index + count' itcMac - index);  	}  	for (int x = index; x < index + count; x++) {  		rgtc [x] = new TableCellDescriptor ();  		rgdxaCenter [x] = (short)(rgdxaCenter [x - 1] + width);  	}  	rgdxaCenter [index + count] = (short)(rgdxaCenter [(index + count) - 1] + width);  	break;  }  /**@todo handle table sprms from complex files*/case 0x22:  case 0x23:  case 0x24:  case 0x25:  case 0x26:  case 0x27:  case 0x28:  case 0x29:  case 0x2a:  case 0x2b:  case 0x2c:  	break;  default:  	break;  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: for (int x = 0; x < itcMac; x++) {  	rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: rgdxaCenter [x] = LittleEndian.GetShort (grpprl' offset + (1 + (x * 2)));  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: for (int x = 0; x < itcMac; x++) {  	// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  	if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  		rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  	else  		rgtc [x] = new TableCellDescriptor ();  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: for (int x = 0; x < itcMac; x++) {  	// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  	if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  		rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  	else  		rgtc [x] = new TableCellDescriptor ();  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: for (int x = 0; x < itcMac; x++) {  	// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  	if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  		rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  	else  		rgtc [x] = new TableCellDescriptor ();  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: for (int x = 0; x < itcMac; x++) {  	// Sometimes' the grpprl does not contain data at every Offset. I have no idea why this happens.  	if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  		rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  	else  		rgtc [x] = new TableCellDescriptor ();  }  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  	rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  else  	rgtc [x] = new TableCellDescriptor ();  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  	rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  else  	rgtc [x] = new TableCellDescriptor ();  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  	rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  else  	rgtc [x] = new TableCellDescriptor ();  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: if (hasTCs && offset + (1 + ((itcMac + 1) * 2) + (x * 20)) < grpprl.Length)  	rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  else  	rgtc [x] = new TableCellDescriptor ();  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: rgtc [x] = TableCellDescriptor.ConvertBytesToTC (grpprl' offset + (1 + ((itcMac + 1) * 2) + (x * 20)));  
Magic Number,NPOI.HWPF.SPRM,TableSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\TableSprmUncompressor.cs,UncompressTAPOperation,The following statement contains a magic number: rgdxaCenter [itcMac] = LittleEndian.GetShort (grpprl' offset + (1 + (itcMac * 2)));  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_41_xstDispFldRMark = new byte[36];  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_7_hps = 20;  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_24_istd = 10;  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,CharacterProperties,The following statement contains a magic number: field_16_wCharScale = 100;  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: if (_ico24 == -1) {  	switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  	{  	case 0:  		// auto  		return -1;  	case 1:  		// black  		return 0x000000;  	case 2:  		// blue  		return 0xFF0000;  	case 3:  		// cyan  		return 0xFFFF00;  	case 4:  		// green  		return 0x00FF00;  	case 5:  		// magenta  		return 0xFF00FF;  	case 6:  		// red  		return 0x0000FF;  	case 7:  		// yellow  		return 0x00FFFF;  	case 8:  		// white  		return 0x0FFFFFF;  	case 9:  		// dark blue  		return 0x800000;  	case 10:  		// dark cyan  		return 0x808000;  	case 11:  		// dark green  		return 0x008000;  	case 12:  		// dark magenta  		return 0x800080;  	case 13:  		// dark red  		return 0x000080;  	case 14:  		// dark yellow  		return 0x008080;  	case 15:  		// dark grey  		return 0x808080;  	case 16:  		// light grey  		return 0xC0C0C0;  	}  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following statement contains a magic number: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
Magic Number,NPOI.HWPF.UserModel,FieldsImpl,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\FieldsImpl.cs,BinarySearch,The following statement contains a magic number: return -mid - (result >= 0 ? 1 : 2);  
Magic Number,NPOI.HWPF.UserModel,HeaderStories,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\HeaderStories.cs,GetHeader,The following statement contains a magic number: if (pageNumber % 2 == 0) {  	if (EvenHeader.Length > 0) {  		return EvenHeader;  	}  }  
Magic Number,NPOI.HWPF.UserModel,HeaderStories,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\HeaderStories.cs,GetFooter,The following statement contains a magic number: if (pageNumber % 2 == 0) {  	if (EvenFooter.Length > 0) {  		return EvenFooter;  	}  }  
Magic Number,NPOI.HWPF.UserModel,HWPFList,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData ((int)(new Random ((int)DateTime.Now.Ticks).Next (0' 100) / 100 * DateTime.Now.Millisecond)' numbered);  
Magic Number,NPOI.HWPF.UserModel,HWPFList,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\HWPFList.cs,HWPFList,The following statement contains a magic number: _listData = new ListData ((int)(new Random ((int)DateTime.Now.Ticks).Next (0' 100) / 100 * DateTime.Now.Millisecond)' numbered);  
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: if (_props.IsFBackward ()) {  	retVal |= 2;  }  
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: retVal |= 2;  
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: if (_props.IsFRotateFont ()) {  	retVal |= 4;  }  
Magic Number,NPOI.HWPF.UserModel,Paragraph,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Paragraph.cs,GetFrameTextFlow,The following statement contains a magic number: retVal |= 4;  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetAnld (new byte[84]);  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,ParagraphProperties,The following statement contains a magic number: SetPhe (new byte[12]);  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: if (jcLogical) {  	if (!GetFBiDi ())  		return GetJc ();  	switch (GetJc ()) {  	case 0:  		return 2;  	case 2:  		return 0;  	default:  		return GetJc ();  	}  }  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: if (jcLogical) {  	if (!GetFBiDi ())  		return GetJc ();  	switch (GetJc ()) {  	case 0:  		return 2;  	case 2:  		return 0;  	default:  		return GetJc ();  	}  }  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: switch (GetJc ()) {  case 0:  	return 2;  case 2:  	return 0;  default:  	return GetJc ();  }  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: switch (GetJc ()) {  case 0:  	return 2;  case 2:  	return 0;  default:  	return GetJc ();  }  
Magic Number,NPOI.HWPF.UserModel,ParagraphProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\ParagraphProperties.cs,GetJustification,The following statement contains a magic number: return 2;  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: if (MatchSignature (rawContent' COMPRESSED1' 32) || MatchSignature (rawContent' COMPRESSED2' 32)) {  	try {  		ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  		MemoryStream out1 = new MemoryStream ();  		byte[] buf = new byte[4096];  		int readBytes;  		while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  			out1.Write (buf' 0' readBytes);  		}  		content = out1.ToArray ();  	}  	catch (IOException) {  		// Problems Reading from the actual MemoryStream should never happen  		// so this will only ever be a ZipException.  		//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	}  }  else {  	// Raw data is not compressed.  	content = rawContent;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: try {  	ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  	MemoryStream out1 = new MemoryStream ();  	byte[] buf = new byte[4096];  	int readBytes;  	while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  		out1.Write (buf' 0' readBytes);  	}  	content = out1.ToArray ();  }  catch (IOException) {  	// Problems Reading from the actual MemoryStream should never happen  	// so this will only ever be a ZipException.  	//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: try {  	ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  	MemoryStream out1 = new MemoryStream ();  	byte[] buf = new byte[4096];  	int readBytes;  	while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  		out1.Write (buf' 0' readBytes);  	}  	content = out1.ToArray ();  }  catch (IOException) {  	// Problems Reading from the actual MemoryStream should never happen  	// so this will only ever be a ZipException.  	//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: try {  	ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  	MemoryStream out1 = new MemoryStream ();  	byte[] buf = new byte[4096];  	int readBytes;  	while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  		out1.Write (buf' 0' readBytes);  	}  	content = out1.ToArray ();  }  catch (IOException) {  	// Problems Reading from the actual MemoryStream should never happen  	// so this will only ever be a ZipException.  	//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: try {  	ZlibStream gzip = new ZlibStream (new MemoryStream (rawContent' 33' rawContent.Length - 33)' CompressionMode.Decompress);  	MemoryStream out1 = new MemoryStream ();  	byte[] buf = new byte[4096];  	int readBytes;  	while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  		out1.Write (buf' 0' readBytes);  	}  	content = out1.ToArray ();  }  catch (IOException) {  	// Problems Reading from the actual MemoryStream should never happen  	// so this will only ever be a ZipException.  	//log.log(POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillImageContent,The following statement contains a magic number: while ((readBytes = gzip.Read (buf' 0' 4096)) > 0) {  	out1.Write (buf' 0' readBytes);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1) {  	do {  		firstByte = _dataStream [pointer];  		secondByte = _dataStream [pointer + 1];  		pointer += 2;  	}  	while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);  	if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1) {  		if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  			break;  		}  		else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  			pointer += 5;  			this.height = GetBigEndianShort (_dataStream' pointer);  			this.width = GetBigEndianShort (_dataStream' pointer + 2);  			break;  		}  		else {  			pointer++;  			pointer++;  			int length = GetBigEndianShort (_dataStream' pointer);  			pointer += length;  		}  	}  	else {  		pointer++;  	}  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1) {  	do {  		firstByte = _dataStream [pointer];  		secondByte = _dataStream [pointer + 1];  		pointer += 2;  	}  	while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);  	if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1) {  		if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  			break;  		}  		else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  			pointer += 5;  			this.height = GetBigEndianShort (_dataStream' pointer);  			this.width = GetBigEndianShort (_dataStream' pointer + 2);  			break;  		}  		else {  			pointer++;  			pointer++;  			int length = GetBigEndianShort (_dataStream' pointer);  			pointer += length;  		}  	}  	else {  		pointer++;  	}  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: while (pointer < endOfPicture - 1) {  	do {  		firstByte = _dataStream [pointer];  		secondByte = _dataStream [pointer + 1];  		pointer += 2;  	}  	while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);  	if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1) {  		if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  			break;  		}  		else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  			pointer += 5;  			this.height = GetBigEndianShort (_dataStream' pointer);  			this.width = GetBigEndianShort (_dataStream' pointer + 2);  			break;  		}  		else {  			pointer++;  			pointer++;  			int length = GetBigEndianShort (_dataStream' pointer);  			pointer += length;  		}  	}  	else {  		pointer++;  	}  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: do {  	firstByte = _dataStream [pointer];  	secondByte = _dataStream [pointer + 1];  	pointer += 2;  }  while (!(firstByte == (byte)0xFF) && pointer < endOfPicture - 1);  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: pointer += 2;  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1) {  	if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  		break;  	}  	else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  		pointer += 5;  		this.height = GetBigEndianShort (_dataStream' pointer);  		this.width = GetBigEndianShort (_dataStream' pointer + 2);  		break;  	}  	else {  		pointer++;  		pointer++;  		int length = GetBigEndianShort (_dataStream' pointer);  		pointer += length;  	}  }  else {  	pointer++;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if (firstByte == ((byte)0xFF) && pointer < endOfPicture - 1) {  	if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  		break;  	}  	else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  		pointer += 5;  		this.height = GetBigEndianShort (_dataStream' pointer);  		this.width = GetBigEndianShort (_dataStream' pointer + 2);  		break;  	}  	else {  		pointer++;  		pointer++;  		int length = GetBigEndianShort (_dataStream' pointer);  		pointer += length;  	}  }  else {  	pointer++;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  	break;  }  else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  	pointer += 5;  	this.height = GetBigEndianShort (_dataStream' pointer);  	this.width = GetBigEndianShort (_dataStream' pointer + 2);  	break;  }  else {  	pointer++;  	pointer++;  	int length = GetBigEndianShort (_dataStream' pointer);  	pointer += length;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if (secondByte == (byte)0xD9 || secondByte == (byte)0xDA) {  	break;  }  else if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  	pointer += 5;  	this.height = GetBigEndianShort (_dataStream' pointer);  	this.width = GetBigEndianShort (_dataStream' pointer + 2);  	break;  }  else {  	pointer++;  	pointer++;  	int length = GetBigEndianShort (_dataStream' pointer);  	pointer += length;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  	pointer += 5;  	this.height = GetBigEndianShort (_dataStream' pointer);  	this.width = GetBigEndianShort (_dataStream' pointer + 2);  	break;  }  else {  	pointer++;  	pointer++;  	int length = GetBigEndianShort (_dataStream' pointer);  	pointer += length;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: if ((secondByte & 0xF0) == 0xC0 && secondByte != (byte)0xC4 && secondByte != (byte)0xC8 && secondByte != (byte)0xCC) {  	pointer += 5;  	this.height = GetBigEndianShort (_dataStream' pointer);  	this.width = GetBigEndianShort (_dataStream' pointer + 2);  	break;  }  else {  	pointer++;  	pointer++;  	int length = GetBigEndianShort (_dataStream' pointer);  	pointer += length;  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: pointer += 5;  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillJPGWidthHeight,The following statement contains a magic number: this.width = GetBigEndianShort (_dataStream' pointer + 2);  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: if (MatchSignature (_dataStream' IHDR' HEADER_START)) {  	int IHDR_CHUNK_WIDTH = HEADER_START + 4;  	this.width = GetBigEndianInt (_dataStream' IHDR_CHUNK_WIDTH);  	this.height = GetBigEndianInt (_dataStream' IHDR_CHUNK_WIDTH + 4);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: if (MatchSignature (_dataStream' IHDR' HEADER_START)) {  	int IHDR_CHUNK_WIDTH = HEADER_START + 4;  	this.width = GetBigEndianInt (_dataStream' IHDR_CHUNK_WIDTH);  	this.height = GetBigEndianInt (_dataStream' IHDR_CHUNK_WIDTH + 4);  }  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,FillPNGWidthHeight,The following statement contains a magic number: this.height = GetBigEndianInt (_dataStream' IHDR_CHUNK_WIDTH + 4);  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianInt,The following statement contains a magic number: return (((data [offset] & 0xFF) << 24) + ((data [offset + 1] & 0xFF) << 16) + ((data [offset + 2] & 0xFF) << 8) + (data [offset + 3] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Picture,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Picture.cs,GetBigEndianShort,The following statement contains a magic number: return (((data [offset] & 0xFF) << 8) + (data [offset + 1] & 0xFF));  
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _left = LittleEndian.GetInt (contenuto' 4);  
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _top = LittleEndian.GetInt (contenuto' 8);  
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _right = LittleEndian.GetInt (contenuto' 12);  
Magic Number,NPOI.HWPF.UserModel,Shape,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\Shape.cs,Shape,The following statement contains a magic number: _bottom = LittleEndian.GetInt (contenuto' 16);  
Missing Default,NPOI.HWPF.Converter,AbstractWordConverter,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordConverter.cs,ProcessField,The following switch statement is missing a default case: switch (field.Type) {  case 37:// page reference   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex pagerefPattern = new Regex ("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		Match match = pagerefPattern.Match (formula);  		if (match.Success) {  			String pageref = match.Groups [1].Value;  			ProcessPageref (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' pageref);  			return;  		}  		//Pattern pagerefPattern = Pattern  		//        .compile("[ \\t\\r\\n]*PAGEREF ([^ ]*)[ \\t\\r\\n]*\\\\h[ \\t\\r\\n]*");  		//Matcher matcher = pagerefPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String pageref = matcher.group(1);  		//    processPageref(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' pageref);  		//    return;  		//}  	}  	break;  }  case 58:// Embedded Object   {  	if (!field.HasSeparator ()) {  		logger.Log (POILogger.WARN' parentRange + " contains " + field + " with 'Embedded Object' but without separator mark");  		return;  	}  	CharacterRun separator = field.GetMarkSeparatorCharacterRun (parentRange);  	if (separator.IsOle2 ()) {  		// the only supported so far  		bool processed = ProcessOle2 (wordDocument' separator' currentBlock);  		// if we didn't output OLE - output field value  		if (!processed) {  			ProcessCharacters (wordDocument' currentTableLevel' field.SecondSubrange (parentRange)' currentBlock);  		}  		return;  	}  	break;  }  case 88:// hyperlink   {  	Range firstSubrange = field.FirstSubrange (parentRange);  	if (firstSubrange != null) {  		String formula = firstSubrange.Text;  		Regex hyperlinkPattern = new Regex ("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		Match match = hyperlinkPattern.Match (formula);  		if (match.Success) {  			String hyperlink = match.Groups [1].Value;  			ProcessHyperlink (wordDocument' currentBlock' field.SecondSubrange (parentRange)' currentTableLevel' hyperlink);  			return;  		}  		//Pattern hyperlinkPattern = Pattern  		//        .compile("[ \\t\\r\\n]*HYPERLINK \"(.*)\"[ \\t\\r\\n]*");  		//Matcher matcher = hyperlinkPattern.matcher(formula);  		//if (matcher.find())  		//{  		//    String hyperlink = matcher.group(1);  		//    processHyperlink(wordDocument' currentBlock'  		//            field.secondSubrange(parentRange)'  		//            currentTableLevel' hyperlink);  		//    return;  		//}  	}  	break;  }  }  
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetColor24,The following switch statement is missing a default case: switch (rgbValue) {  case 0xFFFFFF:  	return "white";  case 0xC0C0C0:  	return "silver";  case 0x808080:  	return "gray";  case 0x000000:  	return "black";  case 0xFF0000:  	return "red";  case 0x800000:  	return "maroon";  case 0xFFFF00:  	return "yellow";  case 0x808000:  	return "olive";  case 0x00FF00:  	return "lime";  case 0x008000:  	return "green";  case 0x00FFFF:  	return "aqua";  case 0x008080:  	return "teal";  case 0x0000FF:  	return "blue";  case 0x000080:  	return "navy";  case 0xFF00FF:  	return "fuchsia";  case 0x800080:  	return "purple";  }  
Missing Default,NPOI.HWPF.Converter,AbstractWordUtils,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\Converter\AbstractWordUtils.cs,GetJustification,The following switch statement is missing a default case: switch (js) {  case 0:  	return "start";  case 1:  	return "center";  case 2:  	return "end";  case 3:  case 4:  	return "justify";  case 5:  	return "center";  case 6:  	return "left";  case 7:  	return "start";  case 8:  	return "end";  case 9:  	return "justify";  }  
Missing Default,NPOI.HWPF.SPRM,CharacterSprmUncompressor,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\SPRM\CharacterSprmUncompressor.cs,UncompressCHPOperation,The following switch statement is missing a default case: switch (sprm.Operation) {  case 0:  	newCHP.SetFRMarkDel (GetFlag (sprm.Operand));  	break;  case 0x1:  	newCHP.SetFRMark (GetFlag (sprm.Operand));  	break;  case 0x2:  	newCHP.SetFFldVanish (GetFlag (sprm.Operand));  	break;  case 0x3:  	newCHP.SetFcPic (sprm.Operand);  	newCHP.SetFSpec (true);  	break;  case 0x4:  	newCHP.SetIbstRMark ((short)sprm.Operand);  	break;  case 0x5:  	newCHP.SetDttmRMark (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x6:  	newCHP.SetFData (GetFlag (sprm.Operand));  	break;  case 0x7:  	//don't care about this  	break;  case 0x8:  	//short chsDiff = (short)((param & 0xff0000) >>> 16);  	int operand = sprm.Operand;  	short chsDiff = (short)(operand & 0x0000ff);  	newCHP.SetFChsDiff (GetFlag (chsDiff));  	newCHP.SetChse ((short)(operand & 0xffff00));  	break;  case 0x9:  	newCHP.SetFSpec (true);  	newCHP.SetFtcSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	newCHP.SetXchSym (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset + 2));  	break;  case 0xa:  	newCHP.SetFOle2 (GetFlag (sprm.Operand));  	break;  case 0xb:  	// Obsolete  	break;  case 0xc:  	newCHP.SetIcoHighlight ((byte)sprm.Operand);  	newCHP.SetFHighlight (GetFlag (sprm.Operand));  	break;  case 0xd:  	//	undocumented  	break;  case 0xe:  	newCHP.SetFcObj (sprm.Operand);  	break;  case 0xf:  	// undocumented  	break;  case 0x10:  	// undocumented  	break;  // undocumented till 0x30  case 0x11:  	// sprmCFWebHidden  	break;  case 0x12:  	break;  case 0x13:  	break;  case 0x14:  	break;  case 0x15:  	// sprmCRsidProp  	break;  case 0x16:  	// sprmCRsidText  	break;  case 0x17:  	// sprmCRsidRMDel  	break;  case 0x18:  	// sprmCFSpecVanish  	break;  case 0x19:  	break;  case 0x1a:  	// sprmCFMathPr  	break;  case 0x1b:  	break;  case 0x1c:  	break;  case 0x1d:  	break;  case 0x1e:  	break;  case 0x1f:  	break;  case 0x20:  	break;  case 0x21:  	break;  case 0x22:  	break;  case 0x23:  	break;  case 0x24:  	break;  case 0x25:  	break;  case 0x26:  	break;  case 0x27:  	break;  case 0x28:  	break;  case 0x29:  	break;  case 0x2a:  	break;  case 0x2b:  	break;  case 0x2c:  	break;  case 0x2d:  	break;  case 0x2e:  	break;  case 0x2f:  	break;  case 0x30:  	newCHP.SetIstd (sprm.Operand);  	break;  case 0x31:  	//permutation vector for fast saves' who cares!  	break;  case 0x32:  	newCHP.SetFBold (false);  	newCHP.SetFItalic (false);  	newCHP.SetFOutline (false);  	newCHP.SetFStrike (false);  	newCHP.SetFShadow (false);  	newCHP.SetFSmallCaps (false);  	newCHP.SetFCaps (false);  	newCHP.SetFVanish (false);  	newCHP.SetKul ((byte)0);  	newCHP.SetIco ((byte)0);  	break;  case 0x33:  	// preserve the fSpec Setting from the original CHP  	bool fSpec = newCHP.IsFSpec ();  	newCHP = (CharacterProperties)oldCHP.Clone ();  	newCHP.SetFSpec (fSpec);  	return;  case 0x34:  	// sprmCKcd  	break;  case 0x35:  	newCHP.SetFBold (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFBold ()));  	break;  case 0x36:  	newCHP.SetFItalic (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFItalic ()));  	break;  case 0x37:  	newCHP.SetFStrike (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFStrike ()));  	break;  case 0x38:  	newCHP.SetFOutline (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFOutline ()));  	break;  case 0x39:  	newCHP.SetFShadow (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFShadow ()));  	break;  case 0x3a:  	newCHP.SetFSmallCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFSmallCaps ()));  	break;  case 0x3b:  	newCHP.SetFCaps (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFCaps ()));  	break;  case 0x3c:  	newCHP.SetFVanish (GetCHPFlag ((byte)sprm.Operand' oldCHP.IsFVanish ()));  	break;  case 0x3d:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x3e:  	newCHP.SetKul ((byte)sprm.Operand);  	break;  case 0x3f:  	operand = sprm.Operand;  	int hps = operand & 0xff;  	if (hps != 0) {  		newCHP.SetHps (hps);  	}  	//byte cInc = (byte)(((byte)(param & 0xfe00) >>> 4) >> 1);  	byte cInc = (byte)((operand & 0xff00) >> 8);  	cInc = (byte)(cInc >> 1);  	if (cInc != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (cInc * 2)' 2));  	}  	//byte hpsPos = (byte)((param & 0xff0000) >>> 8);  	byte hpsPos = (byte)((operand & 0xff0000) >> 16);  	if (hpsPos != 0x80) {  		newCHP.SetHpsPos (hpsPos);  	}  	bool fAdjust = (operand & 0x0100) > 0;  	if (fAdjust && hpsPos != 128 && hpsPos != 0 && oldCHP.GetHpsPos () == 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  	}  	if (fAdjust && hpsPos == 0 && oldCHP.GetHpsPos () != 0) {  		newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  	}  	break;  case 0x40:  	newCHP.SetDxaSpace (sprm.Operand);  	break;  case 0x41:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x42:  	newCHP.SetIco ((byte)sprm.Operand);  	break;  case 0x43:  	newCHP.SetHps (sprm.Operand);  	break;  case 0x44:  	byte hpsLvl = (byte)sprm.Operand;  	newCHP.SetHps (Math.Max (newCHP.GetHps () + (hpsLvl * 2)' 2));  	break;  case 0x45:  	newCHP.SetHpsPos ((short)sprm.Operand);  	break;  case 0x46:  	if (sprm.Operand != 0) {  		if (oldCHP.GetHpsPos () == 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + (-2)' 2));  		}  	}  	else {  		if (oldCHP.GetHpsPos () != 0) {  			newCHP.SetHps (Math.Max (newCHP.GetHps () + 2' 2));  		}  	}  	break;  case 0x47:  	/*CharacterProperties genCHP = new CharacterProperties ();                     genCHP.SetFtcAscii (4);                     genCHP = (CharacterProperties) unCompressProperty (varParam' genCHP'                       styleSheet);                     CharacterProperties styleCHP = styleSheet.GetStyleDescription (oldCHP.                       GetBaseIstd ()).GetCHP ();                     if (genCHP.IsFBold () == newCHP.IsFBold ())                     {                       newCHP.SetFBold (styleCHP.IsFBold ());                     }                     if (genCHP.IsFItalic () == newCHP.IsFItalic ())                     {                       newCHP.SetFItalic (styleCHP.IsFItalic ());                     }                     if (genCHP.IsFSmallCaps () == newCHP.IsFSmallCaps ())                     {                       newCHP.SetFSmallCaps (styleCHP.IsFSmallCaps ());                     }                     if (genCHP.IsFVanish () == newCHP.IsFVanish ())                     {                       newCHP.SetFVanish (styleCHP.IsFVanish ());                     }                     if (genCHP.IsFStrike () == newCHP.IsFStrike ())                     {                       newCHP.SetFStrike (styleCHP.IsFStrike ());                     }                     if (genCHP.IsFCaps () == newCHP.IsFCaps ())                     {                       newCHP.SetFCaps (styleCHP.IsFCaps ());                     }                     if (genCHP.GetFtcAscii () == newCHP.GetFtcAscii ())                     {                       newCHP.SetFtcAscii (styleCHP.GetFtcAscii ());                     }                     if (genCHP.GetFtcFE () == newCHP.GetFtcFE ())                     {                       newCHP.SetFtcFE (styleCHP.GetFtcFE ());                     }                     if (genCHP.GetFtcOther () == newCHP.GetFtcOther ())                     {                       newCHP.SetFtcOther (styleCHP.GetFtcOther ());                     }                     if (genCHP.GetHps () == newCHP.GetHps ())                     {                       newCHP.SetHps (styleCHP.GetHps ());                     }                     if (genCHP.GetHpsPos () == newCHP.GetHpsPos ())                     {                       newCHP.SetHpsPos (styleCHP.GetHpsPos ());                     }                     if (genCHP.GetKul () == newCHP.GetKul ())                     {                       newCHP.SetKul (styleCHP.GetKul ());                     }                     if (genCHP.GetDxaSpace () == newCHP.GetDxaSpace ())                     {                       newCHP.SetDxaSpace (styleCHP.GetDxaSpace ());                     }                     if (genCHP.GetIco () == newCHP.GetIco ())                     {                       newCHP.SetIco (styleCHP.GetIco ());                     }                     if (genCHP.GetLidDefault () == newCHP.GetLidDefault ())                     {                       newCHP.SetLidDefault (styleCHP.GetLidDefault ());                     }                     if (genCHP.GetLidFE () == newCHP.GetLidFE ())                     {                       newCHP.SetLidFE (styleCHP.GetLidFE ());                     }*/break;  case 0x48:  	newCHP.SetIss ((byte)sprm.Operand);  	break;  case 0x49:  	newCHP.SetHps (LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x4a:  	int increment = LittleEndian.GetShort (sprm.Grpprl' sprm.GrpprlOffset);  	newCHP.SetHps (Math.Max (newCHP.GetHps () + increment' 8));  	break;  case 0x4b:  	newCHP.SetHpsKern (sprm.Operand);  	break;  case 0x4c:  	//        unCompressCHPOperation (oldCHP' newCHP' 0x47' param' varParam'  	//                                styleSheet' opSize);  	break;  case 0x4d:  	float percentage = sprm.Operand / 100.0f;  	int add = (int)(percentage * newCHP.GetHps ());  	newCHP.SetHps (newCHP.GetHps () + add);  	break;  case 0x4e:  	newCHP.SetYsr ((byte)sprm.Operand);  	break;  case 0x4f:  	newCHP.SetFtcAscii ((short)sprm.Operand);  	break;  case 0x50:  	newCHP.SetFtcFE ((short)sprm.Operand);  	break;  case 0x51:  	newCHP.SetFtcOther ((short)sprm.Operand);  	break;  case 0x52:  	// sprmCCharScale  	break;  case 0x53:  	newCHP.SetFDStrike (GetFlag (sprm.Operand));  	break;  case 0x54:  	newCHP.SetFImprint (GetFlag (sprm.Operand));  	break;  case 0x55:  	newCHP.SetFSpec (GetFlag (sprm.Operand));  	break;  case 0x56:  	newCHP.SetFObj (GetFlag (sprm.Operand));  	break;  case 0x57:  	byte[] buf = sprm.Grpprl;  	int offset = sprm.GrpprlOffset;  	newCHP.SetFPropMark (buf [offset]);  	newCHP.SetIbstPropRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmPropRMark (new DateAndTime (buf' offset + 3));  	break;  case 0x58:  	newCHP.SetFEmboss (GetFlag (sprm.Operand));  	break;  case 0x59:  	newCHP.SetSfxtText ((byte)sprm.Operand);  	break;  case 0x5a:  	// sprmCFBiDi  	break;  case 0x5b:  	break;  case 0x5c:  	// sprmCFBoldBi  	break;  case 0x5d:  	// sprmCFItalicBi  	break;  case 0x5e:  	// sprmCFtcBi  	break;  case 0x5f:  	// sprmCLidBi   	break;  case 0x60:  	// sprmCIcoBi  	break;  case 0x61:  	// sprmCHpsBi  	break;  case 0x62:  	byte[] xstDispFldRMark = new byte[32];  	buf = sprm.Grpprl;  	offset = sprm.GrpprlOffset;  	newCHP.SetFDispFldRMark (buf [offset]);  	newCHP.SetIbstDispFldRMark (LittleEndian.GetShort (buf' offset + 1));  	newCHP.SetDttmDispFldRMark (new DateAndTime (buf' offset + 3));  	Array.Copy (buf' offset + 7' xstDispFldRMark' 0' 32);  	newCHP.SetXstDispFldRMark (xstDispFldRMark);  	break;  case 0x63:  	newCHP.SetIbstRMarkDel ((short)sprm.Operand);  	break;  case 0x64:  	newCHP.SetDttmRMarkDel (new DateAndTime (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x65:  	newCHP.SetBrc (new BorderCode (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x66:  	newCHP.SetShd (new ShadingDescriptor (sprm.Grpprl' sprm.GrpprlOffset));  	break;  case 0x67:  	// Obsolete  	break;  case 0x68:  	//  sprmCFUsePgsuSettings  	break;  case 0x69:  	break;  case 0x6a:  	break;  case 0x6b:  	break;  case 0x6c:  	break;  case 0x6d:  	newCHP.SetLidDefault ((short)sprm.Operand);  	break;  case 0x6e:  	newCHP.SetLidFE ((short)sprm.Operand);  	break;  case 0x6f:  	newCHP.SetIdctHint ((byte)sprm.Operand);  	break;  case 0x70:  	newCHP.SetIco24 (sprm.Operand);  	break;  case 0x71:  	// sprmCShd  	break;  case 0x72:  	// sprmCBrc  	break;  case 0x73:  	// sprmCRgLid0  	break;  case 0x74:  	// sprmCRgLid1  	break;  }  
Missing Default,NPOI.HWPF.UserModel,CharacterProperties,C:\repos\xoposhiy_npoi\trunk\scratchpad\HWPF\UserModel\CharacterProperties.cs,GetIco24,The following switch statement is missing a default case: switch (field_11_ico) // convert word 97 colour numbers to 0xBBGGRR value  {  case 0:  	// auto  	return -1;  case 1:  	// black  	return 0x000000;  case 2:  	// blue  	return 0xFF0000;  case 3:  	// cyan  	return 0xFFFF00;  case 4:  	// green  	return 0x00FF00;  case 5:  	// magenta  	return 0xFF00FF;  case 6:  	// red  	return 0x0000FF;  case 7:  	// yellow  	return 0x00FFFF;  case 8:  	// white  	return 0x0FFFFFF;  case 9:  	// dark blue  	return 0x800000;  case 10:  	// dark cyan  	return 0x808000;  case 11:  	// dark green  	return 0x008000;  case 12:  	// dark magenta  	return 0x800080;  case 13:  	// dark red  	return 0x000080;  case 14:  	// dark yellow  	return 0x008080;  case 15:  	// dark grey  	return 0x808080;  case 16:  	// light grey  	return 0xC0C0C0;  }  
