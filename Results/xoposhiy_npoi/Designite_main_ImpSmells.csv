Implementation smell,Namespace,Class,File,Method,Description
Long Method,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The method has 320 lines of code.
Long Method,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,PropertyName,The method has 284 lines of code.
Long Method,NPOI.DDF,EscherProperties,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherProperties.cs,InitProps,The method has 279 lines of code.
Long Method,NPOI.HSSF.Record,RecordFactory,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordFactory.cs,RecordFactory,The method has 179 lines of code.
Long Method,NPOI.HSSF.Record,UnknownRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnknownRecord.cs,GetBiffName,The method has 141 lines of code.
Long Method,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateMSDrawingObjectRecord,The method has 207 lines of code.
Long Method,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateSeries,The method has 100 lines of code.
Long Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellType,The method has 111 lines of code.
Long Method,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The method has 104 lines of code.
Long Method,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,The method has 137 lines of code.
Long Method,NPOI.HPSF,Section,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Section.cs,Section,The method has 101 lines of code.
Long Method,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The method has 132 lines of code.
Long Method,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The method has 110 lines of code.
Long Method,NPOI.HSSF.EventUserModel,HSSFRecordStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\HSSFRecordStream.cs,GetNextRecord,The method has 101 lines of code.
Long Method,NPOI.HSSF.EventUserModel,MissingRecordAwareHSSFListener,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\MissingRecordAwareHSSFListener.cs,ProcessRecord,The method has 119 lines of code.
Long Method,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,InternalSheet,The method has 173 lines of code.
Long Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The method has 130 lines of code.
Long Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The method has 296 lines of code.
Long Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The method has 100 lines of code.
Long Method,NPOI.SS.Formula,FormulaShifter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\FormulaShifter.cs,RowMoveAreaPtg,The method has 119 lines of code.
Long Method,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The method has 124 lines of code.
Long Method,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The method has 703 lines of code.
Long Method,NPOI.SS.Formula.Functions,Value,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Value.cs,ConvertTextToNumber,The method has 116 lines of code.
Long Method,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The method has 133 lines of code.
Long Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The method has 107 lines of code.
Long Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,FormatValue,The method has 120 lines of code.
Complex Method,NPOI.DDF,DefaultEscherRecordFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\DefaultEscherRecordFactory.cs,CreateRecord,Cyclomatic complexity of the method is 8
Complex Method,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Decompress,Cyclomatic complexity of the method is 10
Complex Method,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,GetBlipType,Cyclomatic complexity of the method is 9
Complex Method,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,Cyclomatic complexity of the method is 122
Complex Method,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,Cyclomatic complexity of the method is 9
Complex Method,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,OutHex,Cyclomatic complexity of the method is 11
Complex Method,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,InflatePictureData,Cyclomatic complexity of the method is 9
Complex Method,NPOI.DDF,EscherPropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPropertyFactory.cs,CreateProperties,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Record.Aggregates,WorksheetProtectionBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\WorksheetProtectionBlock.cs,ReadARecord,Cyclomatic complexity of the method is 17
Complex Method,NPOI.HSSF.Record.Aggregates,CFRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\CFRecordsAggregate.cs,UpdateFormulasAfterCellShift,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,SetColumn,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,IsComponentRecord,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,ReadARecord,Cyclomatic complexity of the method is 61
Complex Method,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,SetMargin,Cyclomatic complexity of the method is 19
Complex Method,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,RowRecordsAggregate,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Record.Aggregates,SharedValueManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\SharedValueManager.cs,GetRecordForFirstCell,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record.AutoFilter,DOPERRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AutoFilter\DOPER.cs,DOPERRecord,Cyclomatic complexity of the method is 28
Complex Method,NPOI.HSSF.Record.AutoFilter,DOPERRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AutoFilter\DOPER.cs,Serialize,Cyclomatic complexity of the method is 27
Complex Method,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Record,FeatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FeatRecord.cs,FeatRecord,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HSSF.Record,BoolErrRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BoolErrRecord.cs,BoolErrRecord,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.Record,BoolErrRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BoolErrRecord.cs,SetValue,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record,ColumnInfoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ColumnInfoRecord.cs,ColumnInfoRecord,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,Cyclomatic complexity of the method is 21
Complex Method,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record,FilePassRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FilePassRecord.cs,FilePassRecord,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HSSF.Record,SpecialCachedValue,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FormulaRecord.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,Cyclomatic complexity of the method is 14
Complex Method,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,TranslateBuiltInName,Cyclomatic complexity of the method is 14
Complex Method,NPOI.HSSF.Record,ObjRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ObjRecord.cs,ObjRecord,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record,RecordFactoryInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordFactoryInputStream.cs,ReadNextRecord,Cyclomatic complexity of the method is 16
Complex Method,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,ReadStringCommon,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,LbsDataSubRecord,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,Serialize,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,TextObjectRecord,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Record,UnknownRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnknownRecord.cs,GetBiffName,Cyclomatic complexity of the method is 58
Complex Method,NPOI.HSSF.Record,UnknownRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnknownRecord.cs,IsObservedButUnknown,Cyclomatic complexity of the method is 54
Complex Method,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteCharacterData,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.UserModel,DVConstraint,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\DVConstraint.cs,CreateNumericConstraint,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,GetSheetCharts,Cyclomatic complexity of the method is 16
Complex Method,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateSeries,Cyclomatic complexity of the method is 26
Complex Method,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,RemoveSeries,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.UserModel,HSSFErrorConstants,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFErrorConstants.cs,GetText,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,Cyclomatic complexity of the method is 29
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,HSSFCell,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellType,Cyclomatic complexity of the method is 66
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,ConvertCellValueToString,Cyclomatic complexity of the method is 13
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellValue,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellErrorValue,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellValue,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,ConvertCellValueToBoolean,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,FindCellComment,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.UserModel,HSSFFormulaEvaluator,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFFormulaEvaluator.cs,SetCellType,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.UserModel,HSSFFormulaEvaluator,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFFormulaEvaluator.cs,SetCellValue,Cyclomatic complexity of the method is 14
Complex Method,NPOI.HSSF.UserModel,HSSFHyperlink,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFHyperlink.cs,HSSFHyperlink,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,Cyclomatic complexity of the method is 22
Complex Method,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseCellStyles,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.UserModel,HSSFRichTextString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFRichTextString.cs,ApplyFont,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetPropertiesFromSheet,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,RemoveRow,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,Cyclomatic complexity of the method is 27
Complex Method,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,RemoveSheetAt,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,Cyclomatic complexity of the method is 17
Complex Method,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,AddPicture,Cyclomatic complexity of the method is 20
Complex Method,NPOI.HSSF.UserModel,StaticFontMetrics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\StaticFontMetrics.cs,GetFontDetails,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,Cyclomatic complexity of the method is 14
Complex Method,NPOI.HPSF,Section,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Section.cs,Section,Cyclomatic complexity of the method is 9
Complex Method,NPOI.HPSF,Section,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Section.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,Cyclomatic complexity of the method is 35
Complex Method,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,Cyclomatic complexity of the method is 29
Complex Method,NPOI.HSSF.EventModel,EventRecordFactory,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventModel\EventRecordFactory.cs,ProcessRecords,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.EventUserModel,HSSFRecordStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\HSSFRecordStream.cs,GetNextRecord,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HSSF.EventUserModel,MissingRecordAwareHSSFListener,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\MissingRecordAwareHSSFListener.cs,ProcessRecord,Cyclomatic complexity of the method is 42
Complex Method,NPOI.HSSF.Model,AbstractShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\AbstractShape.cs,CreateShape,Cyclomatic complexity of the method is 20
Complex Method,NPOI.HSSF.Model,CommentShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\CommentShape.cs,AddStandardOptions,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,LinkTable,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsPageBreakPriorRecord,Cyclomatic complexity of the method is 17
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindInsertPosForNewCondFormatTable,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsDVTPriorRecord,Cyclomatic complexity of the method is 10
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsGutsPriorRecord,Cyclomatic complexity of the method is 15
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsEndOfRowBlock,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsRowBlockRecord,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Model,RowBlocksReader,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RowBlocksReader.cs,RowBlocksReader,Cyclomatic complexity of the method is 21
Complex Method,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,InternalSheet,Cyclomatic complexity of the method is 33
Complex Method,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,VisitContainedRecords,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,Cyclomatic complexity of the method is 63
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CloneDrawings,Cyclomatic complexity of the method is 12
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,Serialize,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,Cyclomatic complexity of the method is 286
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,Cyclomatic complexity of the method is 30
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,FindDrawingGroup,Cyclomatic complexity of the method is 20
Complex Method,NPOI.HSSF.Model,WorkbookRecordList,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\WorkbookRecordList.cs,Add,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Model,WorkbookRecordList,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\WorkbookRecordList.cs,Remove,Cyclomatic complexity of the method is 11
Complex Method,NPOI.HSSF.Record.CF,FontFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\FontFormatting.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,Cyclomatic complexity of the method is 9
Complex Method,NPOI.POIFS.Crypt,EcmaDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EcmaDecryptor.cs,GenerateKey,Cyclomatic complexity of the method is 10
Complex Method,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,Cyclomatic complexity of the method is 11
Complex Method,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,Cyclomatic complexity of the method is 12
Complex Method,NPOI.POIFS.FileSystem,NPOIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSFileSystem.cs,GetFreeBlock,Cyclomatic complexity of the method is 12
Complex Method,NPOI.POIFS.FileSystem,NPOIFSMiniStore,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSMiniStore.cs,GetFreeBlock,Cyclomatic complexity of the method is 8
Complex Method,NPOI.POIFS.FileSystem,POIFSDocumentReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\POIFSDocumentReader.cs,Seek,Cyclomatic complexity of the method is 14
Complex Method,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,ShouldCountFeb29,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,CreateDateFormat,Cyclomatic complexity of the method is 15
Complex Method,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,cleanFormatForNumber,Cyclomatic complexity of the method is 15
Complex Method,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,FormatCellValue,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.UserModel,OperatorType,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataValidationConstraint.cs,ValidateSecondArg,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,Cyclomatic complexity of the method is 14
Complex Method,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,IsADateFormat,Cyclomatic complexity of the method is 15
Complex Method,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,IsInternalDateFormat,Cyclomatic complexity of the method is 17
Complex Method,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,ValueOf,Cyclomatic complexity of the method is 15
Complex Method,NPOI.Util,ByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\ByteArrayInputStream.cs,Seek,Cyclomatic complexity of the method is 14
Complex Method,NPOI.Util,Arrays,C:\repos\xoposhiy_npoi\trunk\main\Util\Arrays.cs,ArrayMoveWithin,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 14
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,Cyclomatic complexity of the method is 11
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,Cyclomatic complexity of the method is 9
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftLeft,Cyclomatic complexity of the method is 9
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftRight,Cyclomatic complexity of the method is 14
Complex Method,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,Cyclomatic complexity of the method is 14
Complex Method,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,Cyclomatic complexity of the method is 14
Complex Method,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,binaryGCD,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,Cyclomatic complexity of the method is 13
Complex Method,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,Cyclomatic complexity of the method is 19
Complex Method,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,Cyclomatic complexity of the method is 51
Complex Method,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,ObjectToObjectArray,Cyclomatic complexity of the method is 17
Complex Method,NPOI.POIFS.Properties,PropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\POIFS\property\PropertyFactory.cs,ConvertToProperties,Cyclomatic complexity of the method is 13
Complex Method,NPOI.POIFS.Storage,BlockAllocationTableReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BlockAllocationTableReader.cs,BlockAllocationTableReader,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,ReadAConstantValue,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Constant,ErrorConstant,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ErrorConstant.cs,ValueOf,Cyclomatic complexity of the method is 8
Complex Method,NPOI.HSSF.Record.PivotTable,ExtendedPivotTableViewFieldsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PivotTable\ExtendedPivotTableViewFieldsRecord.cs,ExtendedPivotTableViewFieldsRecord,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Eval.Forked,ForkedEvaluationCell,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\Forked\ForkedEvaluationCell.cs,CopyValue,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.PTG,AttrPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AttrPtg.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.PTG,AttrPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AttrPtg.cs,ToFormulaString,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,CreateClassifiedPtg,Cyclomatic complexity of the method is 18
Complex Method,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,CreateBasePtg,Cyclomatic complexity of the method is 29
Complex Method,NPOI.SS.Formula,CellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\CellCacheEntry.cs,AreValuesEqual,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,EvaluationCache,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\EvaluationCache.cs,NotifyUpdateCell,Cyclomatic complexity of the method is 13
Complex Method,NPOI.SS.Formula,EvaluationCache,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\EvaluationCache.cs,AreValuesEqual,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,FormulaCellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntry.cs,ChangeConsumingCells,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Remove,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,NeedsMemFunc,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,Cyclomatic complexity of the method is 22
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseNonRange,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleRangePart,Cyclomatic complexity of the method is 14
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSheetName,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleFactor,Cyclomatic complexity of the method is 16
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseArrayRow,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseArrayItem,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseErrorLiteral,Cyclomatic complexity of the method is 23
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,GetNumberPtgFromString,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,Term,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ComparisonExpression,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,AdditiveExpression,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,UnionExpression,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,FormulaRenderer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaRenderer.cs,ToFormulaString,Cyclomatic complexity of the method is 14
Complex Method,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformFormula,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformNode,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformFunctionNode,Cyclomatic complexity of the method is 31
Complex Method,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetDynamicReference,Cyclomatic complexity of the method is 36
Complex Method,NPOI.SS.Formula,FormulaShifter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\FormulaShifter.cs,AdjustPtgDueToRowMove,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula,FormulaShifter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\FormulaShifter.cs,RowMoveAreaPtg,Cyclomatic complexity of the method is 20
Complex Method,NPOI.SS.Formula,SheetNameFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SheetNameFormatter.cs,NeedsDelimiting,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateAny,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,Cyclomatic complexity of the method is 21
Complex Method,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,GetEvalForPtg,Cyclomatic complexity of the method is 18
Complex Method,NPOI.SS.Formula.Eval,ErrorEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\ErrorEval.cs,ValueOf,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Eval,OperandResolver,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\OperandResolver.cs,CoerceValueToBoolean,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.Eval,RelationalOperationEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\RelationalOperationEval\RelationalOperationEval.cs,DoCompare,Cyclomatic complexity of the method is 13
Complex Method,NPOI.SS.Formula.Eval,ValueEvalToNumericXlator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\ValueEvalToNumericXlator.cs,AttemptXlateToNumeric,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,Cyclomatic complexity of the method is 24
Complex Method,NPOI.SS.Formula.Functions,BooleanFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Boolean\BooleanFunction.cs,Calculate,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.Functions,CalendarFieldFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\CalendarFieldFunction.cs,GetCalField,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.Functions,Countif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Countif.cs,ParseBoolean,Cyclomatic complexity of the method is 11
Complex Method,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,GetValueFromArea,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,Cyclomatic complexity of the method is 15
Complex Method,NPOI.SS.Formula.Functions,LookupUtils,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\LookupUtils.cs,ResolveRangeLookupArg,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,FindIndexOfValue,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula.Functions,Mode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Mode.cs,Evaluate,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Formula.Functions,MultiOperandNumericFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MultiOperandNumericFunction.cs,CollectValue,Cyclomatic complexity of the method is 11
Complex Method,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,Cyclomatic complexity of the method is 15
Complex Method,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,Cyclomatic complexity of the method is 12
Complex Method,NPOI.SS.Formula.Functions,Value,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Value.cs,ConvertTextToNumber,Cyclomatic complexity of the method is 55
Complex Method,NPOI.SS.Formula.Functions,XYNumericFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\XYNumericFunction.cs,EvaluateInternal,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Formula.Function,FunctionMetadataReader,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadataReader.cs,CreateRegistry,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,SeparateAreaRefs,Cyclomatic complexity of the method is 16
Complex Method,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ClassifyCellReference,Cyclomatic complexity of the method is 13
Complex Method,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ParseSheetName,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,Cyclomatic complexity of the method is 24
Complex Method,NPOI.SS.Util,NumberComparer,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberComparer.cs,Compare,Cyclomatic complexity of the method is 11
Complex Method,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,Cyclomatic complexity of the method is 19
Complex Method,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,CreateSafeSheetName,Cyclomatic complexity of the method is 17
Complex Method,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,ValidateSheetName,Cyclomatic complexity of the method is 14
Complex Method,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,ValidateSheetState,Cyclomatic complexity of the method is 8
Complex Method,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,Load,Cyclomatic complexity of the method is 23
Complex Method,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,Cyclomatic complexity of the method is 38
Complex Method,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,Cyclomatic complexity of the method is 25
Complex Method,NPOI.SS.Format,CellFormatCondition,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatCondition.cs,GetInstance,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,CellFormatPart,Cyclomatic complexity of the method is 8
Complex Method,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,formatType,Cyclomatic complexity of the method is 21
Complex Method,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,Cyclomatic complexity of the method is 23
Complex Method,NPOI.SS.Format,CellGeneralFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellGeneralFormatter.cs,FormatValue,Cyclomatic complexity of the method is 13
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,Cyclomatic complexity of the method is 18
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,Cyclomatic complexity of the method is 10
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,FormatValue,Cyclomatic complexity of the method is 39
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteScientific,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteFraction,Cyclomatic complexity of the method is 9
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,Cyclomatic complexity of the method is 13
Complex Method,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteFractional,Cyclomatic complexity of the method is 9
Long Parameter List,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,SetColumnInfoFields,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,SetColumn,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,SetColumnInfoFields,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.Record,ContinueRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ContinueRecord.cs,Write,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.Record,DVRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DVRecord.cs,DVRecord,The method has 15 parameters.
Long Parameter List,NPOI.HSSF.UserModel,DVConstraint,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\DVConstraint.cs,DVConstraint,The method has 7 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,SetValueRange,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,EscherGraphics,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,CopyArea,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawArc,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawImage,The method has 10 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawImage,The method has 9 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawImage,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawImage,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawLine,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawRoundRect,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,FillArc,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,FillRoundRect,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,HSSFCell,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellType,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The method has 8 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The method has 8 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFPatriarch,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPatriarch.cs,CreateAnchor,The method has 8 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,CreateSplitPane,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The method has 8 parameters.
Long Parameter List,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetPrintArea,The method has 5 parameters.
Long Parameter List,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,Property,The method has 5 parameters.
Long Parameter List,NPOI.HPSF,Util,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Util.cs,Copy,The method has 5 parameters.
Long Parameter List,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,SetColumn,The method has 5 parameters.
Long Parameter List,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,SetColumn,The method has 6 parameters.
Long Parameter List,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreateSplitPane,The method has 5 parameters.
Long Parameter List,NPOI.POIFS.FileSystem,POIFSDocument,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\POIFSDocument.cs,POIFSDocument,The method has 5 parameters.
Long Parameter List,NPOI.POIFS.FileSystem,POIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\POIFSFileSystem.cs,ProcessProperties,The method has 5 parameters.
Long Parameter List,NPOI.SS.UserModel,CellValue,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\CellValue.cs,CellValue,The method has 5 parameters.
Long Parameter List,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The method has 7 parameters.
Long Parameter List,NPOI.SS.UserModel,IDrawing,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Drawing.cs,CreateAnchor,The method has 8 parameters.
Long Parameter List,NPOI.SS.UserModel,ISheet,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Sheet.cs,ShiftRows,The method has 5 parameters.
Long Parameter List,NPOI.SS.UserModel,ISheet,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Sheet.cs,CreateSplitPane,The method has 5 parameters.
Long Parameter List,NPOI.SS.UserModel,IWorkbook,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Workbook.cs,SetRepeatingRowsAndColumns,The method has 5 parameters.
Long Parameter List,NPOI.SS.UserModel,IWorkbook,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Workbook.cs,FindFont,The method has 8 parameters.
Long Parameter List,NPOI.SS.UserModel,IWorkbook,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\Workbook.cs,SetPrintArea,The method has 5 parameters.
Long Parameter List,NPOI.Util,ByteBuffer,C:\repos\xoposhiy_npoi\trunk\main\Util\ByteBuffer.cs,ByteBuffer,The method has 6 parameters.
Long Parameter List,NPOI.Util,ByteBuffer,C:\repos\xoposhiy_npoi\trunk\main\Util\ByteBuffer.cs,ByteBuffer,The method has 6 parameters.
Long Parameter List,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The method has 5 parameters.
Long Parameter List,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulAdd,The method has 5 parameters.
Long Parameter List,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulsub,The method has 5 parameters.
Long Parameter List,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The method has 5 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 5 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 6 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 7 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 8 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 9 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 5 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 6 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 7 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 8 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 9 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,Log,The method has 10 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,LogFormatted,The method has 5 parameters.
Long Parameter List,NPOI.Util,NullLogger,C:\repos\xoposhiy_npoi\trunk\main\Util\NullLogger.cs,LogFormatted,The method has 6 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 5 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 6 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 7 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 8 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 9 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 5 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 6 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 7 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 8 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 9 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The method has 10 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,LogFormatted,The method has 5 parameters.
Long Parameter List,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,LogFormatted,The method has 6 parameters.
Long Parameter List,NPOI.POIFS.Storage,BlockAllocationTableReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BlockAllocationTableReader.cs,BlockAllocationTableReader,The method has 6 parameters.
Long Parameter List,NPOI.POIFS.Dev,POIFSViewEngine,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Dev\POIFSViewEngine.cs,ProcessViewable,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,Area2DPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Area2DPtgBase.cs,Area2DPtgBase,The method has 8 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,Area3DPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Area3DPtg.cs,Area3DPtg,The method has 9 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,OffsetArea,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaI.cs,OffsetArea,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,AreaPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaPtg.cs,AreaPtg,The method has 8 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,AreaPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaPtgBase.cs,AreaPtgBase,The method has 8 parameters.
Long Parameter List,NPOI.SS.Formula.PTG,ArrayPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ArrayPtg.cs,ArrayPtg,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula,EvaluationCache,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\EvaluationCache.cs,GetPlainValueEntry,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,EvaluationTracker,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\EvaluationTracker.cs,AcceptPlainValueDependency,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,IEvaluationListener,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\IEvaluationListener.cs,OnChangeFromBlankValue,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,LazyAreaEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\LazyAreaEval.cs,LazyAreaEval,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,OperationEvaluationContext,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetDynamicReference,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetArea3DEval,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateAny,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateReference,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The method has 7 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceLib.cs,fv,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceLib.cs,pv,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceLib.cs,pmt,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,FinanceLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceLib.cs,nper,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Fixed3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed3ArgFunction.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Fixed4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed4ArgFunction.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Function3Arg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Function3Arg.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Function4Arg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Function4Arg.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Fv,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fv.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,If,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\If.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,GetValueFromArea,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Nper,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Nper.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Npv,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Npv.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Npv,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Npv.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Poisson,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Numeric\Poisson.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Pmt,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Pmt.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Pv,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Pv.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Sumif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Sumif.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Sumif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Sumif.cs,Eval,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Sumif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Sumif.cs,Accumulate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,SearchFind,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\SearchFind.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,TimeFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\TimeFunc.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Vlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Vlookup.cs,Evaluate,The method has 5 parameters.
Long Parameter List,NPOI.SS.Formula.Functions,Vlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Vlookup.cs,Evaluate,The method has 6 parameters.
Long Parameter List,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,Add,The method has 7 parameters.
Long Parameter List,NPOI.SS.Formula.Function,FunctionMetadata,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadata.cs,FunctionMetadata,The method has 6 parameters.
Long Parameter List,NPOI.SS,SpreadsheetVersion,C:\repos\xoposhiy_npoi\trunk\main\SS\SpreadsheetVersion.cs,SpreadsheetVersion,The method has 5 parameters.
Long Parameter List,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,CellReference,The method has 5 parameters.
Long Parameter List,NPOI.SS.Util,PaneInformation,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\PaneInformation.cs,PaneInformation,The method has 6 parameters.
Long Parameter List,NPOI.SS.Util,SSCellRange,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SSCellRange.cs,SSCellRange,The method has 5 parameters.
Long Parameter List,NPOI.SS.Util,SSCellRange,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SSCellRange.cs,Create,The method has 6 parameters.
Long Parameter List,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,ReplaceMod,The method has 5 parameters.
Long Parameter List,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteFraction,The method has 5 parameters.
Long Parameter List,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteSingleint,The method has 5 parameters.
Long Parameter List,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The method has 5 parameters.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,NameRecord,The length of the parameter field_4_length_name_definition is 30.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,NameRecord,The length of the parameter field_8_length_description_text is 31.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,NameRecord,The length of the parameter field_9_length_help_topic_text is 30.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,NameRecord,The length of the parameter field_10_length_status_bar_text is 31.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,Serialize,The length of the parameter field_8_length_description_text is 31.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,Serialize,The length of the parameter field_9_length_help_topic_text is 30.
Long Identifier,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,Serialize,The length of the parameter field_10_length_status_bar_text is 31.
Long Identifier,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,AttachToEnvironment,The length of the parameter collaboratingWorkbooksEnvironment is 33.
Long Identifier,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateAny,The length of the parameter shouldCellDependencyBeRecorded is 30.
Long Identifier,NPOI.SS.Formula.Functions,Value,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Value.cs,ConvertTextToNumber,The length of the parameter distanceBetweenThousandsSeparators is 34.
Long Statement,NPOI.DDF,DefaultEscherRecordFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\DefaultEscherRecordFactory.cs,CreateRecord,The length of the statement  "		if (header.RecordId == EscherBitmapBlip.RECORD_ID_DIB || header.RecordId == EscherBitmapBlip.RECORD_ID_JPEG || header.RecordId == EscherBitmapBlip.RECORD_ID_PNG) { " is 163.
Long Statement,NPOI.DDF,DefaultEscherRecordFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\DefaultEscherRecordFactory.cs,CreateRecord,The length of the statement  "		else if (header.RecordId == EscherMetafileBlip.RECORD_ID_EMF || header.RecordId == EscherMetafileBlip.RECORD_ID_WMF || header.RecordId == EscherMetafileBlip.RECORD_ID_PICT) { " is 174.
Long Statement,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,ToString,The length of the statement  "	return "propNum: " + PropertyNumber + "' propName: " + EscherProperties.GetPropertyName (PropertyNumber) + "' complex: " + IsComplex + "' blipId: " + IsBlipId + "' data: " + nl + results.ToString (); " is 199.
Long Statement,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,ToString,The length of the statement  "		return this.GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  UID: 0x" + HexDump.ToHex (field_1_UID) + nl + "  Marker: 0x" + HexDump.ToHex (field_2_marker) + nl + "  Extra Data:" + nl + extraData; " is 278.
Long Statement,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,ToString,The length of the statement  "		return this.GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl; " is 139.
Long Statement,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  Secondary UID: " + HexDump.ToHex (field_1_secondaryUID) + nl + "  CacheOfSize: " + field_2_cacheOfSize + nl + "  BoundaryTop: " + field_3_boundaryTop + nl + "  BoundaryLeft: " + field_4_boundaryLeft + nl + "  BoundaryWidth: " + field_5_boundaryWidth + nl + "  BoundaryHeight: " + field_6_boundaryHeight + nl + "  X: " + field_7_width + nl + "  Y: " + field_8_height + nl + "  CacheOfSavedSize: " + field_9_cacheOfSavedSize + nl + "  CompressionFlag: " + field_10_compressionFlag + nl + "  Filter: " + field_11_filter + nl; " is 661.
Long Statement,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  BlipTypeWin32: " + field_1_blipTypeWin32 + nl + "  BlipTypeMacOS: " + field_2_blipTypeMacOS + nl + "  SUID: " + HexDump.ToHex (field_3_uid) + nl + "  Tag: " + field_4_tag + nl + "  Size: " + field_5_size + nl + "  Ref: " + field_6_ref + nl + "  Offset: " + field_7_offset + nl + "  Usage: " + field_8_usage + nl + "  Name: " + field_9_name + nl + "  Unused2: " + field_10_unused2 + nl + "  Unused3: " + field_11_unused3 + nl + "  blipRecord: " + (field_12_blipRecord == null ? "null" : field_12_blipRecord.ToString ()) + nl; " is 664.
Long Statement,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  X1: " + field_1_dx1 + nl + "  Y1: " + field_2_dy1 + nl + "  X2: " + field_3_dx2 + nl + "  Y2: " + field_4_dy2 + nl; " is 255.
Long Statement,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  Flag: " + field_1_flag + nl + "  Col1: " + field_2_col1 + nl + "  DX1: " + field_3_dx1 + nl + "  Row1: " + field_4_row1 + nl + "  DY1: " + field_5_dy1 + nl + "  Col2: " + field_6_col2 + nl + "  DX2: " + field_7_dx2 + nl + "  Row2: " + field_8_row2 + nl + "  DY2: " + field_9_dy2 + nl; " is 424.
Long Statement,NPOI.DDF,EscherClientDataRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientDataRecord.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl; " is 135.
Long Statement,NPOI.DDF,EscherComplexProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherComplexProperty.cs,ToString,The length of the statement  "	return "propNum: " + PropertyNumber + "' propName: " + EscherProperties.GetPropertyName (PropertyNumber) + "' complex: " + IsComplex + "' blipId: " + IsBlipId + "' data: " + Environment.NewLine + dataStr; " is 204.
Long Statement,NPOI.DDF,EscherContainerRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherContainerRecord.cs,ToString,The length of the statement  "	return indent + this.GetType ().Name + " (" + RecordName + "):" + nl + indent + "  isContainer: " + IsContainerRecord + nl + indent + "  options: 0x" + HexDump.ToHex (Options) + nl + indent + "  recordId: 0x" + HexDump.ToHex (RecordId) + nl + indent + "  numchildren: " + ChildRecords.Count + nl + indent + children.ToString (); " is 328.
Long Statement,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The length of the statement  "		field_5_fileIdClusters [i] = new FileIdCluster (LittleEndian.GetInt (data' pos + size)' LittleEndian.GetInt (data' pos + size + 4)); " is 132.
Long Statement,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  ShapeIdMax: " + field_1_shapeIdMax + nl + "  NumIdClusters: " + NumIdClusters + nl + "  NumShapesSaved: " + field_3_numShapesSaved + nl + "  DrawingsSaved: " + field_4_drawingsSaved + nl + "" + field_5_string.ToString (); " is 361.
Long Statement,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  NumShapes: " + field_1_numShapes + nl + "  LastMSOSPID: " + field_2_lastMSOSPID + nl; " is 225.
Long Statement,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  UID: 0x" + HexDump.ToHex (field_1_UID) + nl + (field_2_UID == null ? "" : ("  UID2: 0x" + HexDump.ToHex (field_2_UID) + nl)) + "  Uncompressed Size: " + HexDump.ToHex (field_2_cb) + nl + "  Bounds: " + Bounds + nl + "  Size in EMU: " + SizeEMU + nl + "  Compressed Size: " + HexDump.ToHex (field_5_cbSave) + nl + "  Compression: " + HexDump.ToHex (field_6_fCompression) + nl + "  Filter: " + HexDump.ToHex (field_7_fFilter) + nl + "  Extra Data:" + nl + extraData + (remainingData == null ? null : ("\n" + " Remaining Data: " + HexDump.ToHex (remainingData' 32))); " is 703.
Long Statement,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,ToString,The length of the statement  "		return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  UID: 0x" + HexDump.ToHex (field_1_UID) + nl + "  Uncompressed Size: " + HexDump.ToHex (field_2_cb) + nl + "  Bounds: " + Bounds + nl + "  Size in EMU: " + SizeEMU + nl + "  Compressed Size: " + HexDump.ToHex (field_5_cbSave) + nl + "  Compression: " + HexDump.ToHex (field_6_fCompression) + nl + "  Filter: " + HexDump.ToHex (field_7_fFilter) + nl + "  Extra Data:" + nl + extraData; " is 522.
Long Statement,NPOI.DDF,EscherProperties,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherProperties.cs,InitProps,The length of the statement  "		AddProp (PROTECTION__LOCKAGAINSTGROUPING' GetData ("protection.lockagainstgrouping"' EscherPropertyMetaData.TYPE_bool)); " is 120.
Long Statement,NPOI.DDF,EscherProperties,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherProperties.cs,InitProps,The length of the statement  "		AddProp (GROUPSHAPE__WRAPPOLYGONVERTICES' GetData ("groupshape.wrappolygonvertices"' EscherPropertyMetaData.TYPE_ARRAY)); " is 121.
Long Statement,NPOI.DDF,EscherSimpleProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSimpleProperty.cs,ToString,The length of the statement  "	return "propNum: " + PropertyNumber + "' RAW: 0x" + HexDump.ToHex (Id) + "' propName: " + EscherProperties.GetPropertyName (PropertyNumber) + "' complex: " + IsComplex + "' blipId: " + IsBlipId + "' value: " + propertyValue + " (0x" + HexDump.ToHex (propertyValue) + ")"; " is 271.
Long Statement,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  RectX: " + field_1_rectX1 + nl + "  RectY: " + field_2_rectY1 + nl + "  RectWidth: " + field_3_rectX2 + nl + "  RectHeight: " + field_4_rectY2 + nl; " is 288.
Long Statement,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  Color1: 0x" + HexDump.ToHex (field_1_color1) + nl + "  Color2: 0x" + HexDump.ToHex (field_2_color2) + nl + "  Color3: 0x" + HexDump.ToHex (field_3_color3) + nl + "  Color4: 0x" + HexDump.ToHex (field_4_color4) + nl + ""; " is 360.
Long Statement,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,ToString,The length of the statement  "	return this.GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RECORD_ID) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  ShapeId: " + field_1_shapeId + nl + "  Flags: " + DecodeFlags (field_2_flags) + " (0x" + HexDump.ToHex (field_2_flags) + ")" + nl; " is 275.
Long Statement,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,ToString,The length of the statement  "	return GetType ().Name + ":" + nl + "  isContainer: " + IsContainerRecord + nl + "  options: 0x" + HexDump.ToHex (Options) + nl + "  recordId: 0x" + HexDump.ToHex (RecordId) + nl + "  numchildren: " + ChildRecords.Count + nl + theDumpHex; " is 238.
Long Statement,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,ToString,The length of the statement  "	return this.GetType ().Name + ":" + nl + "  isContainer: " + IsContainerRecord + nl + "  options: 0x" + HexDump.ToHex (Options) + nl + "  recordId: 0x" + HexDump.ToHex (RecordId) + nl + "  numchildren: " + ChildRecords.Count + nl + theDumpHex + children.ToString (); " is 266.
Long Statement,NPOI.HSSF.Record.Aggregates,WorksheetProtectionBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\WorksheetProtectionBlock.cs,CheckNotPresent,The length of the statement  "		throw new RecordFormatException ("Duplicate WorksheetProtectionBlock record (sid=0x" + StringUtil.ToHexString (rec.Sid) + ")"); " is 127.
Long Statement,NPOI.HSSF.Record.Aggregates,CFRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\CFRecordsAggregate.cs,CreateCFAggregate,The length of the statement  "		throw new InvalidOperationException ("next record sid was " + rec.Sid + " instead of " + CFHeaderRecord.sid + " as expected"); " is 126.
Long Statement,NPOI.HSSF.Record.Aggregates,CFRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\CFRecordsAggregate.cs,CreateCFAggregate,The length of the statement  "		throw new InvalidOperationException ("next record sid was " + rec.Sid + " instead of " + CFHeaderRecord.sid + " as expected"); " is 126.
Long Statement,NPOI.HSSF.Record.Aggregates,CFRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\CFRecordsAggregate.cs,AddRule,The length of the statement  "		throw new InvalidOperationException ("Cannot have more than " + MAX_CONDTIONAL_FORMAT_RULES + " conditional format rules"); " is 123.
Long Statement,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,CollapseColInfoRecords,The length of the statement  "	bool columnsMatch = previousCol.XFIndex == currentCol.XFIndex && previousCol.Options == currentCol.Options && previousCol.ColumnWidth == currentCol.ColumnWidth; " is 160.
Long Statement,NPOI.HSSF.Record.Aggregates,ConditionalFormattingTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ConditionalFormattingTable.cs,CheckIndex,The length of the statement  "		throw new ArgumentException ("Specified CF index " + index + " is outside the allowable range (0.." + (_cfHeaders.Count - 1) + ")"); " is 132.
Long Statement,NPOI.HSSF.Record.Aggregates,FormulaRecordAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\FormulaRecordAggregate.cs,SetArrayFormula,The length of the statement  "	ArrayRecord arr = new ArrayRecord (NPOI.SS.Formula.Formula.Create (ptgs)' new CellRangeAddress8Bit (r.FirstRow' r.LastRow' r.FirstColumn' r.LastColumn)); " is 153.
Long Statement,NPOI.HSSF.Record.Aggregates,MergedCellsTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\MergedCellsTable.cs,CheckIndex,The length of the statement  "		throw new ArgumentException ("Specified CF index " + index + " is outside the allowable range (0.." + (_mergedRegions.Count - 1) + ")"); " is 136.
Long Statement,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CheckNotPresent,The length of the statement  "		throw new RecordFormatException ("Duplicate PageSettingsBlock record (sid=0x" + StringUtil.ToHexString (rec.Sid) + ")"); " is 120.
Long Statement,NPOI.HSSF.Record.Aggregates,SharedValueManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\SharedValueManager.cs,CreateEmpty,The length of the statement  "	return new SharedValueManager (new SharedFormulaRecord[0]' new CellReference[0]' new List<ArrayRecord> ()' new List<TableRecord> ()); " is 133.
Long Statement,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,RemoveAllCellsValuesForRow,The length of the statement  "		throw new ArgumentException ("Specified rowIndex " + rowIndex + " is outside the allowable range (0.." + MAX_ROW_INDEX + ")"); " is 126.
Long Statement,NPOI.HSSF.Record.AutoFilter,DOPERRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AutoFilter\DOPER.cs,Serialize,The length of the statement  "		throw new InvalidOperationException ("Error in serialization of (" + this.GetType ().Name + "): " + "Incorrect number of bytes written - expected " + this.RecordSize + " but got " + (out1.WriteIndex - offset)); " is 210.
Long Statement,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Equals,The length of the statement  "	bool eq = ((field_1_charCount == other.field_1_charCount) && (field_2_optionflags == other.field_2_optionflags) && field_3_string.Equals (other.field_3_string)); " is 161.
Long Statement,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Equals,The length of the statement  "	if (((field_4_format_Runs == null) && (other.field_4_format_Runs != null)) || (field_4_format_Runs != null) && (other.field_4_format_Runs == null)) " is 147.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .horizontalAlignment  = ").Append ("0x").Append (HexDump.ToHex (HorizontalAlignment)).Append (" (").Append (HorizontalAlignment).Append (" )"); " is 163.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .verticalAlignment    = ").Append ("0x").Append (HexDump.ToHex (VerticalAlignment)).Append (" (").Append (VerticalAlignment).Append (" )"); " is 159.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .DisplayMode          = ").Append ("0x").Append (HexDump.ToHex (DisplayMode)).Append (" (").Append (DisplayMode).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .rgbColor             = ").Append ("0x").Append (HexDump.ToHex (RgbColor)).Append (" (").Append (RgbColor).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .x                    = ").Append ("0x").Append (HexDump.ToHex (X)).Append (" (").Append (X).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .y                    = ").Append ("0x").Append (HexDump.ToHex (Y)).Append (" (").Append (Y).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .width                = ").Append ("0x").Append (HexDump.ToHex (Width)).Append (" (").Append (Width).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .height               = ").Append ("0x").Append (HexDump.ToHex (Height)).Append (" (").Append (Height).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options1             = ").Append ("0x").Append (HexDump.ToHex (Options1)).Append (" (").Append (Options1).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .IndexOfColorValue    = ").Append ("0x").Append (HexDump.ToHex (IndexOfColorValue)).Append (" (").Append (IndexOfColorValue).Append (" )"); " is 159.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options2             = ").Append ("0x").Append (HexDump.ToHex (Options2)).Append (" (").Append (Options2).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record,TextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .textRotation         = ").Append ("0x").Append (HexDump.ToHex (TextRotation)).Append (" (").Append (TextRotation).Append (" )"); " is 149.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .majorTickType        = ").Append ("0x").Append (HexDump.ToHex (MajorTickType)).Append (" (").Append (MajorTickType).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .minorTickType        = ").Append ("0x").Append (HexDump.ToHex (MinorTickType)).Append (" (").Append (MinorTickType).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .labelPosition        = ").Append ("0x").Append (HexDump.ToHex (LabelPosition)).Append (" (").Append (LabelPosition).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .background           = ").Append ("0x").Append (HexDump.ToHex (Background)).Append (" (").Append (Background).Append (" )"); " is 145.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .labelColorRgb        = ").Append ("0x").Append (HexDump.ToHex (LabelColorRgb)).Append (" (").Append (LabelColorRgb).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .zero1                = ").Append ("0x").Append (HexDump.ToHex (Zero1)).Append (" (").Append (Zero1).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .zero2                = ").Append ("0x").Append (HexDump.ToHex (Zero2)).Append (" (").Append (Zero2).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .tickColor            = ").Append ("0x").Append (HexDump.ToHex (TickColor)).Append (" (").Append (TickColor).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record,TickRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\TickRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .zero3                = ").Append ("0x").Append (HexDump.ToHex (Zero3)).Append (" (").Append (Zero3).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record,UnitsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\UnitsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .units                = ").Append ("0x").Append (HexDump.ToHex (Units)).Append (" (").Append (Units).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record,DBCellRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DBCellRecord.cs,ToString,The length of the statement  "		buffer.Append ("    .cell_").Append (k).Append (" = ").Append (HexDump.ShortToHex (field_2_cell_offsets [k])).Append ("\n"); " is 124.
Long Statement,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The length of the statement  "		throw new InvalidOperationException ("No child escher containers at the point that should hold the patriach data' and one container per top level shape!"); " is 155.
Long Statement,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The length of the statement  "					EscherClientAnchorRecord anchorRecord = (EscherClientAnchorRecord)GetEscherChild (shapeContainer' EscherClientAnchorRecord.RECORD_ID); " is 134.
Long Statement,NPOI.HSSF.Record,ExternalNameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExternalNameRecord.cs,ReadFail,The length of the statement  "	String fullMsg = msg + " fields: (option=" + field_1_option_flag + " index=" + field_2_ixals + " not_used=" + field_3_not_used + " name='" + field_4_name + "')"; " is 161.
Long Statement,NPOI.HSSF.Record,FontRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FontRecord.cs,SameProperties,The length of the statement  "	return field_1_font_height == other.field_1_font_height && field_2_attributes == other.field_2_attributes && field_3_color_palette_index == other.field_3_color_palette_index && field_4_bold_weight == other.field_4_bold_weight && field_5_base_sub_script == other.field_5_base_sub_script && field_6_underline == other.field_6_underline && field_7_family == other.field_7_family && field_8_charset == other.field_8_charset && field_9_zero == other.field_9_zero && field_11_font_name.Equals (other.field_11_font_name); " is 514.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Length of menu text (Char count)        = ").Append (field_14_custom_menu_text.Length).Append ("\n"); " is 122.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Length of description text (Char count) = ").Append (field_15_description_text.Length).Append ("\n"); " is 122.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Length of help topic text (Char count)  = ").Append (field_16_help_topic_text.Length).Append ("\n"); " is 121.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Length of status bar text (Char count)  = ").Append (field_17_status_bar_text.Length).Append ("\n"); " is 121.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Menu text (Unicode string without Length field)        = ").Append (field_14_custom_menu_text).Append ("\n"); " is 130.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Description text (Unicode string without Length field) = ").Append (field_15_description_text).Append ("\n"); " is 130.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Help topic text (Unicode string without Length field)  = ").Append (field_16_help_topic_text).Append ("\n"); " is 129.
Long Statement,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .Status bar text (Unicode string without Length field)  = ").Append (field_17_status_bar_text).Append ("\n"); " is 129.
Long Statement,NPOI.HSSF.Record,PaneRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaneRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .x                    = ").Append ("0x").Append (HexDump.ToHex (X)).Append (" (").Append (X).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record,PaneRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaneRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .y                    = ").Append ("0x").Append (HexDump.ToHex (Y)).Append (" (").Append (Y).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record,PaneRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaneRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .topRow               = ").Append ("0x").Append (HexDump.ToHex (TopRow)).Append (" (").Append (TopRow).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record,PaneRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaneRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .leftColumn           = ").Append ("0x").Append (HexDump.ToHex (LeftColumn)).Append (" (").Append (LeftColumn).Append (" )"); " is 145.
Long Statement,NPOI.HSSF.Record,PaneRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaneRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .activePane           = ").Append ("0x").Append (HexDump.ToHex (ActivePane)).Append (" (").Append (ActivePane).Append (" )"); " is 145.
Long Statement,NPOI.HSSF.Record,RecordFactory,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordFactory.cs,RecordsToMap,The length of the statement  "			throw new RuntimeException ("duplicate record sid 0x" + sid.ToString ("X"' CultureInfo.CurrentCulture) + " for classes (" + recClass.Name + ") and (" + prevClass.Name + ")"); " is 174.
Long Statement,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,CheckRecordPosition,The length of the statement  "	throw new RecordFormatException ("Not enough data (" + nAvailable + ") to read requested (" + requiredByteCount + ") bytes"); " is 125.
Long Statement,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,ReadStringCommon,The length of the statement  "			throw new RecordFormatException ("Expected to find a ContinueRecord in order to read remaining " + (requestedLength - curLen) + " of " + requestedLength + " chars"); " is 165.
Long Statement,NPOI.HSSF.Record,SCLRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SCLRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .numerator            = ").Append ("0x").Append (HexDump.ToHex (Numerator)).Append (" (").Append (Numerator).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record,SCLRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SCLRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .denominator          = ").Append ("0x").Append (HexDump.ToHex (Denominator)).Append (" (").Append (Denominator).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record,SSTRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SSTRecord.cs,Equals,The length of the statement  "	return ((field_1_num_strings == other.field_1_num_strings) && (field_2_num_unique_strings == other.field_2_num_unique_strings) && field_3_strings.Equals (other.field_3_strings)); " is 178.
Long Statement,NPOI.HSSF.Record,StandardRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\StandardRecord.cs,Serialize,The length of the statement  "		throw new InvalidOperationException ("Error in serialization of (" + this.GetType ().Name + "): " + "Incorrect number of bytes written - expected " + recSize + " but got " + (out1.WriteIndex - offset)); " is 202.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .objectType           = ").Append ("0x").Append (HexDump.ToHex ((short)ObjectType)).Append (" (").Append (ObjectType).Append (" )"); " is 152.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .objectId             = ").Append ("0x").Append (HexDump.ToHex (ObjectId)).Append (" (").Append (ObjectId).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .option               = ").Append ("0x").Append (HexDump.ToHex (Option)).Append (" (").Append (Option).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved1            = ").Append ("0x").Append (HexDump.ToHex (Reserved1)).Append (" (").Append (Reserved1).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved2            = ").Append ("0x").Append (HexDump.ToHex (Reserved2)).Append (" (").Append (Reserved2).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved3            = ").Append ("0x").Append (HexDump.ToHex (Reserved3)).Append (" (").Append (Reserved3).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The length of the statement  "		out1.WriteByte (field_4_unknownByte == null ? 0x00 : (int)Convert.ToByte (field_4_unknownByte' CultureInfo.InvariantCulture)); " is 126.
Long Statement,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,ToString,The length of the statement  "		sb.Append ("    .f4unknown   = ").Append (HexDump.ByteToHex (Convert.ToByte (field_4_unknownByte' CultureInfo.InvariantCulture))).Append ("\n"); " is 144.
Long Statement,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,ToString,The length of the statement  "		sb.Append ("    .streamId      = ").Append (HexDump.IntToHex (Convert.ToInt32 (field_5_stream_id' CultureInfo.InvariantCulture))).Append ("\n"); " is 144.
Long Statement,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The length of the statement  "	return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0)); " is 139.
Long Statement,NPOI.HSSF.UserModel,DVConstraint,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\DVConstraint.cs,ConvertDate,The length of the statement  "			throw new InvalidOperationException ("Failed to parse date '" + dateStr + "' using specified format '" + dateFormat + "'"' e); " is 126.
Long Statement,NPOI.HSSF.UserModel,DVConstraint,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\DVConstraint.cs,CreateListFormula,The length of the statement  "		return HSSFFormulaParser.Parse (_formula1' (HSSFWorkbook)wb' FormulaType.DATAVALIDATION_LIST' wb.GetSheetIndex (sheet)); " is 120.
Long Statement,NPOI.HSSF.UserModel,HSSFDataValidation,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFDataValidation.cs,CreateDVRecord,The length of the statement  "	return new DVRecord (_constraint.GetValidationType ()' _constraint.Operator' _errorStyle' _emptyCellAllowed' SuppressDropDownArrow' _constraint.GetValidationType () == ValidationType.LIST && _constraint.ExplicitListValues != null' _ShowPromptBox' _prompt_title' _prompt_text' _ShowErrorBox' _error_title' _error_text' fp.Formula1' fp.Formula2' _regions); " is 354.
Long Statement,NPOI.HSSF.UserModel,HSSFErrorConstants,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFErrorConstants.cs,IsValidCode,The length of the statement  "	if (errorCode == ERROR_NULL || errorCode == ERROR_DIV_0 || errorCode == ERROR_VALUE || errorCode == ERROR_REF || errorCode == ERROR_NAME || errorCode == ERROR_NUM || errorCode == ERROR_NA) { " is 190.
Long Statement,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The length of the statement  "	using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) { " is 145.
Long Statement,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,MatchFont,The length of the statement  "	HSSFColor hssfColor = workbook.GetCustomPalette ().FindColor ((byte)foreground.R' (byte)foreground.G' (byte)foreground.B); " is 122.
Long Statement,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,MatchFont,The length of the statement  "	HSSFFont hssfFont = (HSSFFont)workbook.FindFont (bold ? (short)NPOI.SS.UserModel.FontBoldWeight.BOLD : (short)NPOI.SS.UserModel.FontBoldWeight.NORMAL' hssfColor.GetIndex ()' (short)(font.Size * 20)' font.Name' italic' false' (short)NPOI.SS.UserModel.FontSuperScript.NONE' (byte)NPOI.SS.UserModel.FontUnderlineType.NONE); " is 320.
Long Statement,NPOI.HSSF.UserModel,EvaluationCycleDetector,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EvaluationCycleDetector.cs,EndEvaluate,The length of the statement  "		throw new Exception ("Wrong cell specified. " + "Corresponding startEvaluate() call was for cell {" + cefExpected.FormatAsString () + "} this endEvaluate() call Is for cell {" + cefActual.FormatAsString () + "}"); " is 213.
Long Statement,NPOI.HSSF.UserModel,FontDetails,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\FontDetails.cs,Create,The length of the statement  "		throw new ArgumentException ("The supplied FontMetrics doesn't know about the font '" + fontName + "'' so we can't use it. Please Add it to your font metrics file (see StaticFontMetrics.GetFontDetails"); " is 203.
Long Statement,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,TypeMismatch,The length of the statement  "	String msg = "Cannot get a " + GetCellTypeName (expectedTypeCode) + " value from a " + GetCellTypeName (actualTypeCode) + " " + (isFormulaCell ? "formula " : "") + "cell"; " is 171.
Long Statement,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,CheckBounds,The length of the statement  "		throw new ArgumentException ("Invalid column index (" + cellIndex + ").  Allowable column range for " + FILE_FORMAT_NAME + " is (0.." + LAST_COLUMN_NUMBER + ") or ('A'..'" + LAST_COLUMN_NAME + "')"); " is 199.
Long Statement,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The length of the statement  "		if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) { " is 134.
Long Statement,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,NotifyArrayFormulaChanging,The length of the statement  "	String msg = "Cell " + ref1.FormatAsString () + " is part of a multi-cell array formula. " + "You cannot change part of an array."; " is 131.
Long Statement,NPOI.HSSF.UserModel,HSSFCellStyle,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCellStyle.cs,VerifyBelongsToWorkbook,The length of the statement  "		throw new ArgumentException ("This Style does not belong to the supplied Workbook. Are you trying to assign a style from one workbook to the cell of a differnt workbook?"); " is 172.
Long Statement,NPOI.HSSF.UserModel,HSSFCellStyle,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCellStyle.cs,CloneStyleFrom,The length of the statement  "		throw new ArgumentException ("Can only clone from one HSSFCellStyle to another' not between HSSFCellStyle and XSSFCellStyle"); " is 126.
Long Statement,NPOI.HSSF.UserModel,HSSFEvaluationCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFEvaluationCell.cs,Equals,The length of the statement  "	return _cell.RowIndex == cellb.RowIndex && _cell.ColumnIndex == cellb.ColumnIndex && _cell.CellFormula == cellb.CellFormula && _cell.Sheet == cellb.Sheet; " is 154.
Long Statement,NPOI.HSSF.UserModel,HSSFName,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFName.cs,ValidateName,The length of the statement  "		throw new ArgumentException ("Invalid name: '" + name + "'; Names must begin with a letter or underscore and not contain spaces"); " is 130.
Long Statement,NPOI.HSSF.UserModel,HSSFPalette,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPalette.cs,AddColor,The length of the statement  "	for (i = (short)PaletteRecord.FIRST_COLOR_INDEX; i < PaletteRecord.STANDARD_PALETTE_SIZE + PaletteRecord.FIRST_COLOR_INDEX; b = palette.GetColor (++i)) { " is 153.
Long Statement,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetResolution,The length of the statement  "	//if (lst != null && lst.GetLength == 1) hdpi = (int)(mm2inch / Float.ParseFloat(((Element)lst.item(0)).GetAttribute("value"))); " is 128.
Long Statement,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetResolution,The length of the statement  "	//if (lst != null && lst.GetLength == 1) vdpi = (int)(mm2inch / Float.ParseFloat(((Element)lst.item(0)).GetAttribute("value"))); " is 128.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,RemoveRow,The length of the statement  "			String msg = "Row[rownum=" + row.RowNum + "] contains cell(s) included in a multi-cell array formula. You cannot change part of an array."; " is 139.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ValidateArrayFormulas,The length of the statement  "				if (arrayRange.NumberOfCells > 1 && (arrayRange.IsInRange (region.FirstRow' region.FirstColumn) || arrayRange.IsInRange (region.FirstRow' region.FirstColumn))) { " is 161.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ValidateArrayFormulas,The length of the statement  "					String msg = "The range " + region.FormatAsString () + " intersects with a multi-cell array formula. " + "You cannot merge cells of an array."; " is 143.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,The length of the statement  "	//if (endRow == lastrow || endRow + n > lastrow) lastrow = Math.Min(endRow + n' SpreadsheetVersion.EXCEL97.LastRowIndex); " is 121.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,NotifyRowShifting,The length of the statement  "	String msg = "Row[rownum=" + row.RowNum + "] contains cell(s) included in a multi-cell array formula. " + "You cannot change part of an array."; " is 144.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,IsMergedRegion,The length of the statement  "		if (range.FirstColumn <= mergedRegion.FirstColumn && range.LastColumn >= mergedRegion.LastColumn && range.FirstRow <= mergedRegion.FirstRow && range.LastRow >= mergedRegion.LastRow) { " is 183.
Long Statement,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetAutoFilter,The length of the statement  "	Area3DPtg ptg = new Area3DPtg (range.FirstRow' range.LastRow' range.FirstColumn' range.LastColumn' false' false' false' false' sheetIndex); " is 139.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetWorkbookDirEntryName,The length of the statement  "		throw new OldExcelFormatException ("The supplied spreadsheet seems to be Excel 5.0/7.0 (BIFF5) format. " + "POI only supports BIFF8 format (from Excel versions 97/2000/XP/2003)"); " is 179.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetWorkbookDirEntryName,The length of the statement  "	throw new ArgumentException ("The supplied POIFSFileSystem does not contain a BIFF8 'Workbook' entry. " + "Is it really an excel file?"); " is 137.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The length of the statement  "	//        Console.WriteLine( boldWeight + "' " + color + "' " + fontHeight + "' " + name + "' " + italic + "' " + strikeout + "' " + typeOffset + "' " + Underline ); " is 165.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The length of the statement  "		//            Console.WriteLine( hssfFont.GetBoldweight() + "' " + hssfFont.GetColor() + "' " + hssfFont.FontHeight + "' " + hssfFont.FontName + "' " + hssfFont.GetItalic() + "' " + hssfFont.GetStrikeout() + "' " + hssfFont.GetTypeOffset() + "' " + hssfFont.Underline ); " is 270.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The length of the statement  "		if (hssfFont.Boldweight == boldWeight && hssfFont.Color == color && hssfFont.FontHeight == fontHeight && hssfFont.FontName.Equals (name) && hssfFont.IsItalic == italic && hssfFont.IsStrikeout == strikeout && hssfFont.TypeOffset == typeOffset && hssfFont.Underline == Underline) { " is 279.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,CreateCellStyle,The length of the statement  "		throw new InvalidOperationException ("The maximum number of cell styles was exceeded. " + "You can define up to 4000 styles in a .xls workbook"); " is 145.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetBytes,The length of the statement  "			throw new InvalidOperationException ("Actual serialized sheet size (" + serializedSize + ") differs from pre-calculated size (" + src.TotalSize + ") for sheet (" + k + ")"); " is 173.
Long Statement,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetBytes,The length of the statement  "			// TODO - Add similar sanity Check to Ensure that Sheet.SerializeIndexRecord() does not Write mis-aligned offsets either " is 120.
Long Statement,NPOI.HSSF.UserModel,StaticFontMetrics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\StaticFontMetrics.cs,GetFontDetails,The length of the statement  "	if (fontMetricsProps [FontDetails.BuildFontHeightProperty (fontName)] == null && fontMetricsProps [FontDetails.BuildFontHeightProperty (fontName + "." + fontStyle)] != null) { " is 175.
Long Statement,NPOI.HSSF.Util,HSSFColor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFColor.cs,CreateColorsByIndexMap,The length of the statement  "			throw new InvalidDataException ("Dup color index (" + index1 + ") for colors (" + prevColor.GetType ().Name + ")'(" + color.GetType ().Name + ")"); " is 147.
Long Statement,NPOI.HPSF,CustomProperties,C:\repos\xoposhiy_npoi\trunk\main\HPSF\CustomProperties.cs,Put,The length of the statement  "		throw new ArgumentException ("The name of a custom property must " + "be a String' but it is a " + name.GetType ().Name); " is 121.
Long Statement,NPOI.HPSF,CustomProperties,C:\repos\xoposhiy_npoi\trunk\main\HPSF\CustomProperties.cs,Put,The length of the statement  "		throw new ArgumentException ("Parameter \"name\" (" + name + ") and custom property's name (" + cp.Name + ") do not match."); " is 125.
Long Statement,NPOI.HPSF,CustomProperties,C:\repos\xoposhiy_npoi\trunk\main\HPSF\CustomProperties.cs,Put,The length of the statement  "	/* Register name and ID in the dictionary. Mapping in both directions is possible. If there is alReady a  */long idKey = cp.ID; " is 127.
Long Statement,NPOI.HPSF,DocumentSummaryInformation,C:\repos\xoposhiy_npoi\trunk\main\HPSF\DocumentSummaryInformation.cs,RemoveCustomProperties,The length of the statement  "		throw new HPSFRuntimeException ("Illegal internal format of Document SummaryInformation stream: second section is missing."); " is 125.
Long Statement,NPOI.HPSF,MutableProperty,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableProperty.cs,Write,The length of the statement  "	/* Ensure that wide strings are written if the codepage is Unicode. */if (codepage == (int)Constants.CP_UNICODE && variantType == Variant.VT_LPSTR) " is 147.
Long Statement,NPOI.HPSF,MutablePropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutablePropertySet.cs,Write,The length of the statement  "             * section's offset relative To the beginning of the stream. */offset += nrSections * (ClassID.Length + LittleEndianConsts.INT_SIZE); " is 132.
Long Statement,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The length of the statement  "                     * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE; " is 121.
Long Statement,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The length of the statement  "                             * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE); " is 136.
Long Statement,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The length of the statement  "			/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length); " is 124.
Long Statement,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The length of the statement  "		l.Log (POILogger.WARN' "The property Set's dictionary Contains bogus data. " + "All dictionary entries starting with the one with ID " + id + " will be ignored."' ex); " is 167.
Long Statement,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,TypesAreEqual,The length of the statement  "	if (t1 == t2 || (t1 == Variant.VT_LPSTR && t2 == Variant.VT_LPWSTR) || (t2 == Variant.VT_LPSTR && t1 == Variant.VT_LPWSTR)) " is 123.
Long Statement,NPOI.HPSF,PropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\PropertySet.cs,Equals,The length of the statement  "	if (byteOrder1 != byteOrder2 || !classID1.Equals (classID2) || format1 != format2 || osVersion1 != osVersion2 || sectionCount1 != sectionCount2) " is 144.
Long Statement,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The length of the statement  "		value = codepage != -1 ? Encoding.GetEncoding (codepage).GetString (src' first' l) : Encoding.UTF8.GetString (src' first' l); " is 125.
Long Statement,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The length of the statement  "		byte[] bytes = (codepage == -1 ? Encoding.UTF8.GetBytes ((string)value) : Encoding.GetEncoding (codepage).GetBytes ((string)value)); " is 132.
Long Statement,NPOI.HSSF.EventUserModel,FormatTrackingHSSFListener,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\FormatTrackingHSSFListener.cs,GetFormatIndex,The length of the statement  "		Console.Error.WriteLine ("Cell " + cell.Row + "'" + cell.Column + " uses XF with index " + cell.XFIndex + "' but we don't have that"); " is 134.
Long Statement,NPOI.HSSF.Model,CommentShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\CommentShape.cs,AddStandardOptions,The length of the statement  "	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.GROUPSHAPE__PRINT' comment.Visible ? 0x000A0000 : 0x000A0002)); " is 129.
Long Statement,NPOI.HSSF.Model,LineShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LineShape.cs,CreateSpContainer,The length of the statement  "	opt.AddEscherProperty (new EscherShapePathProperty (EscherProperties.GEOMETRY__SHAPEPATH' EscherShapePathProperty.COMPLEX)); " is 124.
Long Statement,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,GetExternalSheetIndex,The length of the statement  "		throw new InvalidOperationException ("ExternSheetRecord does not contain combination (" + externalBookIndex + "' " + sheetIndex + ")"); " is 135.
Long Statement,NPOI.HSSF.Model,PictureShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PictureShape.cs,CreateSpContainer,The length of the statement  "	//        opt.AddEscherProperty( new EscherBoolProperty( EscherProperties.PROTECTION__LOCKAGAINSTGROUPING' 0x00800080 ) ; " is 121.
Long Statement,NPOI.HSSF.Model,PictureShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PictureShape.cs,CreateSpContainer,The length of the statement  "	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.BLIP__BLIPTODISPLAY' false' true' shape.PictureIndex)); " is 121.
Long Statement,NPOI.HSSF.Model,PictureShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PictureShape.cs,CreateSpContainer,The length of the statement  "	//        opt.AddEscherProperty( new EscherComplexProperty( EscherProperties.BLIP__BLIPFILENAME' true' new byte[] { (byte)0x74' (byte)0x00' (byte)0x65' (byte)0x00' (byte)0x73' (byte)0x00' (byte)0x74' (byte)0x00' (byte)0x00' (byte)0x00 } ) ; " is 240.
Long Statement,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The length of the statement  "	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.GEOMETRY__RIGHT' false' false' hssfShape.DrawAreaWidth)); " is 123.
Long Statement,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The length of the statement  "	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.GEOMETRY__BOTTOM' false' false' hssfShape.DrawAreaHeight)); " is 125.
Long Statement,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The length of the statement  "	opt.AddEscherProperty (new EscherShapePathProperty (EscherProperties.GEOMETRY__SHAPEPATH' EscherShapePathProperty.COMPLEX)); " is 124.
Long Statement,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindDataValidationTableInsertPos,The length of the statement  "				throw new InvalidOperationException ("Unexpected (" + nextRec.GetType ().Name + ") found after (" + rb.GetType ().Name + ")"); " is 126.
Long Statement,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,AggregateDrawingRecords,The length of the statement  "		while (loc + 1 < records.Count && records [loc] is DrawingRecord && (records [loc + 1] is ObjRecord || records [loc + 1] is TextObjectRecord)) { " is 144.
Long Statement,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The length of the statement  "			retval.maxformatid = retval.maxformatid >= ((FormatRecord)rec).IndexCode ? retval.maxformatid : ((FormatRecord)rec).IndexCode; " is 126.
Long Statement,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The length of the statement  "		retval.maxformatid = retval.maxformatid >= ((FormatRecord)rec).IndexCode ? retval.maxformatid : ((FormatRecord)rec).IndexCode; " is 126.
Long Statement,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,Serialize,The length of the statement  "			//                    throw new InvalidOperationException("Record size does not match Serialized bytes.  Serialized size = " + len + " but RecordSize returns " + record.RecordSize); " is 181.
Long Statement,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,Intersect,The length of the statement  "	if (gt (crA.FirstRow' lastRow) || lt (crA.LastRow' firstRow) || gt (crA.FirstColumn' lastCol) || lt (crA.LastColumn' firstCol)) { " is 129.
Long Statement,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,Contains,The length of the statement  "	return le (crA.FirstRow' firstRow) && ge (crA.LastRow' lastRow) && le (crA.FirstColumn' firstCol) && ge (crA.LastColumn' lastCol); " is 130.
Long Statement,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,CreateEnclosingCellRange,The length of the statement  "	return new CellRangeAddress (lt (crB.FirstRow' crA.FirstRow) ? crB.FirstRow : crA.FirstRow' gt (crB.LastRow' crA.LastRow) ? crB.LastRow : crA.LastRow' lt (crB.FirstColumn' crA.FirstColumn) ? crB.FirstColumn : crA.FirstColumn' gt (crB.LastColumn' crA.LastColumn) ? crB.LastColumn : crA.LastColumn); " is 297.
Long Statement,NPOI.HSSF.Record.CF,FontFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\FontFormatting.cs,ToString,The length of the statement  "		buffer.Append ("	.font weight = ").Append (FontWeight).Append (FontWeight == FONT_WEIGHT_NORMAL ? "(Normal)" : FontWeight == FONT_WEIGHT_BOLD ? "(Bold)" : "0x" + StringUtil.ToHexString (FontWeight)).Append ("\n"); " is 213.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .foregroundColor      = ").Append ("0x").Append (HexDump.ToHex (ForegroundColor)).Append (" (").Append (ForegroundColor).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .backgroundColor      = ").Append ("0x").Append (HexDump.ToHex (BackgroundColor)).Append (" (").Append (BackgroundColor).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .pattern              = ").Append ("0x").Append (HexDump.ToHex (Pattern)).Append (" (").Append (Pattern).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatFlags          = ").Append ("0x").Append (HexDump.ToHex (FormatFlags)).Append (" (").Append (FormatFlags).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .forecolorIndex       = ").Append ("0x").Append (HexDump.ToHex (ForecolorIndex)).Append (" (").Append (ForecolorIndex).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,AreaFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .backcolorIndex       = ").Append ("0x").Append (HexDump.ToHex (BackcolorIndex)).Append (" (").Append (BackcolorIndex).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,AreaRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AreaRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatFlags          = ").Append ("0x").Append (HexDump.ToHex (FormatFlags)).Append (" (").Append (FormatFlags).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,AxisLineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisLineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .axisType             = ").Append ("0x").Append (HexDump.ToHex (AxisType)).Append (" (").Append (AxisType).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .minimumCategory      = ").Append ("0x").Append (HexDump.ToHex (MinimumCategory)).Append (" (").Append (MinimumCategory).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .maximumCategory      = ").Append ("0x").Append (HexDump.ToHex (MaximumCategory)).Append (" (").Append (MaximumCategory).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .majorUnitValue       = ").Append ("0x").Append (HexDump.ToHex (MajorUnitValue)).Append (" (").Append (MajorUnitValue).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .majorUnit            = ").Append ("0x").Append (HexDump.ToHex (MajorUnit)).Append (" (").Append (MajorUnit).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .minorUnitValue       = ").Append ("0x").Append (HexDump.ToHex (MinorUnitValue)).Append (" (").Append (MinorUnitValue).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .minorUnit            = ").Append ("0x").Append (HexDump.ToHex (MinorUnit)).Append (" (").Append (MinorUnit).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .baseUnit             = ").Append ("0x").Append (HexDump.ToHex (BaseUnit)).Append (" (").Append (BaseUnit).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .crossingPoint        = ").Append ("0x").Append (HexDump.ToHex (CrossingPoint)).Append (" (").Append (CrossingPoint).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record.Chart,AxisOptionsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisOptionsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,AxisParentRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisParentRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .axisType             = ").Append ("0x").Append (HexDump.ToHex (AxisType)).Append (" (").Append (AxisType).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,AxisParentRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisParentRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .x                    = ").Append ("0x").Append (HexDump.ToHex (X)).Append (" (").Append (X).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record.Chart,AxisParentRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisParentRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .y                    = ").Append ("0x").Append (HexDump.ToHex (Y)).Append (" (").Append (Y).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record.Chart,AxisParentRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisParentRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .width                = ").Append ("0x").Append (HexDump.ToHex (Width)).Append (" (").Append (Width).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,AxisParentRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisParentRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .height               = ").Append ("0x").Append (HexDump.ToHex (Height)).Append (" (").Append (Height).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,AxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .axisType             = ").Append ("0x").Append (HexDump.ToHex (AxisType)).Append (" (").Append (AxisType).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,AxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved1            = ").Append ("0x").Append (HexDump.ToHex (Reserved1)).Append (" (").Append (Reserved1).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved2            = ").Append ("0x").Append (HexDump.ToHex (Reserved2)).Append (" (").Append (Reserved2).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved3            = ").Append ("0x").Append (HexDump.ToHex (Reserved3)).Append (" (").Append (Reserved3).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .reserved4            = ").Append ("0x").Append (HexDump.ToHex (Reserved4)).Append (" (").Append (Reserved4).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,AxisUsedRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\AxisUsedRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .numAxis              = ").Append ("0x").Append (HexDump.ToHex (this.NumAxis)).Append (" (").Append (this.NumAxis).Append (" )"); " is 149.
Long Statement,NPOI.HSSF.Record.Chart,BarRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\BarRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .barSpace             = ").Append ("0x").Append (HexDump.ToHex (BarSpace)).Append (" (").Append (BarSpace).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,BarRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\BarRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .categorySpace        = ").Append ("0x").Append (HexDump.ToHex (CategorySpace)).Append (" (").Append (CategorySpace).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record.Chart,BarRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\BarRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatFlags          = ").Append ("0x").Append (HexDump.ToHex (FormatFlags)).Append (" (").Append (FormatFlags).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,CategorySeriesAxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\CategorySeriesAxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .crossingPoint        = ").Append ("0x").Append (HexDump.ToHex (CrossingPoint)).Append (" (").Append (CrossingPoint).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record.Chart,CategorySeriesAxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\CategorySeriesAxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .labelFrequency       = ").Append ("0x").Append (HexDump.ToHex (LabelFrequency)).Append (" (").Append (LabelFrequency).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,CategorySeriesAxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\CategorySeriesAxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .tickMarkFrequency    = ").Append ("0x").Append (HexDump.ToHex (TickMarkFrequency)).Append (" (").Append (TickMarkFrequency).Append (" )"); " is 159.
Long Statement,NPOI.HSSF.Record.Chart,CategorySeriesAxisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\CategorySeriesAxisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,Chart3DBarShapeRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\Chart3DBarShape.cs,ToString,The length of the statement  "	buffer.Append ("    .axisType             = ").Append ("0x").Append (HexDump.ToHex (Riser)).Append (" (").Append (Riser).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,Chart3DBarShapeRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\Chart3DBarShape.cs,ToString,The length of the statement  "	buffer.Append ("    .x                    = ").Append ("0x").Append (HexDump.ToHex (Taper)).Append (" (").Append (Taper).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,ChartRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .x                    = ").Append ("0x").Append (HexDump.ToHex (X)).Append (" (").Append (X).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record.Chart,ChartRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .y                    = ").Append ("0x").Append (HexDump.ToHex (Y)).Append (" (").Append (Y).Append (" )"); " is 127.
Long Statement,NPOI.HSSF.Record.Chart,ChartRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .width                = ").Append ("0x").Append (HexDump.ToHex (Width)).Append (" (").Append (Width).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,ChartRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .height               = ").Append ("0x").Append (HexDump.ToHex (Height)).Append (" (").Append (Height).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,DataFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DataFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .pointNumber          = ").Append ("0x").Append (HexDump.ToHex (PointNumber)).Append (" (").Append (PointNumber).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,DataFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DataFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .seriesIndex          = ").Append ("0x").Append (HexDump.ToHex (SeriesIndex)).Append (" (").Append (SeriesIndex).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,DataFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DataFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .seriesNumber         = ").Append ("0x").Append (HexDump.ToHex (SeriesNumber)).Append (" (").Append (SeriesNumber).Append (" )"); " is 149.
Long Statement,NPOI.HSSF.Record.Chart,DataFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DataFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatFlags          = ").Append ("0x").Append (HexDump.ToHex (FormatFlags)).Append (" (").Append (FormatFlags).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,DatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,DefaultDataLabelTextPropertiesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\DefaultDataLabelTextPropertiesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .categoryDataType     = ").Append ("0x").Append (HexDump.ToHex ((short)CategoryDataType)).Append (" (").Append (CategoryDataType).Append (" )"); " is 164.
Long Statement,NPOI.HSSF.Record.Chart,FontBasisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontBasisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .xBasis               = ").Append ("0x").Append (HexDump.ToHex (XBasis)).Append (" (").Append (XBasis).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,FontBasisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontBasisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .yBasis               = ").Append ("0x").Append (HexDump.ToHex (YBasis)).Append (" (").Append (YBasis).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,FontBasisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontBasisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .heightBasis          = ").Append ("0x").Append (HexDump.ToHex (HeightBasis)).Append (" (").Append (HeightBasis).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,FontBasisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontBasisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .scale                = ").Append ("0x").Append (HexDump.ToHex (Scale)).Append (" (").Append (Scale).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,FontBasisRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontBasisRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .indexToFontTable     = ").Append ("0x").Append (HexDump.ToHex (IndexToFontTable)).Append (" (").Append (IndexToFontTable).Append (" )"); " is 157.
Long Statement,NPOI.HSSF.Record.Chart,FontIndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FontIndexRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .fontIndex            = ").Append ("0x").Append (HexDump.ToHex (FontIndex)).Append (" (").Append (FontIndex).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,FrameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FrameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .borderType           = ").Append ("0x").Append (HexDump.ToHex (BorderType)).Append (" (").Append (BorderType).Append (" )"); " is 145.
Long Statement,NPOI.HSSF.Record.Chart,FrameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\FrameRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .xAxisUpperLeft       = ").Append ("0x").Append (HexDump.ToHex (XAxisUpperLeft)).Append (" (").Append (XAxisUpperLeft).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .yAxisUpperLeft       = ").Append ("0x").Append (HexDump.ToHex (YAxisUpperLeft)).Append (" (").Append (YAxisUpperLeft).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .xSize                = ").Append ("0x").Append (HexDump.ToHex (XSize)).Append (" (").Append (XSize).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .ySize                = ").Append ("0x").Append (HexDump.ToHex (YSize)).Append (" (").Append (YSize).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .type                 = ").Append ("0x").Append (HexDump.ToHex (Type)).Append (" (").Append (Type).Append (" )"); " is 133.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .spacing              = ").Append ("0x").Append (HexDump.ToHex (Spacing)).Append (" (").Append (Spacing).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,LegendRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LegendRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.HSSF.Record.Chart,LineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .lineColor            = ").Append ("0x").Append (HexDump.ToHex (LineColor)).Append (" (").Append (LineColor).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,LineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .linePattern          = ").Append ("0x").Append (HexDump.ToHex (LinePattern)).Append (" (").Append (LinePattern).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,LineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .weight               = ").Append ("0x").Append (HexDump.ToHex (Weight)).Append (" (").Append (Weight).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,LineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .format               = ").Append ("0x").Append (HexDump.ToHex (Format)).Append (" (").Append (Format).Append (" )"); " is 137.
Long Statement,NPOI.HSSF.Record.Chart,LineFormatRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\LineFormatRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .colourPaletteIndex   = ").Append ("0x").Append (HexDump.ToHex (ColourPaletteIndex)).Append (" (").Append (ColourPaletteIndex).Append (" )"); " is 161.
Long Statement,NPOI.HSSF.Record.Chart,NumberFormatIndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\NumberFormatIndexRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatIndex          = ").Append ("0x").Append (HexDump.ToHex (FormatIndex)).Append (" (").Append (FormatIndex).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,ObjectLinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ObjectLinkRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .AnchorId             = ").Append ("0x").Append (HexDump.ToHex (AnchorId)).Append (" (").Append (AnchorId).Append (" )"); " is 141.
Long Statement,NPOI.HSSF.Record.Chart,ObjectLinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ObjectLinkRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .link1                = ").Append ("0x").Append (HexDump.ToHex (Link1)).Append (" (").Append (Link1).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,ObjectLinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ObjectLinkRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .link2                = ").Append ("0x").Append (HexDump.ToHex (Link2)).Append (" (").Append (Link2).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,PlotGrowthRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\PlotGrowthRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .horizontalScale      = ").Append ("0x").Append (HexDump.ToHex (HorizontalScale)).Append (" (").Append (HorizontalScale).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,PlotGrowthRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\PlotGrowthRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .verticalScale        = ").Append ("0x").Append (HexDump.ToHex (VerticalScale)).Append (" (").Append (VerticalScale).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record.Chart,SeriesChartGroupIndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesChartGroupIndexRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .chartGroupIndex      = ").Append ("0x").Append (HexDump.ToHex (ChartGroupIndex)).Append (" (").Append (ChartGroupIndex).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,SeriesIndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesIndexRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .index                = ").Append ("0x").Append (HexDump.ToHex (Index)).Append (" (").Append (Index).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,SeriesLabelsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesLabelsRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .formatFlags          = ").Append ("0x").Append (HexDump.ToHex (FormatFlags)).Append (" (").Append (FormatFlags).Append (" )"); " is 147.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .categoryDataType     = ").Append ("0x").Append (HexDump.ToHex (CategoryDataType)).Append (" (").Append (CategoryDataType).Append (" )"); " is 157.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .valuesDataType       = ").Append ("0x").Append (HexDump.ToHex (ValuesDataType)).Append (" (").Append (ValuesDataType).Append (" )"); " is 153.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .numCategories        = ").Append ("0x").Append (HexDump.ToHex (NumCategories)).Append (" (").Append (NumCategories).Append (" )"); " is 151.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .numValues            = ").Append ("0x").Append (HexDump.ToHex (NumValues)).Append (" (").Append (NumValues).Append (" )"); " is 143.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .bubbleSeriesType     = ").Append ("0x").Append (HexDump.ToHex (BubbleSeriesType)).Append (" (").Append (BubbleSeriesType).Append (" )"); " is 157.
Long Statement,NPOI.HSSF.Record.Chart,SeriesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .numBubbleValues      = ").Append ("0x").Append (HexDump.ToHex (NumBubbleValues)).Append (" (").Append (NumBubbleValues).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,SeriesTextRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesTextRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .id                   = ").Append ("0x").Append (HexDump.ToHex (Id)).Append (" (").Append (Id).Append (" )"); " is 129.
Long Statement,NPOI.HSSF.Record.Chart,SeriesToChartGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SeriesToChartGroupRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .chartGroupIndex      = ").Append ("0x").Append (HexDump.ToHex (ChartGroupIndex)).Append (" (").Append (ChartGroupIndex).Append (" )"); " is 155.
Long Statement,NPOI.HSSF.Record.Chart,SheetPropertiesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SheetPropertiesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .flags                = ").Append ("0x").Append (HexDump.ToHex (Flags)).Append (" (").Append (Flags).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,SheetPropertiesRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\SheetPropertiesRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .empty                = ").Append ("0x").Append (HexDump.ToHex (Empty)).Append (" (").Append (Empty).Append (" )"); " is 135.
Long Statement,NPOI.HSSF.Record.Chart,ValueRangeRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ValueRangeRecord.cs,ToString,The length of the statement  "	buffer.Append ("    .options              = ").Append ("0x").Append (HexDump.ToHex (Options)).Append (" (").Append (Options).Append (" )"); " is 139.
Long Statement,NPOI.POIFS.Crypt,AgileDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\AgileDecryptor.cs,GetCipher,The length of the statement  "		if (algorithm == EncryptionHeader.ALGORITHM_AES_128 || algorithm == EncryptionHeader.ALGORITHM_AES_192 || algorithm == EncryptionHeader.ALGORITHM_AES_256) " is 154.
Long Statement,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The length of the statement  "		using (CryptoStream cStream = new CryptoStream (fStream' cipher.CreateDecryptor (cipher.Key' cipher.IV)' CryptoStreamMode.Read)) { " is 130.
Long Statement,NPOI.POIFS.EventFileSystem,POIFSReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\EventFileSystem\POIFSReader.cs,Read,The length of the statement  "	new BlockAllocationTableReader (header_block.BigBlockSize' header_block.BATCount' header_block.BATArray' header_block.XBATCount' header_block.XBATIndex' data_blocks); " is 166.
Long Statement,NPOI.POIFS.EventFileSystem,POIFSReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\EventFileSystem\POIFSReader.cs,Read,The length of the statement  "	return ProcessProperties (SmallBlockTableReader.GetSmallDocumentBlocks (header_block.BigBlockSize' data_blocks' properties.Root' header_block.SBATStart)' data_blocks' properties.Root.Children' new POIFSDocumentPath ()); " is 219.
Long Statement,NPOI.POIFS.FileSystem,ChainLoopDetector,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\BlockStore.cs,Claim,The length of the statement  "		throw new InvalidOperationException ("Potential loop detected - Block " + offset + " was already claimed but was just requested again"); " is 136.
Long Statement,NPOI.POIFS.FileSystem,NDocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NDocumentInputStream.cs,CheckAvaliable,The length of the statement  "		throw new Exception ("Buffer underrun - requested " + requestedSize + " bytes but " + (_document_size - _current_offset) + " was available"); " is 141.
Long Statement,NPOI.POIFS.FileSystem,NPOIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSFileSystem.cs,WriteFilesystem,The length of the statement  "		throw new ArgumentException ("POIFS opened from an inputstream' so WriteFilesystem() may " + "not be called. Use WriteFilesystem(OutputStream) instead"); " is 153.
Long Statement,NPOI.POIFS.FileSystem,ODocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\ODocumentInputStream.cs,CheckAvaliable,The length of the statement  "		throw new Exception ("Buffer underrun - requested " + requestedSize + " bytes but " + (_document_size - _current_offset) + " was available"); " is 141.
Long Statement,NPOI.POIFS.FileSystem,POIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\POIFSFileSystem.cs,CloseInputStream,The length of the statement  "		String msg = "POIFS is closing the supplied input stream of type (" + stream.GetType ().Name + ") which supports mark/reset.  " + "This will be a problem for the caller if the stream will still be used.  " + "If that is the case the caller should wrap the input stream to avoid this Close logic.  " + "This warning is only temporary and will not be present in future versions of POI."; " is 385.
Long Statement,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Read,The length of the statement  "		throw new IndexOutOfRangeException ("Unable to read " + length + " bytes from " + position + " in stream of length " + size); " is 125.
Long Statement,NPOI.SS.Formula.Atp,EDate,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\EDate.cs,Evaluate,The length of the statement  "		date = DateUtil.GetJavaDate (OperandResolver.CoerceValueToDouble (OperandResolver.GetSingleValue (args [0]' ec.RowIndex' ec.ColumnIndex))); " is 139.
Long Statement,NPOI.SS.Formula.Atp,EDate,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\EDate.cs,Evaluate,The length of the statement  "		numberOfMonths = OperandResolver.CoerceValueToDouble (OperandResolver.GetSingleValue (args [1]' ec.RowIndex' ec.ColumnIndex)); " is 126.
Long Statement,NPOI.SS.Formula.Atp,EDate,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\EDate.cs,Evaluate,The length of the statement  "		// calculate the result date (Excel rounds the second argument always to zero; but we have be careful about negative numbers) " is 125.
Long Statement,NPOI.SS.Formula.Atp,MRound,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\MRound.cs,Evaluate,The length of the statement  "		multiple = OperandResolver.CoerceValueToDouble (OperandResolver.GetSingleValue (args [1]' ec.RowIndex' ec.ColumnIndex)); " is 120.
Long Statement,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,CalculateAdjusted,The length of the statement  "	double dayCount = (endDate.year - startDate.year) * 360 + (endDate.month - startDate.month) * SHORT_MONTH_LEN + (date2day - date1day) * 1; " is 138.
Long Statement,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ParseInt,The length of the statement  "		throw new FormatException (fieldName + " value (" + result + ") is outside the allowable range(0.." + upperLimit + ")"); " is 120.
Long Statement,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,Divide,The length of the statement  "	MutableBigInteger q = new MutableBigInteger ()' a = new MutableBigInteger (this.mag)' b = new MutableBigInteger (val.mag); " is 122.
Long Statement,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulsub,The length of the statement  "		carry = Operator.UnsignedRightShift (product' 32) + (((difference & LONG_MASK) > (((~(int)product) & LONG_MASK))) ? 1 : 0); " is 123.
Long Statement,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The length of the statement  "			long product = (y._value [j + y.offset] & LONG_MASK) * (_value [i + offset] & LONG_MASK) + (z._value [k] & LONG_MASK) + carry; " is 126.
Long Statement,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The length of the statement  "		throw new ArrayTypeMismatchException ("Destination byte[] must have room for at least 16 bytes' " + "but has a length of only " + dst.Length + "."); " is 148.
Long Statement,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,FileCRC,The length of the statement  "	using (FileStream inFile = new System.IO.FileStream (sInputFilename' System.IO.FileMode.Open' System.IO.FileAccess.Read)) { " is 123.
Long Statement,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The length of the statement  "		string message = string.Format (CultureInfo.InvariantCulture' "illegal index: {0} into array of length {1}"' index' data.Length); " is 129.
Long Statement,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The length of the statement  "			byte[] info = System.Text.Encoding.UTF8.GetBytes (string.Format (CultureInfo.InvariantCulture' "No Data{0}"' Environment.NewLine)); " is 131.
Long Statement,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The length of the statement  "			string message = string.Format (CultureInfo.InvariantCulture' "illegal index: {0} into array of length {1}"' index' data.Length); " is 129.
Long Statement,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The length of the statement  "	return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0)); " is 139.
Long Statement,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,CheckPosition,The length of the statement  "		throw new RuntimeException (string.Format (CultureInfo.InvariantCulture' "Buffer overrun i={0};endIndex={1};writeIndex={2}"' i' _endIndex' _writeIndex)); " is 153.
Long Statement,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The length of the statement  "	return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0)); " is 139.
Long Statement,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The length of the statement  "	return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints) " is 161.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6)); " is 120.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7)); " is 135.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8)); " is 149.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6)' exception); " is 131.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7)' exception); " is 146.
Long Statement,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The length of the statement  "		Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8)' exception); " is 160.
Long Statement,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The length of the statement  "		if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) { " is 155.
Long Statement,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The length of the statement  "			throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)"); " is 253.
Long Statement,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The length of the statement  "		throw new IOException ("Invalid header signature; read " + LongToHex (signature) + "' expected " + LongToHex (_signature)); " is 123.
Long Statement,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,AlertShortRead,The length of the statement  "	return new IOException ("Unable to Read entire header; " + read + type + " Read; expected " + expectedReadSize + " bytes"); " is 123.
Long Statement,NPOI.POIFS.Storage,BATBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BATBlock.cs,CreateBATBlocks,The length of the statement  "		blocks [index++] = new BATBlock (bigBlockSize' entries' j' (remaining > _entries_per_block) ? j + _entries_per_block : entries.Length); " is 135.
Long Statement,NPOI.POIFS.Storage,BATBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BATBlock.cs,CreateXBATBlocks,The length of the statement  "			blocks [index++] = new BATBlock (bigBlockSize' entries' j' (remaining > _entries_per_xbat_block) ? j + _entries_per_xbat_block : entries.Length); " is 145.
Long Statement,NPOI.POIFS.Storage,BATBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BATBlock.cs,GetValueAt,The length of the statement  "		throw new IndexOutOfRangeException ("Unable to fetch offset " + relativeOffset + " as the " + "BAT only contains " + _values.Length + " entries"); " is 146.
Long Statement,NPOI.POIFS.Storage,BlockAllocationTableReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BlockAllocationTableReader.cs,FetchBlocks,The length of the statement  "				_logger.Log (POILogger.WARN' "Warning' incorrectly terminated empty data blocks in POIFS block listing (should end at -2' ended at 0)"); " is 136.
Long Statement,NPOI.POIFS.Storage,BlockAllocationTableWriter,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BlockAllocationTableWriter.cs,CreateBlocks,The length of the statement  "		int calculated_bat_blocks = BATBlock.CalculateStorageRequirements (_bigBlockSize' bat_blocks + xbat_blocks + _entries.Count); " is 125.
Long Statement,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The length of the statement  "	return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0)); " is 139.
Long Statement,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The length of the statement  "	return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0)); " is 139.
Long Statement,NPOI.POIFS.Storage,DocumentBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DocumentBlock.cs,Read,The length of the statement  "		Array.Copy (blocks [firstBlockIndex]._data' firstBlockOffSet' buffer' buffer_offset' POIFSConstants.BIG_BLOCK_SIZE - firstBlockOffSet); " is 135.
Long Statement,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,AlertShortRead,The length of the statement  "	throw new IOException ("Unable to Read entire header; " + read + type + " Read; expected " + expectedReadSize + " bytes"); " is 122.
Long Statement,NPOI.POIFS.Storage,HeaderBlockWriter,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockWriter.cs,CalculateXBATStorageRequirements,The length of the statement  "	return (blockCount > _max_bats_in_header) ? BATBlock.CalculateXBATStorageRequirements (bigBlockSize' blockCount - _max_bats_in_header) : 0; " is 139.
Long Statement,NPOI.POIFS.Storage,SmallBlockTableReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\SmallBlockTableReader.cs,GetSmallDocumentBlocks,The length of the statement  "	BlockList list = new SmallDocumentBlockList (SmallDocumentBlock.Extract (bigBlockSize' blockList.FetchBlocks (root.StartBlock' -1))); " is 133.
Long Statement,NPOI.POIFS.Storage,SmallDocumentBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\SmallDocumentBlock.cs,Read,The length of the statement  "		Array.Copy (((SmallDocumentBlock)blocks [firstBlockIndex])._data' firstBlockOffSet' buffer' buffer_offset' _block_size - firstBlockOffSet); " is 139.
Long Statement,NPOI.POIFS.Storage,SmallDocumentBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\SmallDocumentBlock.cs,Read,The length of the statement  "		Array.Copy (((SmallDocumentBlock)blocks [lastBlockIndex])._data' 0' buffer' buffer_offset' buffer.Length - buffer_offset); " is 122.
Long Statement,NPOI.HSSF.Record.Crypto,Biff8RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8RC4.cs,XorLong,The length of the statement  "	long mask = (((long)b7) << 56) + (((long)b6) << 48) + (((long)b5) << 40) + (((long)b4) << 32) + (((long)b3) << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0); " is 152.
Long Statement,NPOI.POIFS.Dev,POIFSViewEngine,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Dev\POIFSViewEngine.cs,ProcessViewable,The length of the statement  "			((ArrayList)objects).AddRange (InspectViewable ("POIFSDocument content is too long so ignored"' drilldown' indentLevel + 1' indentString)); " is 139.
Long Statement,NPOI.SS.Formula.PTG,SharedFormula,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SharedFormula.cs,ConvertSharedFormulas,The length of the statement  "			ptg = new RefPtg (FixupRelativeRow (formulaRow' refNPtg.Row' refNPtg.IsRowRelative)' FixupRelativeColumn (formulaColumn' refNPtg.Column' refNPtg.IsColRelative)' refNPtg.IsRowRelative' refNPtg.IsColRelative); " is 207.
Long Statement,NPOI.SS.Formula.PTG,SharedFormula,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SharedFormula.cs,ConvertSharedFormulas,The length of the statement  "			ptg = new AreaPtg (FixupRelativeRow (formulaRow' areaNPtg.FirstRow' areaNPtg.IsFirstRowRelative)' FixupRelativeRow (formulaRow' areaNPtg.LastRow' areaNPtg.IsLastRowRelative)' FixupRelativeColumn (formulaColumn' areaNPtg.FirstColumn' areaNPtg.IsFirstColRelative)' FixupRelativeColumn (formulaColumn' areaNPtg.LastColumn' areaNPtg.IsLastColRelative)' areaNPtg.IsFirstRowRelative' areaNPtg.IsLastRowRelative' areaNPtg.IsFirstColRelative' areaNPtg.IsLastColRelative); " is 463.
Long Statement,NPOI.SS.Formula.PTG,ArrayPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ArrayPtg.cs,GetValueIndex,The length of the statement  "		throw new ArgumentException ("Specified colIx (" + colIx + ") is outside the allowed range (0.." + (_nColumns - 1) + ")"); " is 122.
Long Statement,NPOI.SS.Formula.PTG,DeletedArea3DPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\DeletedArea3DPtg.cs,ToFormulaString,The length of the statement  "	return ExternSheetNameResolver.PrependSheetName (book' field_1_index_extern_sheet' HSSFErrorConstants.GetText (HSSFErrorConstants.ERROR_REF)); " is 142.
Long Statement,NPOI.SS.Formula.PTG,DeletedRef3DPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\DeletedRef3DPtg.cs,ToFormulaString,The length of the statement  "	return ExternSheetNameResolver.PrependSheetName (book' field_1_index_extern_sheet' HSSFErrorConstants.GetText (HSSFErrorConstants.ERROR_REF)); " is 142.
Long Statement,NPOI.SS.Formula.PTG,ExpPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ExpPtg.cs,ToFormulaString,The length of the statement  "	throw new RecordFormatException ("Coding Error: Expected ExpPtg to be Converted from Shared to Non-Shared Formula by ValueRecordsAggregate' but it wasn't"); " is 156.
Long Statement,NPOI.SS.Formula.PTG,ValueOperatorPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ValueOperatorPtg.cs,ToFormulaString,The length of the statement  "	throw new NotImplementedException ("ToFormulaString(String[] operands) should be used for subclasses of OperationPtgs"); " is 120.
Long Statement,NPOI.SS.Formula,CollaboratingWorkbooksEnvironment,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\CollaboratingWorkbooksEnvironment.cs,Setup,The length of the statement  "		throw new ArgumentException ("Number of workbook names is " + nItems + " but number of evaluators is " + evaluators.Length); " is 124.
Long Statement,NPOI.SS.Formula,EvaluationCache,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\EvaluationCache.cs,GetPlainValueEntry,The length of the statement  "		// TODO - if we are confident that this sanity check is not required' we can Remove 'value' from plain value cache entry   " is 120.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,expected,The length of the statement  "		msg = "Parse error near char " + (pointer - 1) + " '" + look + "'" + " in specified formula '" + formulaString + "'. Expected " + s; " is 132.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,CheckValidRangeOperand,The length of the statement  "		throw new FormulaParseException ("The " + sideName + " of the range operator ':' at position " + currentParsePosition + " is not a proper reference."); " is 151.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The length of the statement  "				throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must not contain whitespace."); " is 130.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The length of the statement  "				throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must have exactly 2 dots."); " is 127.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseNonRange,The length of the statement  "	if (name.Equals ("TRUE"' StringComparison.OrdinalIgnoreCase) || name.Equals ("FALSE"' StringComparison.OrdinalIgnoreCase)) { " is 124.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ReduceRangeExpression,The length of the statement  "		return new AreaPtg (refA.Row' refB.Row' refA.Column' refB.Column' refA.IsRowRelative' refB.IsRowRelative' refA.IsColRelative' refB.IsColRelative); " is 146.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ReduceRangeExpression,The length of the statement  "		return new Area3DPtg (refA.Row' refB.Row' refA.Column' refB.Column' refA.IsRowRelative' refB.IsRowRelative' refA.IsColRelative' refB.IsColRelative' refA.ExternSheetIndex); " is 171.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,Function,The length of the statement  "				throw new FormulaParseException ("Attempt To use name '" + name + "' as a Function' but defined name in workbook does not refer To a Function"); " is 144.
Long Statement,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,Parse,The length of the statement  "		String msg = "Unused input [" + formulaString.Substring (pointer - 1) + "] after attempting To Parse the formula [" + formulaString + "]"; " is 138.
Long Statement,NPOI.SS.Formula,FormulaRenderer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaRenderer.cs,GetOperands,The length of the statement  "			String msg = "Too few arguments supplied to operation. Expected (" + nOperands + ") operands but got (" + (nOperands - j - 1) + ")"; " is 132.
Long Statement,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformNode,The length of the statement  "	if (token is ValueOperatorPtg || token is ControlPtg || token is MemFuncPtg || token is MemAreaPtg || token is UnionPtg) { " is 122.
Long Statement,NPOI.SS.Formula,FormulaShifter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\FormulaShifter.cs,RowMoveRefPtg,The length of the statement  "	throw new InvalidOperationException ("Situation not covered: (" + _firstMovedIndex + "' " + _lastMovedIndex + "' " + _amountToMove + "' " + refRow + "' " + refRow + ")"); " is 170.
Long Statement,NPOI.SS.Formula,FormulaShifter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\FormulaShifter.cs,RowMoveAreaPtg,The length of the statement  "	throw new InvalidOperationException ("Situation not covered: (" + _firstMovedIndex + "' " + _lastMovedIndex + "' " + _amountToMove + "' " + aFirstRow + "' " + aLastRow + ")"); " is 175.
Long Statement,NPOI.SS.Formula,SheetNameFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SheetNameFormatter.cs,CellReferenceIsWithinRange,The length of the statement  "	return NPOI.SS.Util.CellReference.CellReferenceIsWithinRange (lettersPrefix' numbersSuffix' NPOI.SS.SpreadsheetVersion.EXCEL97); " is 128.
Long Statement,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateAny,The length of the statement  "	bool shouldCellDependencyBeRecorded = _stabilityClassifier == null ? true : !_stabilityClassifier.IsCellFinal (sheetIndex' rowIndex' columnIndex); " is 146.
Long Statement,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateAny,The length of the statement  "		OperationEvaluationContext ec = new OperationEvaluationContext (this' _workbook' sheetIndex' rowIndex' columnIndex' tracker); " is 125.
Long Statement,NPOI.SS.Formula.Eval,AreaEvalBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\AreaEvalBase.cs,GetAbsoluteValue,The length of the statement  "		throw new ArgumentException ("Specified row index (" + row + ") is outside the allowed range (" + _firstRow + ".." + _lastRow + ")"); " is 133.
Long Statement,NPOI.SS.Formula.Eval,AreaEvalBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\AreaEvalBase.cs,GetAbsoluteValue,The length of the statement  "		throw new ArgumentException ("Specified column index (" + col + ") is outside the allowed range (" + _firstColumn + ".." + col + ")"); " is 134.
Long Statement,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetStartingDate,The length of the statement  "		startingDate = new DateTime (startingDate.Year' startingDate.Month' 30' startingDate.Hour' startingDate.Minute' startingDate.Second); " is 133.
Long Statement,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The length of the statement  "		int colIndex = LookupUtils.LookupIndexOfValue (lookupValue' LookupUtils.CreateRowVector (tableArray' 0)' IsRangeLookup); " is 120.
Long Statement,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The length of the statement  "	else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) { " is 177.
Long Statement,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The length of the statement  "				String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom); " is 132.
Long Statement,NPOI.SS.Formula.Functions,TimeFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\TimeFunc.cs,Evaluate,The length of the statement  "		result = Evaluate (EvalArg (arg0' srcRowIndex' srcColumnIndex)' EvalArg (arg1' srcRowIndex' srcColumnIndex)' EvalArg (arg2' srcRowIndex' srcColumnIndex)); " is 154.
Long Statement,NPOI.SS.Formula.Functions,Vlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Vlookup.cs,Evaluate,The length of the statement  "		int rowIndex = LookupUtils.LookupIndexOfValue (lookupValue' LookupUtils.CreateColumnVector (tableArray' 0)' isRangeLookup); " is 123.
Long Statement,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,Add,The length of the statement  "	FunctionMetadata fm = new FunctionMetadata (functionIndex' functionName' minParams' maxParams' returnClassCode' parameterClassCodes); " is 133.
Long Statement,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,IsWholeColumnReference,The length of the statement  "	if (topLeft.Row == 0 && topLeft.IsRowAbsolute && (botRight.Row == -1 || botRight.Row == 65535) && botRight.IsRowAbsolute) { " is 123.
Long Statement,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,FormatAsString,The length of the statement  "		return CellReference.ConvertNumToColString (_firstCell.Col) + ":" + CellReference.ConvertNumToColString (_lastCell.Col); " is 120.
Long Statement,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,SeparateAreaRefs,The length of the statement  "					throw new ArgumentException ("More than one cell delimiter '" + CELL_DELIMITER + "' appears in area reference '" + reference + "'"); " is 132.
Long Statement,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,SeparateAreaRefs,The length of the statement  "			throw new ArgumentException ("Area reference '" + reference + "' ends with special name delimiter '" + SPECIAL_NAME_DELIMITER + "'"); " is 133.
Long Statement,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ClassifyCellReference,The length of the statement  "			throw new ArgumentException ("Invalid first char (" + firstChar + ") of cell reference or named range.  Letter expected"); " is 122.
Long Statement,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,Equals,The length of the statement  "	return _rowIndex == cr._rowIndex && _colIndex == cr._colIndex && _isRowAbs == cr._isColAbs && _isColAbs == cr._isColAbs; " is 120.
Long Statement,NPOI.SS.Util,NumberComparer,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberComparer.cs,Compare,The length of the statement  "		// special case exponent differs by 1.  There is still a chance that with rounding the two quantities could end up the same " is 123.
Long Statement,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The length of the statement  "						//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention); " is 125.
Long Statement,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The length of the statement  "						//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention); " is 125.
Long Statement,NPOI.SS.Util,SSCellRange,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SSCellRange.cs,GetCell,The length of the statement  "		throw new IndexOutOfRangeException ("Specified row " + relativeRowIndex + " is outside the allowable range (0.." + (_height - 1) + ")."); " is 137.
Long Statement,NPOI.SS.Util,SSCellRange,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SSCellRange.cs,GetCell,The length of the statement  "		throw new IndexOutOfRangeException ("Specified colummn " + relativeColumnIndex + " is outside the allowable range (0.." + (_width - 1) + ")."); " is 143.
Long Statement,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,ValidateSheetName,The length of the statement  "		throw new ArgumentException ("sheetName '" + sheetName + "' is invalid - character count MUST be greater than or equal to 1 and less than or equal to 31"); " is 155.
Long Statement,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,ValidateSheetState,The length of the statement  "		throw new ArgumentException ("Ivalid sheet state : " + state + "\n" + "Sheet state must beone of the Workbook.SHEET_STATE_* constants"); " is 136.
Long Statement,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,GetCondition,The length of the statement  "	return CellFormatCondition.GetInstance (m.Groups [(CONDITION_OPERATOR_GROUP)].Value' m.Groups [(CONDITION_VALUE_GROUP)].Value); " is 127.
Complex Conditional,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Equals,The conditional expression  "((field_4_format_Runs == null) && (other.field_4_format_Runs != null)) || (field_4_format_Runs != null) && (other.field_4_format_Runs == null)"  is complex.
Complex Conditional,NPOI.HSSF.UserModel,HSSFErrorConstants,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFErrorConstants.cs,IsValidCode,The conditional expression  "errorCode == ERROR_NULL || errorCode == ERROR_DIV_0 || errorCode == ERROR_VALUE || errorCode == ERROR_REF || errorCode == ERROR_NAME || errorCode == ERROR_NUM || errorCode == ERROR_NA"  is complex.
Complex Conditional,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ContainsCell,The conditional expression  "cr.FirstRow <= rowIx && cr.LastRow >= rowIx && cr.FirstColumn <= colIx && cr.LastColumn >= colIx"  is complex.
Complex Conditional,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,IsMergedRegion,The conditional expression  "range.FirstColumn <= mergedRegion.FirstColumn && range.LastColumn >= mergedRegion.LastColumn && range.FirstRow <= mergedRegion.FirstRow && range.LastRow >= mergedRegion.LastRow"  is complex.
Complex Conditional,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The conditional expression  "hssfFont.Boldweight == boldWeight && hssfFont.Color == color && hssfFont.FontHeight == fontHeight && hssfFont.FontName.Equals (name) && hssfFont.IsItalic == italic && hssfFont.IsStrikeout == strikeout && hssfFont.TypeOffset == typeOffset && hssfFont.Underline == Underline"  is complex.
Complex Conditional,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,intern_isSheetNameOk,The conditional expression  "!(Char.IsLetterOrDigit (ch) || (ch == '_') || _canBeWaitSpace && (ch == ' '))"  is complex.
Complex Conditional,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,TypesAreEqual,The conditional expression  "t1 == t2 || (t1 == Variant.VT_LPSTR && t2 == Variant.VT_LPWSTR) || (t2 == Variant.VT_LPSTR && t1 == Variant.VT_LPWSTR)"  is complex.
Complex Conditional,NPOI.HPSF,PropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\PropertySet.cs,Equals,The conditional expression  "byteOrder1 != byteOrder2 || !classID1.Equals (classID2) || format1 != format2 || osVersion1 != osVersion2 || sectionCount1 != sectionCount2"  is complex.
Complex Conditional,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,Intersect,The conditional expression  "gt (crA.FirstRow' lastRow) || lt (crA.LastRow' firstRow) || gt (crA.FirstColumn' lastCol) || lt (crA.LastColumn' firstCol)"  is complex.
Complex Conditional,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,HasExactSharedBorder,The conditional expression  "crA.FirstRow > 0 && crA.FirstRow - 1 == oLastRow || oFirstRow > 0 && oFirstRow - 1 == crA.LastRow"  is complex.
Complex Conditional,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,HasExactSharedBorder,The conditional expression  "crA.FirstColumn > 0 && crA.FirstColumn - 1 == oLastCol || oFirstCol > 0 && crA.LastColumn == oFirstCol - 1"  is complex.
Complex Conditional,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The conditional expression  "f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)"  is complex.
Complex Conditional,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,GetFormat,The conditional expression  "emulateCsv && cellValue == 0.0 && formatStr.Contains ("#") && !formatStr.Contains ("0")"  is complex.
Complex Conditional,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The conditional expression  "(!use1904windowing && year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && year < 1904)"  is complex.
Complex Conditional,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The conditional expression  "(month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)"  is complex.
Complex Conditional,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The conditional expression  "(month == 4 || month == 6 || month == 9 || month == 11)"  is complex.
Complex Conditional,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The conditional expression  "(!use1904windowing && date.Year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && date.Year < 1904)"  is complex.
Complex Conditional,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The conditional expression  "i == 3 || i == 5 || i == 7 || i == 9"  is complex.
Complex Conditional,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The conditional expression  "_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]"  is complex.
Complex Conditional,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The conditional expression  "_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]"  is complex.
Complex Conditional,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleFactor,The conditional expression  "IsAlpha (look) || Char.IsDigit (look) || look == '\'' || look == '['"  is complex.
Complex Conditional,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformNode,The conditional expression  "token is ValueOperatorPtg || token is ControlPtg || token is MemFuncPtg || token is MemAreaPtg || token is UnionPtg"  is complex.
Complex Conditional,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,GetEvalForPtg,The conditional expression  "ptg is AreaErrPtg || ptg is RefErrorPtg || ptg is DeletedArea3DPtg || ptg is DeletedRef3DPtg"  is complex.
Complex Conditional,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The conditional expression  "(month == 1 && day >= 60) || (month == 2 && day >= 30)"  is complex.
Complex Conditional,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,GetValueFromArea,The conditional expression  "!rowArgWasEmpty && rowIx >= height || !colArgWasEmpty && columnIx >= width"  is complex.
Complex Conditional,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,GetValueFromArea,The conditional expression  "rowIx < 0 || columnIx < 0 || rowIx >= height || columnIx >= width"  is complex.
Complex Conditional,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,floor,The conditional expression  "(n < 0 && s > 0) || (n > 0 && s < 0) || (s == 0 && n != 0)"  is complex.
Complex Conditional,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,ceiling,The conditional expression  "(n < 0 && s > 0) || (n > 0 && s < 0)"  is complex.
Complex Conditional,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,IsWholeColumnReference,The conditional expression  "topLeft.Row == 0 && topLeft.IsRowAbsolute && (botRight.Row == -1 || botRight.Row == 65535) && botRight.IsRowAbsolute"  is complex.
Complex Conditional,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,ContainsCell,The conditional expression  "cr.FirstRow <= rowIx && cr.LastRow >= rowIx && cr.FirstColumn <= colIx && cr.LastColumn >= colIx"  is complex.
Complex Conditional,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The conditional expression  "resultCh != '0' || s.ch == '0' || s.ch == '?' || pos >= strip"  is complex.
Virtual Method Call from Constructor,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The constructor "UnicodeString" calls a virtual method "Log".
Virtual Method Call from Constructor,NPOI.HPSF,MutablePropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutablePropertySet.cs,MutablePropertySet,The constructor "MutablePropertySet" calls a virtual method "ClearSections".
Virtual Method Call from Constructor,NPOI.HPSF,MutablePropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutablePropertySet.cs,MutablePropertySet,The constructor "MutablePropertySet" calls a virtual method "AddSection".
Virtual Method Call from Constructor,NPOI.HPSF,Section,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Section.cs,Section,The constructor "Section" calls a virtual method "GetProperty".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadLong".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The constructor "EncryptionHeader" calls a virtual method "ReadShort".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The constructor "EncryptionInfo" calls a virtual method "ReadShort".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The constructor "EncryptionInfo" calls a virtual method "ReadShort".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The constructor "EncryptionInfo" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The constructor "EncryptionInfo" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The constructor "EncryptionVerifier" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The constructor "EncryptionVerifier" calls a virtual method "ReadFully".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The constructor "EncryptionVerifier" calls a virtual method "ReadFully".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The constructor "EncryptionVerifier" calls a virtual method "ReadInt".
Virtual Method Call from Constructor,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The constructor "EncryptionVerifier" calls a virtual method "ReadFully".
Virtual Method Call from Constructor,NPOI.POIFS.FileSystem,ChainLoopDetector,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\BlockStore.cs,ChainLoopDetector,The constructor "ChainLoopDetector" calls a virtual method "GetBlockStoreBlockSize".
Virtual Method Call from Constructor,NPOI.POIFS.FileSystem,StreamBlockByteBufferIterator,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSStream.cs,StreamBlockByteBufferIterator,The constructor "StreamBlockByteBufferIterator" calls a virtual method "GetChainLoopDetector".
Virtual Method Call from Constructor,NPOI.POIFS.Storage,RawDataBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\RawDataBlock.cs,RawDataBlock,The constructor "RawDataBlock" calls a virtual method "Log".
Virtual Method Call from Constructor,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,CellFormatPart,The constructor "CellFormatPart" calls a virtual method "GetTriplet".
Empty Catch Block,NPOI.HSSF.Record,RecordFactory,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordFactory.cs,GetRecordCreator,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetWorkbookDirEntryName,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetWorkbookDirEntryName,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.UserModel,StaticFontMetrics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\StaticFontMetrics.cs,GetFontDetails,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.UserModel,StaticFontMetrics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\StaticFontMetrics.cs,GetFontDetails,The method has an empty catch block.
Empty Catch Block,NPOI,POIDocument,C:\repos\xoposhiy_npoi\trunk\main\POIDocument.cs,GetPropertySet,The method has an empty catch block.
Empty Catch Block,NPOI,POIDocument,C:\repos\xoposhiy_npoi\trunk\main\POIDocument.cs,GetPropertySet,The method has an empty catch block.
Empty Catch Block,NPOI.HPSF,MutablePropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutablePropertySet.cs,Write,The method has an empty catch block.
Empty Catch Block,NPOI.HSSF.EventUserModel,HSSFEventFactory,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\HSSFEventFactory.cs,ProcessEvents,The method has an empty catch block.
Empty Catch Block,NPOI.Util,POILogFactory,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogFactory.cs,GetLogger,The method has an empty catch block.
Empty Catch Block,NPOI.POIFS.Storage,BlockAllocationTableReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\BlockAllocationTableReader.cs,IsUsed,The method has an empty catch block.
Magic Number,NPOI.DDF,AbstractEscherOptRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\AbstractEscherOptRecord.cs,FillFields,The following statement contains a magic number: return bytesRemaining + 8;  
Magic Number,NPOI.DDF,AbstractEscherOptRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\AbstractEscherOptRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,AbstractEscherOptRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\AbstractEscherOptRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' PropertiesSize);  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,CheckComplexData,The following statement contains a magic number: if (complexData == null || complexData.Length == 0)  	complexData = new byte[6];  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,CheckComplexData,The following statement contains a magic number: complexData = new byte[6];  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SetArrayData,The following statement contains a magic number: if (emptyComplexPart) {  	complexData = new byte[0];  }  else {  	short numElements = LittleEndian.GetShort (data' offset);  	short numReserved = LittleEndian.GetShort (data' offset + 2);  	short sizeOfElements = LittleEndian.GetShort (data' offset + 4);  	int arraySize = GetActualSizeOfElements (sizeOfElements) * numElements;  	if (arraySize == complexData.Length) {  		// The stored data size in the simple block excludes the header size  		complexData = new byte[arraySize + 6];  		sizeIncludesHeaderSize = false;  	}  	Array.Copy (data' offset' complexData' 0' complexData.Length);  }  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SetArrayData,The following statement contains a magic number: if (emptyComplexPart) {  	complexData = new byte[0];  }  else {  	short numElements = LittleEndian.GetShort (data' offset);  	short numReserved = LittleEndian.GetShort (data' offset + 2);  	short sizeOfElements = LittleEndian.GetShort (data' offset + 4);  	int arraySize = GetActualSizeOfElements (sizeOfElements) * numElements;  	if (arraySize == complexData.Length) {  		// The stored data size in the simple block excludes the header size  		complexData = new byte[arraySize + 6];  		sizeIncludesHeaderSize = false;  	}  	Array.Copy (data' offset' complexData' 0' complexData.Length);  }  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SetArrayData,The following statement contains a magic number: if (emptyComplexPart) {  	complexData = new byte[0];  }  else {  	short numElements = LittleEndian.GetShort (data' offset);  	short numReserved = LittleEndian.GetShort (data' offset + 2);  	short sizeOfElements = LittleEndian.GetShort (data' offset + 4);  	int arraySize = GetActualSizeOfElements (sizeOfElements) * numElements;  	if (arraySize == complexData.Length) {  		// The stored data size in the simple block excludes the header size  		complexData = new byte[arraySize + 6];  		sizeIncludesHeaderSize = false;  	}  	Array.Copy (data' offset' complexData' 0' complexData.Length);  }  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SetArrayData,The following statement contains a magic number: if (arraySize == complexData.Length) {  	// The stored data size in the simple block excludes the header size  	complexData = new byte[arraySize + 6];  	sizeIncludesHeaderSize = false;  }  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SetArrayData,The following statement contains a magic number: complexData = new byte[arraySize + 6];  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SerializeSimplePart,The following statement contains a magic number: if (!sizeIncludesHeaderSize) {  	recordSize -= 6;  }  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SerializeSimplePart,The following statement contains a magic number: recordSize -= 6;  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SerializeSimplePart,The following statement contains a magic number: LittleEndian.PutInt (data' pos + 2' recordSize);  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,SerializeSimplePart,The following statement contains a magic number: return 6;  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,GetActualSizeOfElements,The following statement contains a magic number: if (sizeOfElements < 0)  	return (short)((-sizeOfElements) >> 2);  else  	return sizeOfElements;  
Magic Number,NPOI.DDF,EscherArrayProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherArrayProperty.cs,GetActualSizeOfElements,The following statement contains a magic number: return (short)((-sizeOfElements) >> 2);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,FillFields,The following statement contains a magic number: field_1_UID = new byte[16];  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos' field_1_UID' 0' 16);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,FillFields,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,FillFields,The following statement contains a magic number: field_pictureData = new byte[bytesAfterHeader - 17];  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' RecordSize - HEADER_SIZE);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: Array.Copy (field_1_UID' 0' data' pos' 16);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: data [pos + 16] = field_2_marker;  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: Array.Copy (field_pictureData' 0' data' pos + 17' field_pictureData.Length);  
Magic Number,NPOI.DDF,EscherBitmapBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBitmapBlip.cs,Serialize,The following statement contains a magic number: return HEADER_SIZE + 16 + 1 + field_pictureData.Length;  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,FillFields,The following statement contains a magic number: return bytesAfterHeader + 8;  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (field_pictureData' 0' data' offset + 4' field_pictureData.Length);  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,Serialize,The following statement contains a magic number: listener.AfterRecordSerialize (offset + 4 + field_pictureData.Length' RecordId' field_pictureData.Length + 4' this);  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,Serialize,The following statement contains a magic number: listener.AfterRecordSerialize (offset + 4 + field_pictureData.Length' RecordId' field_pictureData.Length + 4' this);  
Magic Number,NPOI.DDF,EscherBlipRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipRecord.cs,Serialize,The following statement contains a magic number: return field_pictureData.Length + 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: field_1_secondaryUID = new byte[16];  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos + size' field_1_secondaryUID' 0' 16);  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 16;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (field_1_secondaryUID' 0' data' pos' 16);  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherBlipWMFRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBlipWMFRecord.cs,Decompress,The following statement contains a magic number: Array.Copy (data' pos + 50' compressedData' 0' Length);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_3_uid = new byte[16];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos + 2' field_3_uid' 0' 16);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos + 2' field_3_uid' 0' 16);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_4_tag = LittleEndian.GetShort (data' pos + 18);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_5_size = LittleEndian.GetInt (data' pos + 20);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_6_ref = LittleEndian.GetInt (data' pos + 24);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_7_offset = LittleEndian.GetInt (data' pos + 28);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_8_usage = data [pos + 32];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_9_name = data [pos + 33];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_10_unused2 = data [pos + 34];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_11_unused3 = data [pos + 35];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: bytesRemaining -= 36;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining > 0) {  	field_12_blipRecord = (EscherBlipRecord)recordFactory.CreateRecord (data' pos + 36);  	bytesRead = field_12_blipRecord.FillFields (data' pos + 36' recordFactory);  }  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining > 0) {  	field_12_blipRecord = (EscherBlipRecord)recordFactory.CreateRecord (data' pos + 36);  	bytesRead = field_12_blipRecord.FillFields (data' pos + 36' recordFactory);  }  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: field_12_blipRecord = (EscherBlipRecord)recordFactory.CreateRecord (data' pos + 36);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: bytesRead = field_12_blipRecord.FillFields (data' pos + 36' recordFactory);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: pos += 36 + bytesRead;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: return bytesRemaining + 8 + 36 + (field_12_blipRecord == null ? 0 : field_12_blipRecord.RecordSize);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,FillFields,The following statement contains a magic number: return bytesRemaining + 8 + 36 + (field_12_blipRecord == null ? 0 : field_12_blipRecord.RecordSize);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 8] = field_1_blipTypeWin32;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 9] = field_2_blipTypeMacOS;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	data [offset + 10 + i] = field_3_uid [i];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: for (int i = 0; i < 16; i++)  	data [offset + 10 + i] = field_3_uid [i];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 10 + i] = field_3_uid [i];  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 26' field_4_tag);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 28' field_5_size);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 32' field_6_ref);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 36' field_7_offset);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 40] = field_8_usage;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 41] = field_9_name;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 42] = field_10_unused2;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: data [offset + 43] = field_11_unused3;  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: if (field_12_blipRecord != null) {  	bytesWritten = field_12_blipRecord.Serialize (offset + 44' data);  }  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: bytesWritten = field_12_blipRecord.Serialize (offset + 44' data);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,Serialize,The following statement contains a magic number: Array.Copy (_remainingData' 0' data' offset + 44 + bytesWritten' _remainingData.Length);  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case BT_ERROR:  	return " ERROR";  case BT_UNKNOWN:  	return " UNKNOWN";  case BT_EMF:  	return " EMF";  case BT_WMF:  	return " WMF";  case BT_PICT:  	return " PICT";  case BT_JPEG:  	return " JPEG";  case BT_PNG:  	return " PNG";  case BT_DIB:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherBSERecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherBSERecord.cs,GetBlipType,The following statement contains a magic number: if (b < 32)  	return " NotKnown";  else  	return " Client";  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,FillFields,The following statement contains a magic number: return 8 + size;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' pos' RecordSize - 8);  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherChildAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherChildAnchorRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining == 4)// Word format only 4 bytes   {  	// Not sure exactly what the format is quite yet' likely a reference to a PLC  }  else {  	field_1_flag = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_2_col1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_3_dx1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_4_row1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	if (bytesRemaining >= 18) {  		field_5_dy1 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_6_col2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_7_dx2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_8_row2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		field_9_dy2 = LittleEndian.GetShort (data' pos + size);  		size += 2;  		shortRecord = false;  	}  	else {  		shortRecord = true;  	}  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: if (bytesRemaining >= 18) {  	field_5_dy1 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_6_col2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_7_dx2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_8_row2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	field_9_dy2 = LittleEndian.GetShort (data' pos + size);  	size += 2;  	shortRecord = false;  }  else {  	shortRecord = true;  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: size += 2;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,FillFields,The following statement contains a magic number: return 8 + size + bytesRemaining;  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 8' field_1_flag);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 10' field_2_col1);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 12' field_3_dx1);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 14' field_4_row1);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: if (!shortRecord) {  	LittleEndian.PutShort (data' offset + 16' field_5_dy1);  	LittleEndian.PutShort (data' offset + 18' field_6_col2);  	LittleEndian.PutShort (data' offset + 20' field_7_dx2);  	LittleEndian.PutShort (data' offset + 22' field_8_row2);  	LittleEndian.PutShort (data' offset + 24' field_9_dy2);  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: if (!shortRecord) {  	LittleEndian.PutShort (data' offset + 16' field_5_dy1);  	LittleEndian.PutShort (data' offset + 18' field_6_col2);  	LittleEndian.PutShort (data' offset + 20' field_7_dx2);  	LittleEndian.PutShort (data' offset + 22' field_8_row2);  	LittleEndian.PutShort (data' offset + 24' field_9_dy2);  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: if (!shortRecord) {  	LittleEndian.PutShort (data' offset + 16' field_5_dy1);  	LittleEndian.PutShort (data' offset + 18' field_6_col2);  	LittleEndian.PutShort (data' offset + 20' field_7_dx2);  	LittleEndian.PutShort (data' offset + 22' field_8_row2);  	LittleEndian.PutShort (data' offset + 24' field_9_dy2);  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: if (!shortRecord) {  	LittleEndian.PutShort (data' offset + 16' field_5_dy1);  	LittleEndian.PutShort (data' offset + 18' field_6_col2);  	LittleEndian.PutShort (data' offset + 20' field_7_dx2);  	LittleEndian.PutShort (data' offset + 22' field_8_row2);  	LittleEndian.PutShort (data' offset + 24' field_9_dy2);  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: if (!shortRecord) {  	LittleEndian.PutShort (data' offset + 16' field_5_dy1);  	LittleEndian.PutShort (data' offset + 18' field_6_col2);  	LittleEndian.PutShort (data' offset + 20' field_7_dx2);  	LittleEndian.PutShort (data' offset + 22' field_8_row2);  	LittleEndian.PutShort (data' offset + 24' field_9_dy2);  }  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 16' field_5_dy1);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 18' field_6_col2);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 20' field_7_dx2);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 22' field_8_row2);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 24' field_9_dy2);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (remainingData' 0' data' offset + (shortRecord ? 16 : 26)' remainingData.Length);  
Magic Number,NPOI.DDF,EscherClientAnchorRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientAnchorRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (remainingData' 0' data' offset + (shortRecord ? 16 : 26)' remainingData.Length);  
Magic Number,NPOI.DDF,EscherClientDataRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientDataRecord.cs,FillFields,The following statement contains a magic number: return 8 + bytesRemaining;  
Magic Number,NPOI.DDF,EscherClientDataRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientDataRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherClientDataRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientDataRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingData.Length);  
Magic Number,NPOI.DDF,EscherClientDataRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherClientDataRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (remainingData' 0' data' offset + 8' remainingData.Length);  
Magic Number,NPOI.DDF,EscherComplexProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherComplexProperty.cs,SerializeSimplePart,The following statement contains a magic number: LittleEndian.PutInt (data' pos + 2' complexData.Length);  
Magic Number,NPOI.DDF,EscherComplexProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherComplexProperty.cs,SerializeSimplePart,The following statement contains a magic number: return 6;  
Magic Number,NPOI.DDF,EscherComplexProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherComplexProperty.cs,GetHashCode,The following statement contains a magic number: return Id * 11;  
Magic Number,NPOI.DDF,EscherContainerRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherContainerRecord.cs,FillFields,The following statement contains a magic number: offset += 8;  
Magic Number,NPOI.DDF,EscherContainerRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherContainerRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherContainerRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherContainerRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: field_5_fileIdClusters = new FileIdCluster[(bytesRemaining - size) / 8];  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: for (int i = 0; i < field_5_fileIdClusters.Length; i++) {  	field_5_fileIdClusters [i] = new FileIdCluster (LittleEndian.GetInt (data' pos + size)' LittleEndian.GetInt (data' pos + size + 4));  	maxDgId = Math.Max (maxDgId' field_5_fileIdClusters [i].DrawingGroupId);  	size += 8;  }  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: for (int i = 0; i < field_5_fileIdClusters.Length; i++) {  	field_5_fileIdClusters [i] = new FileIdCluster (LittleEndian.GetInt (data' pos + size)' LittleEndian.GetInt (data' pos + size + 4));  	maxDgId = Math.Max (maxDgId' field_5_fileIdClusters [i].DrawingGroupId);  	size += 8;  }  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: field_5_fileIdClusters [i] = new FileIdCluster (LittleEndian.GetInt (data' pos + size)' LittleEndian.GetInt (data' pos + size + 4));  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: size += 8;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,FillFields,The following statement contains a magic number: return 8 + size + bytesRemaining;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: for (int i = 0; i < field_5_fileIdClusters.Length; i++) {  	LittleEndian.PutInt (data' pos' field_5_fileIdClusters [i].DrawingGroupId);  	pos += 4;  	LittleEndian.PutInt (data' pos' field_5_fileIdClusters [i].NumShapeIdsUsed);  	pos += 4;  }  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: for (int i = 0; i < field_5_fileIdClusters.Length; i++) {  	LittleEndian.PutInt (data' pos' field_5_fileIdClusters [i].DrawingGroupId);  	pos += 4;  	LittleEndian.PutInt (data' pos' field_5_fileIdClusters [i].NumShapeIdsUsed);  	pos += 4;  }  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDggRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDggRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' 8);  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' 8);  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 8' field_1_numShapes);  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 12' field_2_lastMSOSPID);  
Magic Number,NPOI.DDF,EscherDgRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDgRecord.cs,Serialize,The following statement contains a magic number: listener.AfterRecordSerialize (offset + 16' RecordId' RecordSize' this);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (!atEOF && (remainingBytes > 0)) {  	stringBuf = new StringBuilder ();  	options = LittleEndian.ReadShort (in1);  	recordId = LittleEndian.ReadShort (in1);  	recordBytesRemaining = LittleEndian.ReadInt (in1);  	remainingBytes -= 2 + 2 + 4;  	switch (recordId) {  	case unchecked((short)0xF000):  		recordName = "MsofbtDggContainer";  		break;  	case unchecked((short)0xF006):  		recordName = "MsofbtDgg";  		break;  	case unchecked((short)0xF016):  		recordName = "MsofbtCLSID";  		break;  	case unchecked((short)0xF00B):  		recordName = "MsofbtOPT";  		break;  	case unchecked((short)0xF11A):  		recordName = "MsofbtColorMRU";  		break;  	case unchecked((short)0xF11E):  		recordName = "MsofbtSplitMenuColors";  		break;  	case unchecked((short)0xF001):  		recordName = "MsofbtBstoreContainer";  		break;  	case unchecked((short)0xF007):  		recordName = "MsofbtBSE";  		break;  	case unchecked((short)0xF002):  		recordName = "MsofbtDgContainer";  		break;  	case unchecked((short)0xF008):  		recordName = "MsofbtDg";  		break;  	case unchecked((short)0xF118):  		recordName = "MsofbtRegroupItem";  		break;  	case unchecked((short)0xF120):  		recordName = "MsofbtColorScheme";  		break;  	case unchecked((short)0xF003):  		recordName = "MsofbtSpgrContainer";  		break;  	case unchecked((short)0xF004):  		recordName = "MsofbtSpContainer";  		break;  	case unchecked((short)0xF009):  		recordName = "MsofbtSpgr";  		break;  	case unchecked((short)0xF00A):  		recordName = "MsofbtSp";  		break;  	case unchecked((short)0xF00C):  		recordName = "MsofbtTextbox";  		break;  	case unchecked((short)0xF00D):  		recordName = "MsofbtClientTextbox";  		break;  	case unchecked((short)0xF00E):  		recordName = "MsofbtAnchor";  		break;  	case unchecked((short)0xF00F):  		recordName = "MsofbtChildAnchor";  		break;  	case unchecked((short)0xF010):  		recordName = "MsofbtClientAnchor";  		break;  	case unchecked((short)0xF011):  		recordName = "MsofbtClientData";  		break;  	case unchecked((short)0xF11F):  		recordName = "MsofbtOleObject";  		break;  	case unchecked((short)0xF11D):  		recordName = "MsofbtDeletedPspl";  		break;  	case unchecked((short)0xF005):  		recordName = "MsofbtSolverContainer";  		break;  	case unchecked((short)0xF012):  		recordName = "MsofbtConnectorRule";  		break;  	case unchecked((short)0xF013):  		recordName = "MsofbtAlignRule";  		break;  	case unchecked((short)0xF014):  		recordName = "MsofbtArcRule";  		break;  	case unchecked((short)0xF015):  		recordName = "MsofbtClientRule";  		break;  	case unchecked((short)0xF017):  		recordName = "MsofbtCalloutRule";  		break;  	case unchecked((short)0xF119):  		recordName = "MsofbtSelection";  		break;  	case unchecked((short)0xF122):  		recordName = "MsofbtUDefProp";  		break;  	default:  		if (recordId >= unchecked((short)0xF018) && recordId <= unchecked((short)0xF117))  			recordName = "MsofbtBLIP";  		else if ((options & (short)0x000F) == (short)0x000F)  			recordName = "UNKNOWN container";  		else  			recordName = "UNKNOWN ID";  		break;  	}  	stringBuf.Append ("  ");  	stringBuf.Append (HexDump.ToHex (recordId));  	stringBuf.Append ("  ").Append (recordName).Append (" [");  	stringBuf.Append (HexDump.ToHex (options));  	stringBuf.Append (''');  	stringBuf.Append (HexDump.ToHex (recordBytesRemaining));  	stringBuf.Append ("]  instance: ");  	stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  	Console.WriteLine (stringBuf.ToString ());  	if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  		// BSE' FBSE  		//                ULONG nP = pIn->GetRecPos();  		byte n8;  		//                short n16;  		//                int n32;  		stringBuf = new StringBuilder ("    btWin32: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		stringBuf.Append ("  btMacOS: ");  		n8 = (byte)in1.ReadByte ();  		stringBuf.Append (HexDump.ToHex (n8));  		stringBuf.Append (GetBlipType (n8));  		Console.WriteLine (stringBuf.ToString ());  		Console.WriteLine ("    rgbUid:");  		HexDump.Dump (in1' 0' 16);  		Console.Write ("    tag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    size: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cRef: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    offs: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    usage: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    cbName: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused2: ");  		OutHex (4' in1);  		Console.WriteLine ();  		Console.Write ("    unused3: ");  		OutHex (4' in1);  		Console.WriteLine ();  		// subtract the number of bytes we've Read  		remainingBytes -= 36;  		//n -= pIn->GetRecPos() - nP;  		recordBytesRemaining = 0;  		// loop to MsofbtBLIP  	}  	else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  		// ClientAnchor  		//ULONG nP = pIn->GetRecPos();  		//                short n16;  		Console.Write ("    Flag: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col1: ");  		OutHex (2' in1);  		Console.Write ("    dX1: ");  		OutHex (2' in1);  		Console.Write ("    Row1: ");  		OutHex (2' in1);  		Console.Write ("    dY1: ");  		OutHex (2' in1);  		Console.WriteLine ();  		Console.Write ("    Col2: ");  		OutHex (2' in1);  		Console.Write ("    dX2: ");  		OutHex (2' in1);  		Console.Write ("    Row2: ");  		OutHex (2' in1);  		Console.Write ("    dY2: ");  		OutHex (2' in1);  		Console.WriteLine ();  		remainingBytes -= 18;  		recordBytesRemaining -= 18;  	}  	else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  		// OPT  		int nComplex = 0;  		Console.WriteLine ("    PROPID        VALUE");  		while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  			short n16;  			int n32;  			n16 = LittleEndian.ReadShort (in1);  			n32 = LittleEndian.ReadInt (in1);  			recordBytesRemaining -= 6;  			remainingBytes -= 6;  			Console.Write ("    ");  			Console.Write (HexDump.ToHex (n16));  			Console.Write (" (");  			int propertyId = n16 & (short)0x3FFF;  			Console.Write (" " + propertyId);  			if ((n16 & unchecked((short)0x8000)) == 0) {  				if ((n16 & (short)0x4000) != 0)  					Console.Write ("' fBlipID");  				Console.Write (")  ");  				Console.Write (HexDump.ToHex (n32));  				if ((n16 & (short)0x4000) == 0) {  					Console.Write (" (");  					Console.Write (Dec1616 (n32));  					Console.Write (')');  					Console.Write (" {" + PropertyName ((short)propertyId) + "}");  				}  				Console.WriteLine ();  			}  			else {  				Console.Write ("' fComplex)  ");  				Console.Write (HexDump.ToHex (n32));  				Console.Write (" - Complex prop len");  				Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  				nComplex += n32;  			}  		}  		// complex property data  		while ((nComplex & remainingBytes) > 0) {  			nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  			HexDump.Dump (in1' 0' nDumpSize);  			nComplex -= nDumpSize;  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  	else if (recordId == (unchecked((short)0xF012))) {  		Console.Write ("    Connector rule: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   ShapeID B: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("    ShapeID connector: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt A: ");  		Console.Write (LittleEndian.ReadInt (in1));  		Console.Write ("   Connect pt B: ");  		Console.WriteLine (LittleEndian.ReadInt (in1));  		recordBytesRemaining -= 24;  		remainingBytes -= 24;  	}  	else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  		Console.WriteLine ("    Secondary UID: ");  		HexDump.Dump (in1' 0' 16);  		Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  		Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  		Console.WriteLine ("    Data (after decompression): ");  		recordBytesRemaining -= 34 + 16;  		remainingBytes -= 34 + 16;  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		byte[] buf = new byte[nDumpSize];  		int Read = in1.Read (buf' 0' buf.Length);  		while (Read != -1 && Read < nDumpSize)  			Read += in1.Read (buf' Read' buf.Length);  		using (MemoryStream bin = new MemoryStream (buf)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  				int bytesToDump = -1;  				HexDump.Dump (zIn' 0' bytesToDump);  				recordBytesRemaining -= nDumpSize;  				remainingBytes -= nDumpSize;  			}  		}  	}  	bool isContainer = (options & (short)0x000F) == (short)0x000F;  	if (isContainer && remainingBytes >= 0) {  		// Container  		if (recordBytesRemaining <= (int)remainingBytes)  			Console.WriteLine ("            completed within");  		else  			Console.WriteLine ("            continued elsewhere");  	}  	else if (remainingBytes >= 0)// -> 0x0000 ... 0x0FFF  	 {  		nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  		if (nDumpSize != 0) {  			HexDump.Dump (in1' 0' nDumpSize);  			remainingBytes -= nDumpSize;  		}  	}  	else  		Console.WriteLine (" >> OVERRUN <<");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 2 + 2 + 4;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 2 + 2 + 4;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 2 + 2 + 4;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: stringBuf.Append (HexDump.ToHex (((short)(options >> 4))));  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF007)) && 36 <= remainingBytes && 36 <= recordBytesRemaining) {  	// BSE' FBSE  	//                ULONG nP = pIn->GetRecPos();  	byte n8;  	//                short n16;  	//                int n32;  	stringBuf = new StringBuilder ("    btWin32: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	stringBuf.Append ("  btMacOS: ");  	n8 = (byte)in1.ReadByte ();  	stringBuf.Append (HexDump.ToHex (n8));  	stringBuf.Append (GetBlipType (n8));  	Console.WriteLine (stringBuf.ToString ());  	Console.WriteLine ("    rgbUid:");  	HexDump.Dump (in1' 0' 16);  	Console.Write ("    tag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    size: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cRef: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    offs: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    usage: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    cbName: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused2: ");  	OutHex (4' in1);  	Console.WriteLine ();  	Console.Write ("    unused3: ");  	OutHex (4' in1);  	Console.WriteLine ();  	// subtract the number of bytes we've Read  	remainingBytes -= 36;  	//n -= pIn->GetRecPos() - nP;  	recordBytesRemaining = 0;  	// loop to MsofbtBLIP  }  else if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: HexDump.Dump (in1' 0' 16);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (4' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 36;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF010) && 0x12 <= remainingBytes && 0x12 <= recordBytesRemaining) {  	// ClientAnchor  	//ULONG nP = pIn->GetRecPos();  	//                short n16;  	Console.Write ("    Flag: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col1: ");  	OutHex (2' in1);  	Console.Write ("    dX1: ");  	OutHex (2' in1);  	Console.Write ("    Row1: ");  	OutHex (2' in1);  	Console.Write ("    dY1: ");  	OutHex (2' in1);  	Console.WriteLine ();  	Console.Write ("    Col2: ");  	OutHex (2' in1);  	Console.Write ("    dX2: ");  	OutHex (2' in1);  	Console.Write ("    Row2: ");  	OutHex (2' in1);  	Console.Write ("    dY2: ");  	OutHex (2' in1);  	Console.WriteLine ();  	remainingBytes -= 18;  	recordBytesRemaining -= 18;  }  else if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: OutHex (2' in1);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 18;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: recordBytesRemaining -= 18;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == unchecked((short)0xF00B) || recordId == unchecked((short)0xF122)) {  	// OPT  	int nComplex = 0;  	Console.WriteLine ("    PROPID        VALUE");  	while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  		short n16;  		int n32;  		n16 = LittleEndian.ReadShort (in1);  		n32 = LittleEndian.ReadInt (in1);  		recordBytesRemaining -= 6;  		remainingBytes -= 6;  		Console.Write ("    ");  		Console.Write (HexDump.ToHex (n16));  		Console.Write (" (");  		int propertyId = n16 & (short)0x3FFF;  		Console.Write (" " + propertyId);  		if ((n16 & unchecked((short)0x8000)) == 0) {  			if ((n16 & (short)0x4000) != 0)  				Console.Write ("' fBlipID");  			Console.Write (")  ");  			Console.Write (HexDump.ToHex (n32));  			if ((n16 & (short)0x4000) == 0) {  				Console.Write (" (");  				Console.Write (Dec1616 (n32));  				Console.Write (')');  				Console.Write (" {" + PropertyName ((short)propertyId) + "}");  			}  			Console.WriteLine ();  		}  		else {  			Console.Write ("' fComplex)  ");  			Console.Write (HexDump.ToHex (n32));  			Console.Write (" - Complex prop len");  			Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  			nComplex += n32;  		}  	}  	// complex property data  	while ((nComplex & remainingBytes) > 0) {  		nDumpSize = (nComplex > (int)remainingBytes) ? (short)remainingBytes : (short)nComplex;  		HexDump.Dump (in1' 0' nDumpSize);  		nComplex -= nDumpSize;  		recordBytesRemaining -= nDumpSize;  		remainingBytes -= nDumpSize;  	}  }  else if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  	short n16;  	int n32;  	n16 = LittleEndian.ReadShort (in1);  	n32 = LittleEndian.ReadInt (in1);  	recordBytesRemaining -= 6;  	remainingBytes -= 6;  	Console.Write ("    ");  	Console.Write (HexDump.ToHex (n16));  	Console.Write (" (");  	int propertyId = n16 & (short)0x3FFF;  	Console.Write (" " + propertyId);  	if ((n16 & unchecked((short)0x8000)) == 0) {  		if ((n16 & (short)0x4000) != 0)  			Console.Write ("' fBlipID");  		Console.Write (")  ");  		Console.Write (HexDump.ToHex (n32));  		if ((n16 & (short)0x4000) == 0) {  			Console.Write (" (");  			Console.Write (Dec1616 (n32));  			Console.Write (')');  			Console.Write (" {" + PropertyName ((short)propertyId) + "}");  		}  		Console.WriteLine ();  	}  	else {  		Console.Write ("' fComplex)  ");  		Console.Write (HexDump.ToHex (n32));  		Console.Write (" - Complex prop len");  		Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  		nComplex += n32;  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  	short n16;  	int n32;  	n16 = LittleEndian.ReadShort (in1);  	n32 = LittleEndian.ReadInt (in1);  	recordBytesRemaining -= 6;  	remainingBytes -= 6;  	Console.Write ("    ");  	Console.Write (HexDump.ToHex (n16));  	Console.Write (" (");  	int propertyId = n16 & (short)0x3FFF;  	Console.Write (" " + propertyId);  	if ((n16 & unchecked((short)0x8000)) == 0) {  		if ((n16 & (short)0x4000) != 0)  			Console.Write ("' fBlipID");  		Console.Write (")  ");  		Console.Write (HexDump.ToHex (n32));  		if ((n16 & (short)0x4000) == 0) {  			Console.Write (" (");  			Console.Write (Dec1616 (n32));  			Console.Write (')');  			Console.Write (" {" + PropertyName ((short)propertyId) + "}");  		}  		Console.WriteLine ();  	}  	else {  		Console.Write ("' fComplex)  ");  		Console.Write (HexDump.ToHex (n32));  		Console.Write (" - Complex prop len");  		Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  		nComplex += n32;  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  	short n16;  	int n32;  	n16 = LittleEndian.ReadShort (in1);  	n32 = LittleEndian.ReadInt (in1);  	recordBytesRemaining -= 6;  	remainingBytes -= 6;  	Console.Write ("    ");  	Console.Write (HexDump.ToHex (n16));  	Console.Write (" (");  	int propertyId = n16 & (short)0x3FFF;  	Console.Write (" " + propertyId);  	if ((n16 & unchecked((short)0x8000)) == 0) {  		if ((n16 & (short)0x4000) != 0)  			Console.Write ("' fBlipID");  		Console.Write (")  ");  		Console.Write (HexDump.ToHex (n32));  		if ((n16 & (short)0x4000) == 0) {  			Console.Write (" (");  			Console.Write (Dec1616 (n32));  			Console.Write (')');  			Console.Write (" {" + PropertyName ((short)propertyId) + "}");  		}  		Console.WriteLine ();  	}  	else {  		Console.Write ("' fComplex)  ");  		Console.Write (HexDump.ToHex (n32));  		Console.Write (" - Complex prop len");  		Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  		nComplex += n32;  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: while (recordBytesRemaining >= 6 + nComplex && remainingBytes >= 6 + nComplex) {  	short n16;  	int n32;  	n16 = LittleEndian.ReadShort (in1);  	n32 = LittleEndian.ReadInt (in1);  	recordBytesRemaining -= 6;  	remainingBytes -= 6;  	Console.Write ("    ");  	Console.Write (HexDump.ToHex (n16));  	Console.Write (" (");  	int propertyId = n16 & (short)0x3FFF;  	Console.Write (" " + propertyId);  	if ((n16 & unchecked((short)0x8000)) == 0) {  		if ((n16 & (short)0x4000) != 0)  			Console.Write ("' fBlipID");  		Console.Write (")  ");  		Console.Write (HexDump.ToHex (n32));  		if ((n16 & (short)0x4000) == 0) {  			Console.Write (" (");  			Console.Write (Dec1616 (n32));  			Console.Write (')');  			Console.Write (" {" + PropertyName ((short)propertyId) + "}");  		}  		Console.WriteLine ();  	}  	else {  		Console.Write ("' fComplex)  ");  		Console.Write (HexDump.ToHex (n32));  		Console.Write (" - Complex prop len");  		Console.WriteLine (" {" + PropertyName ((short)propertyId) + "}");  		nComplex += n32;  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: recordBytesRemaining -= 6;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 6;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId == (unchecked((short)0xF012))) {  	Console.Write ("    Connector rule: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   ShapeID B: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("    ShapeID connector: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt A: ");  	Console.Write (LittleEndian.ReadInt (in1));  	Console.Write ("   Connect pt B: ");  	Console.WriteLine (LittleEndian.ReadInt (in1));  	recordBytesRemaining -= 24;  	remainingBytes -= 24;  }  else if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: recordBytesRemaining -= 24;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 24;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: if (recordId >= unchecked((short)0xF018) && recordId < unchecked((short)0xF117)) {  	Console.WriteLine ("    Secondary UID: ");  	HexDump.Dump (in1' 0' 16);  	Console.WriteLine ("    Cache of size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary top: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary left: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary width: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Boundary height: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    X: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Y: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Cache of saved size: " + HexDump.ToHex (LittleEndian.ReadInt (in1)));  	Console.WriteLine ("    Compression Flag: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Filter: " + HexDump.ToHex ((byte)in1.ReadByte ()));  	Console.WriteLine ("    Data (after decompression): ");  	recordBytesRemaining -= 34 + 16;  	remainingBytes -= 34 + 16;  	nDumpSize = (recordBytesRemaining > (int)remainingBytes) ? (short)remainingBytes : (short)recordBytesRemaining;  	byte[] buf = new byte[nDumpSize];  	int Read = in1.Read (buf' 0' buf.Length);  	while (Read != -1 && Read < nDumpSize)  		Read += in1.Read (buf' Read' buf.Length);  	using (MemoryStream bin = new MemoryStream (buf)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream zIn = new InflaterInputStream (bin' inflater)) {  			int bytesToDump = -1;  			HexDump.Dump (zIn' 0' bytesToDump);  			recordBytesRemaining -= nDumpSize;  			remainingBytes -= nDumpSize;  		}  	}  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: HexDump.Dump (in1' 0' 16);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: recordBytesRemaining -= 34 + 16;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: recordBytesRemaining -= 34 + 16;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 34 + 16;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,DumpOld,The following statement contains a magic number: remainingBytes -= 34 + 16;  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: switch (b) {  case 0:  	return " ERROR";  case 1:  	return " UNKNOWN";  case 2:  	return " EMF";  case 3:  	return " WMF";  case 4:  	return " PICT";  case 5:  	return " JPEG";  case 6:  	return " PNG";  case 7:  	return " DIB";  default:  	if (b < 32)  		return " NotKnown";  	else  		return " Client";  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,GetBlipType,The following statement contains a magic number: if (b < 32)  	return " NotKnown";  else  	return " Client";  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,Dec1616,The following statement contains a magic number: result += (short)(n32 >> 16);  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,OutHex,The following statement contains a magic number: switch (bytes) {  case 1:  	Console.Write (HexDump.ToHex ((byte)in1.ReadByte ()));  	break;  case 2:  	Console.Write (HexDump.ToHex (LittleEndian.ReadShort (in1)));  	break;  case 4:  	Console.Write (HexDump.ToHex (LittleEndian.ReadInt (in1)));  	break;  default:  	throw new IOException ("Unable to output variable of that width");  }  
Magic Number,NPOI.DDF,EscherDump,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherDump.cs,OutHex,The following statement contains a magic number: switch (bytes) {  case 1:  	Console.Write (HexDump.ToHex ((byte)in1.ReadByte ()));  	break;  case 2:  	Console.Write (HexDump.ToHex (LittleEndian.ReadShort (in1)));  	break;  case 4:  	Console.Write (HexDump.ToHex (LittleEndian.ReadInt (in1)));  	break;  default:  	throw new IOException ("Unable to output variable of that width");  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: field_1_UID = new byte[16];  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos' field_1_UID' 0' 16);  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: if ((Options ^ Signature) == 0x10) {  	field_2_UID = new byte[16];  	Array.Copy (data' pos' field_2_UID' 0' 16);  	pos += 16;  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: if ((Options ^ Signature) == 0x10) {  	field_2_UID = new byte[16];  	Array.Copy (data' pos' field_2_UID' 0' 16);  	pos += 16;  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: if ((Options ^ Signature) == 0x10) {  	field_2_UID = new byte[16];  	Array.Copy (data' pos' field_2_UID' 0' 16);  	pos += 16;  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: field_2_UID = new byte[16];  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos' field_2_UID' 0' 16);  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,InflatePictureData,The following statement contains a magic number: using (MemoryStream in1 = new MemoryStream (data)) {  	using (MemoryStream out1 = new MemoryStream ()) {  		InflaterInputStream zIn = null;  		try {  			Inflater inflater = new Inflater (false);  			zIn = new InflaterInputStream (in1' inflater);  			byte[] buf = new byte[4096];  			int ReadBytes;  			while ((ReadBytes = zIn.Read (buf' 0' buf.Length)) > 0) {  				out1.Write (buf' 0' ReadBytes);  			}  			return out1.ToArray ();  		}  		catch (IOException e) {  			log.Log (POILogger.WARN' "Possibly corrupt compression or non-compressed data"' e);  			return data;  		}  	}  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,InflatePictureData,The following statement contains a magic number: using (MemoryStream out1 = new MemoryStream ()) {  	InflaterInputStream zIn = null;  	try {  		Inflater inflater = new Inflater (false);  		zIn = new InflaterInputStream (in1' inflater);  		byte[] buf = new byte[4096];  		int ReadBytes;  		while ((ReadBytes = zIn.Read (buf' 0' buf.Length)) > 0) {  			out1.Write (buf' 0' ReadBytes);  		}  		return out1.ToArray ();  	}  	catch (IOException e) {  		log.Log (POILogger.WARN' "Possibly corrupt compression or non-compressed data"' e);  		return data;  	}  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,InflatePictureData,The following statement contains a magic number: try {  	Inflater inflater = new Inflater (false);  	zIn = new InflaterInputStream (in1' inflater);  	byte[] buf = new byte[4096];  	int ReadBytes;  	while ((ReadBytes = zIn.Read (buf' 0' buf.Length)) > 0) {  		out1.Write (buf' 0' ReadBytes);  	}  	return out1.ToArray ();  }  catch (IOException e) {  	log.Log (POILogger.WARN' "Possibly corrupt compression or non-compressed data"' e);  	return data;  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,ToString,The following statement contains a magic number: using (MemoryStream b = new MemoryStream ()) {  	try {  		HexDump.Dump (this.field_pictureData' 0' b' 0);  		extraData = b.ToString ();  	}  	catch (Exception e) {  		extraData = e.ToString ();  	}  	return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  UID: 0x" + HexDump.ToHex (field_1_UID) + nl + (field_2_UID == null ? "" : ("  UID2: 0x" + HexDump.ToHex (field_2_UID) + nl)) + "  Uncompressed Size: " + HexDump.ToHex (field_2_cb) + nl + "  Bounds: " + Bounds + nl + "  Size in EMU: " + SizeEMU + nl + "  Compressed Size: " + HexDump.ToHex (field_5_cbSave) + nl + "  Compression: " + HexDump.ToHex (field_6_fCompression) + nl + "  Filter: " + HexDump.ToHex (field_7_fFilter) + nl + "  Extra Data:" + nl + extraData + (remainingData == null ? null : ("\n" + " Remaining Data: " + HexDump.ToHex (remainingData' 32)));  }  
Magic Number,NPOI.DDF,EscherMetafileBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherMetafileBlip.cs,ToString,The following statement contains a magic number: return GetType ().Name + ":" + nl + "  RecordId: 0x" + HexDump.ToHex (RecordId) + nl + "  Options: 0x" + HexDump.ToHex (Options) + nl + "  UID: 0x" + HexDump.ToHex (field_1_UID) + nl + (field_2_UID == null ? "" : ("  UID2: 0x" + HexDump.ToHex (field_2_UID) + nl)) + "  Uncompressed Size: " + HexDump.ToHex (field_2_cb) + nl + "  Bounds: " + Bounds + nl + "  Size in EMU: " + SizeEMU + nl + "  Compressed Size: " + HexDump.ToHex (field_5_cbSave) + nl + "  Compression: " + HexDump.ToHex (field_6_fCompression) + nl + "  Filter: " + HexDump.ToHex (field_7_fFilter) + nl + "  Extra Data:" + nl + extraData + (remainingData == null ? null : ("\n" + " Remaining Data: " + HexDump.ToHex (remainingData' 32)));  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: field_1_UID = new byte[16];  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: Array.Copy (data' pos' field_1_UID' 0' 16);  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,FillFields,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: Array.Copy (field_1_UID' 0' data' pos' 16);  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 16;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,Serialize,The following statement contains a magic number: return HEADER_SIZE + 16 + 1 + raw_pictureData.Length;  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,InflatePictureData,The following statement contains a magic number: using (MemoryStream out1 = new MemoryStream ()) {  	try {  		using (MemoryStream ms = new MemoryStream (data)) {  			Inflater inflater = new Inflater (false);  			using (InflaterInputStream in1 = new InflaterInputStream (ms' inflater)) {  				byte[] buf = new byte[4096];  				int ReadBytes;  				while ((ReadBytes = in1.Read (buf' 0' buf.Length)) > 0) {  					out1.Write (buf' 0' ReadBytes);  				}  				return out1.ToArray ();  			}  		}  	}  	catch (IOException e) {  		log.Log (POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  		return data;  	}  }  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,InflatePictureData,The following statement contains a magic number: try {  	using (MemoryStream ms = new MemoryStream (data)) {  		Inflater inflater = new Inflater (false);  		using (InflaterInputStream in1 = new InflaterInputStream (ms' inflater)) {  			byte[] buf = new byte[4096];  			int ReadBytes;  			while ((ReadBytes = in1.Read (buf' 0' buf.Length)) > 0) {  				out1.Write (buf' 0' ReadBytes);  			}  			return out1.ToArray ();  		}  	}  }  catch (IOException e) {  	log.Log (POILogger.INFO' "Possibly corrupt compression or non-compressed data"' e);  	return data;  }  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,InflatePictureData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream (data)) {  	Inflater inflater = new Inflater (false);  	using (InflaterInputStream in1 = new InflaterInputStream (ms' inflater)) {  		byte[] buf = new byte[4096];  		int ReadBytes;  		while ((ReadBytes = in1.Read (buf' 0' buf.Length)) > 0) {  			out1.Write (buf' 0' ReadBytes);  		}  		return out1.ToArray ();  	}  }  
Magic Number,NPOI.DDF,EscherPictBlip,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPictBlip.cs,InflatePictureData,The following statement contains a magic number: using (InflaterInputStream in1 = new InflaterInputStream (ms' inflater)) {  	byte[] buf = new byte[4096];  	int ReadBytes;  	while ((ReadBytes = in1.Read (buf' 0' buf.Length)) > 0) {  		out1.Write (buf' 0' ReadBytes);  	}  	return out1.ToArray ();  }  
Magic Number,NPOI.DDF,EscherPropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPropertyFactory.cs,CreateProperties,The following statement contains a magic number: for (int i = 0; i < numProperties; i++) {  	short propId;  	int propData;  	propId = LittleEndian.GetShort (data' pos);  	propData = LittleEndian.GetInt (data' pos + 2);  	short propNumber = (short)(propId & (short)0x3FFF);  	bool isComplex = (propId & unchecked((short)0x8000)) != 0;  	bool isBlipId = (propId & (short)0x4000) != 0;  	byte propertyType = EscherProperties.GetPropertyType ((short)propNumber);  	if (propertyType == EscherPropertyMetaData.TYPE_bool)  		results.Add (new EscherBoolProperty (propId' propData));  	else if (propertyType == EscherPropertyMetaData.TYPE_RGB)  		results.Add (new EscherRGBProperty (propId' propData));  	else if (propertyType == EscherPropertyMetaData.TYPE_SHAPEPATH)  		results.Add (new EscherShapePathProperty (propId' propData));  	else {  		if (!isComplex)  			results.Add (new EscherSimpleProperty (propId' propData));  		else {  			if (propertyType == EscherPropertyMetaData.TYPE_ARRAY)  				results.Add (new EscherArrayProperty (propId' new byte[propData]));  			else  				results.Add (new EscherComplexProperty (propId' new byte[propData]));  		}  	}  	pos += 6;  	//            bytesRemaining -= 6 + complexBytes;  }  
Magic Number,NPOI.DDF,EscherPropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPropertyFactory.cs,CreateProperties,The following statement contains a magic number: for (int i = 0; i < numProperties; i++) {  	short propId;  	int propData;  	propId = LittleEndian.GetShort (data' pos);  	propData = LittleEndian.GetInt (data' pos + 2);  	short propNumber = (short)(propId & (short)0x3FFF);  	bool isComplex = (propId & unchecked((short)0x8000)) != 0;  	bool isBlipId = (propId & (short)0x4000) != 0;  	byte propertyType = EscherProperties.GetPropertyType ((short)propNumber);  	if (propertyType == EscherPropertyMetaData.TYPE_bool)  		results.Add (new EscherBoolProperty (propId' propData));  	else if (propertyType == EscherPropertyMetaData.TYPE_RGB)  		results.Add (new EscherRGBProperty (propId' propData));  	else if (propertyType == EscherPropertyMetaData.TYPE_SHAPEPATH)  		results.Add (new EscherShapePathProperty (propId' propData));  	else {  		if (!isComplex)  			results.Add (new EscherSimpleProperty (propId' propData));  		else {  			if (propertyType == EscherPropertyMetaData.TYPE_ARRAY)  				results.Add (new EscherArrayProperty (propId' new byte[propData]));  			else  				results.Add (new EscherComplexProperty (propId' new byte[propData]));  		}  	}  	pos += 6;  	//            bytesRemaining -= 6 + complexBytes;  }  
Magic Number,NPOI.DDF,EscherPropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPropertyFactory.cs,CreateProperties,The following statement contains a magic number: propData = LittleEndian.GetInt (data' pos + 2);  
Magic Number,NPOI.DDF,EscherPropertyFactory,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherPropertyFactory.cs,CreateProperties,The following statement contains a magic number: pos += 6;  
Magic Number,NPOI.DDF,EscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherRecord.cs,Display,The following statement contains a magic number: for (int i = 0; i < indent * 4; i++) {  	Console.Write (' ');  }  
Magic Number,NPOI.DDF,EscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherRecord.cs,GetInstance,The following statement contains a magic number: return (short)(options >> 4);  
Magic Number,NPOI.DDF,EscherSimpleProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSimpleProperty.cs,SerializeSimplePart,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 2' propertyValue);  
Magic Number,NPOI.DDF,EscherSimpleProperty,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSimpleProperty.cs,SerializeSimplePart,The following statement contains a magic number: return 6;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,FillFields,The following statement contains a magic number: return 8 + size + bytesRemaining;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 8' field_1_rectX1);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 12' field_2_rectY1);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 16' field_3_rectX2);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 20' field_4_rectY2);  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: return 8 + 16;  
Magic Number,NPOI.DDF,EscherSpgrRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpgrRecord.cs,Serialize,The following statement contains a magic number: return 8 + 16;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,FillFields,The following statement contains a magic number: return 8 + size + bytesRemaining;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherSplitMenuColorsRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSplitMenuColorsRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,FillFields,The following statement contains a magic number: size += 4;  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 8' field_1_shapeId);  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 12' field_2_flags);  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: return 8 + 8;  
Magic Number,NPOI.DDF,EscherSpRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherSpRecord.cs,Serialize,The following statement contains a magic number: return 8 + 8;  
Magic Number,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,FillFields,The following statement contains a magic number: Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  
Magic Number,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,FillFields,The following statement contains a magic number: return bytesRemaining + 8;  
Magic Number,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,EscherTextboxRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\EscherTextboxRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (thedata' 0' data' offset + 8' thedata.Length);  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: if (IsContainerRecord) {  	int bytesWritten = 0;  	thedata = new byte[0];  	offset += 8;  	bytesWritten += 8;  	while (bytesRemaining > 0) {  		EscherRecord child = recordFactory.CreateRecord (data' offset);  		int childBytesWritten = child.FillFields (data' offset' recordFactory);  		bytesWritten += childBytesWritten;  		offset += childBytesWritten;  		bytesRemaining -= childBytesWritten;  		ChildRecords.Add (child);  	}  	return bytesWritten;  }  else {  	thedata = new byte[bytesRemaining];  	Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  	return bytesRemaining + 8;  }  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: if (IsContainerRecord) {  	int bytesWritten = 0;  	thedata = new byte[0];  	offset += 8;  	bytesWritten += 8;  	while (bytesRemaining > 0) {  		EscherRecord child = recordFactory.CreateRecord (data' offset);  		int childBytesWritten = child.FillFields (data' offset' recordFactory);  		bytesWritten += childBytesWritten;  		offset += childBytesWritten;  		bytesRemaining -= childBytesWritten;  		ChildRecords.Add (child);  	}  	return bytesWritten;  }  else {  	thedata = new byte[bytesRemaining];  	Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  	return bytesRemaining + 8;  }  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: if (IsContainerRecord) {  	int bytesWritten = 0;  	thedata = new byte[0];  	offset += 8;  	bytesWritten += 8;  	while (bytesRemaining > 0) {  		EscherRecord child = recordFactory.CreateRecord (data' offset);  		int childBytesWritten = child.FillFields (data' offset' recordFactory);  		bytesWritten += childBytesWritten;  		offset += childBytesWritten;  		bytesRemaining -= childBytesWritten;  		ChildRecords.Add (child);  	}  	return bytesWritten;  }  else {  	thedata = new byte[bytesRemaining];  	Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  	return bytesRemaining + 8;  }  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: if (IsContainerRecord) {  	int bytesWritten = 0;  	thedata = new byte[0];  	offset += 8;  	bytesWritten += 8;  	while (bytesRemaining > 0) {  		EscherRecord child = recordFactory.CreateRecord (data' offset);  		int childBytesWritten = child.FillFields (data' offset' recordFactory);  		bytesWritten += childBytesWritten;  		offset += childBytesWritten;  		bytesRemaining -= childBytesWritten;  		ChildRecords.Add (child);  	}  	return bytesWritten;  }  else {  	thedata = new byte[bytesRemaining];  	Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  	return bytesRemaining + 8;  }  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: offset += 8;  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: bytesWritten += 8;  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: Array.Copy (data' offset + 8' thedata' 0' bytesRemaining);  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,FillFields,The following statement contains a magic number: return bytesRemaining + 8;  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' offset + 2' RecordId);  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutInt (data' offset + 4' remainingBytes);  
Magic Number,NPOI.DDF,UnknownEscherRecord,C:\repos\xoposhiy_npoi\trunk\main\DDF\UnknownEscherRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (thedata' 0' data' offset + 8' thedata.Length);  
Magic Number,NPOI.HSSF.Record.Aggregates,CFRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\CFRecordsAggregate.cs,CFRecordsAggregate,The following statement contains a magic number: rules = new List<CFRuleRecord> (3);  
Magic Number,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,GroupColumnRange,The following statement contains a magic number: for (int i = fromColumnIx; i <= toColumnIx; i++) {  	int level = 1;  	int colInfoIdx = FindColInfoIdx (i' colInfoSearchStartIdx);  	if (colInfoIdx != -1) {  		level = GetColInfo (colInfoIdx).OutlineLevel;  		if (indent) {  			level++;  		}  		else {  			level--;  		}  		level = Math.Max (0' level);  		level = Math.Min (7' level);  		colInfoSearchStartIdx = Math.Max (0' colInfoIdx - 1);  		// -1 just in case this column is collapsed later.  	}  	SetColumn (i' null' null' level' null' null);  }  
Magic Number,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,GroupColumnRange,The following statement contains a magic number: if (colInfoIdx != -1) {  	level = GetColInfo (colInfoIdx).OutlineLevel;  	if (indent) {  		level++;  	}  	else {  		level--;  	}  	level = Math.Max (0' level);  	level = Math.Min (7' level);  	colInfoSearchStartIdx = Math.Max (0' colInfoIdx - 1);  	// -1 just in case this column is collapsed later.  }  
Magic Number,NPOI.HSSF.Record.Aggregates,ColumnInfoRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ColumnInfoRecordsAggregate.cs,GroupColumnRange,The following statement contains a magic number: level = Math.Min (7' level);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.Scale = ((short)100);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.Options = ((short)2);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.HResolution = ((short)300);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.VResolution = ((short)300);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.HeaderMargin = (0.5);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,CreatePrintSetup,The following statement contains a magic number: retval.FooterMargin = (0.5);  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: if (m != null) {  	return m.Margin;  }  else {  	switch (margin) {  	case MarginType.LeftMargin:  		return .75;  	case MarginType.RightMargin:  		return .75;  	case MarginType.TopMargin:  		return 1.0;  	case MarginType.BottomMargin:  		return 1.0;  	}  	throw new InvalidOperationException ("Unknown margin constant:  " + margin);  }  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: if (m != null) {  	return m.Margin;  }  else {  	switch (margin) {  	case MarginType.LeftMargin:  		return .75;  	case MarginType.RightMargin:  		return .75;  	case MarginType.TopMargin:  		return 1.0;  	case MarginType.BottomMargin:  		return 1.0;  	}  	throw new InvalidOperationException ("Unknown margin constant:  " + margin);  }  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: switch (margin) {  case MarginType.LeftMargin:  	return .75;  case MarginType.RightMargin:  	return .75;  case MarginType.TopMargin:  	return 1.0;  case MarginType.BottomMargin:  	return 1.0;  }  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: switch (margin) {  case MarginType.LeftMargin:  	return .75;  case MarginType.RightMargin:  	return .75;  case MarginType.TopMargin:  	return 1.0;  case MarginType.BottomMargin:  	return 1.0;  }  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: return .75;  
Magic Number,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following statement contains a magic number: return .75;  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,GetRow,The following statement contains a magic number: if (rowIndex < 0 || rowIndex > 65535) {  	throw new ArgumentException ("The row number must be between 0 and 65535");  }  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,GetRowBlockSize,The following statement contains a magic number: return 20 * GetRowCountForBlock (block);  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,CreateIndexRecord,The following statement contains a magic number: for (int block = 0; block < blockCount; block++) {  	// each row-block has a DBCELL record.  	// The offset of each DBCELL record needs to be updated in the INDEX record  	// account for row records in this row-block  	currentOffset += GetRowBlockSize (block);  	// account for cell value records after those  	currentOffset += _valuesAgg.GetRowCellBlockSize (GetStartRowNumberForBlock (block)' GetEndRowNumberForBlock (block));  	// currentOffset is now the location of the DBCELL record for this row-block  	result.AddDbcell (currentOffset);  	// Add space required to write the DBCELL record (whose reference was just added).  	currentOffset += (8 + (GetRowCountForBlock (block) * 2));  }  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,CreateIndexRecord,The following statement contains a magic number: for (int block = 0; block < blockCount; block++) {  	// each row-block has a DBCELL record.  	// The offset of each DBCELL record needs to be updated in the INDEX record  	// account for row records in this row-block  	currentOffset += GetRowBlockSize (block);  	// account for cell value records after those  	currentOffset += _valuesAgg.GetRowCellBlockSize (GetStartRowNumberForBlock (block)' GetEndRowNumberForBlock (block));  	// currentOffset is now the location of the DBCELL record for this row-block  	result.AddDbcell (currentOffset);  	// Add space required to write the DBCELL record (whose reference was just added).  	currentOffset += (8 + (GetRowCountForBlock (block) * 2));  }  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,CreateIndexRecord,The following statement contains a magic number: currentOffset += (8 + (GetRowCountForBlock (block) * 2));  
Magic Number,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,CreateIndexRecord,The following statement contains a magic number: currentOffset += (8 + (GetRowCountForBlock (block) * 2));  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (row >= records.Length) {  	CellValueRecordInterface[][] oldRecords = records;  	int newSize = oldRecords.Length * 2;  	if (newSize < row + 1)  		newSize = row + 1;  	records = new CellValueRecordInterface[newSize][];  	Array.Copy (oldRecords' 0' records' 0' oldRecords.Length);  }  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (objRowCells == null) {  	int newSize = column + 1;  	if (newSize < 10)  		newSize = 10;  	objRowCells = new CellValueRecordInterface[newSize];  	records [row] = (CellValueRecordInterface[])objRowCells;  }  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (objRowCells == null) {  	int newSize = column + 1;  	if (newSize < 10)  		newSize = 10;  	objRowCells = new CellValueRecordInterface[newSize];  	records [row] = (CellValueRecordInterface[])objRowCells;  }  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (newSize < 10)  	newSize = 10;  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (newSize < 10)  	newSize = 10;  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: newSize = 10;  
Magic Number,NPOI.HSSF.Record.Aggregates,ValueRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\ValueRecordsAggregate.cs,InsertCell,The following statement contains a magic number: if (column >= rowCells.Length) {  	CellValueRecordInterface[] oldRowCells = rowCells;  	int newSize = oldRowCells.Length * 2;  	if (newSize < column + 1)  		newSize = column + 1;  	// if(newSize>257) newSize=257; // activate?  	rowCells = new CellValueRecordInterface[newSize];  	Array.Copy (oldRowCells' 0' rowCells' 0' oldRowCells.Length);  	records [row] = rowCells;  }  
Magic Number,NPOI.HSSF.Record.Common,FtrHeader,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Common\FtrHeader.cs,FtrHeader,The following statement contains a magic number: reserved = new byte[8];  
Magic Number,NPOI.HSSF.Record.Common,FtrHeader,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Common\FtrHeader.cs,FtrHeader,The following statement contains a magic number: reserved = new byte[8];  
Magic Number,NPOI.HSSF.Record.Common,FtrHeader,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Common\FtrHeader.cs,FtrHeader,The following statement contains a magic number: in1.Read (reserved' 0' 8);  
Magic Number,NPOI.HSSF.Record.Common,FtrHeader,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Common\FtrHeader.cs,GetDataSize,The following statement contains a magic number: return 12;  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The following statement contains a magic number: if (IsExtendedText && (extensionLength > 0)) {  	field_5_ext_rst = new ExtRst (new ContinuableRecordInput (in1)' extensionLength);  	if (field_5_ext_rst.DataSize + 4 != extensionLength) {  		_logger.Log (POILogger.WARN' "ExtRst was supposed to be " + extensionLength + " bytes long' but seems to actually be " + (field_5_ext_rst.DataSize + 4));  	}  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The following statement contains a magic number: if (IsExtendedText && (extensionLength > 0)) {  	field_5_ext_rst = new ExtRst (new ContinuableRecordInput (in1)' extensionLength);  	if (field_5_ext_rst.DataSize + 4 != extensionLength) {  		_logger.Log (POILogger.WARN' "ExtRst was supposed to be " + extensionLength + " bytes long' but seems to actually be " + (field_5_ext_rst.DataSize + 4));  	}  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The following statement contains a magic number: if (field_5_ext_rst.DataSize + 4 != extensionLength) {  	_logger.Log (POILogger.WARN' "ExtRst was supposed to be " + extensionLength + " bytes long' but seems to actually be " + (field_5_ext_rst.DataSize + 4));  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The following statement contains a magic number: if (field_5_ext_rst.DataSize + 4 != extensionLength) {  	_logger.Log (POILogger.WARN' "ExtRst was supposed to be " + extensionLength + " bytes long' but seems to actually be " + (field_5_ext_rst.DataSize + 4));  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,UnicodeString,The following statement contains a magic number: _logger.Log (POILogger.WARN' "ExtRst was supposed to be " + extensionLength + " bytes long' but seems to actually be " + (field_5_ext_rst.DataSize + 4));  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Serialize,The following statement contains a magic number: if (IsExtendedText && field_5_ext_rst != null) {  	extendedDataSize = 4 + field_5_ext_rst.DataSize;  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Serialize,The following statement contains a magic number: extendedDataSize = 4 + field_5_ext_rst.DataSize;  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Serialize,The following statement contains a magic number: if (numberOfRichTextRuns > 0) {  	//This will ensure that a run does not split a continue  	for (int i = 0; i < numberOfRichTextRuns; i++) {  		if (out1.AvailableSpace < 4) {  			out1.WriteContinue ();  		}  		FormatRun r = field_4_format_Runs [(i)];  		r.Serialize (out1);  	}  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Serialize,The following statement contains a magic number: for (int i = 0; i < numberOfRichTextRuns; i++) {  	if (out1.AvailableSpace < 4) {  		out1.WriteContinue ();  	}  	FormatRun r = field_4_format_Runs [(i)];  	r.Serialize (out1);  }  
Magic Number,NPOI.HSSF.Record,UnicodeString,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnicodeString.cs,Serialize,The following statement contains a magic number: if (out1.AvailableSpace < 4) {  	out1.WriteContinue ();  }  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: if (escherRecords.Count == 0 && rawData != null) {  	LittleEndian.PutShort (data' 0 + offset' Sid);  	LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  	Array.Copy (rawData' 0' data' 4 + offset' rawData.Length);  	return rawData.Length + 4;  }  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: if (escherRecords.Count == 0 && rawData != null) {  	LittleEndian.PutShort (data' 0 + offset' Sid);  	LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  	Array.Copy (rawData' 0' data' 4 + offset' rawData.Length);  	return rawData.Length + 4;  }  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: if (escherRecords.Count == 0 && rawData != null) {  	LittleEndian.PutShort (data' 0 + offset' Sid);  	LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  	Array.Copy (rawData' 0' data' 4 + offset' rawData.Length);  	return rawData.Length + 4;  }  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: if (escherRecords.Count == 0 && rawData != null) {  	LittleEndian.PutShort (data' 0 + offset' Sid);  	LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  	Array.Copy (rawData' 0' data' 4 + offset' rawData.Length);  	return rawData.Length + 4;  }  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: Array.Copy (rawData' 0' data' 4 + offset' rawData.Length);  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: return rawData.Length + 4;  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,AbstractEscherHolderRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\AbstractEscherHolderRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)(RecordSize - 4));  
Magic Number,NPOI.HSSF.Record,BOFRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BOFRecord.cs,BOFRecord,The following statement contains a magic number: if (in1.Remaining >= 2) {  	field_3_build = in1.ReadShort ();  }  
Magic Number,NPOI.HSSF.Record,BOFRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BOFRecord.cs,BOFRecord,The following statement contains a magic number: if (in1.Remaining >= 2) {  	field_4_year = in1.ReadShort ();  }  
Magic Number,NPOI.HSSF.Record,BOFRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BOFRecord.cs,BOFRecord,The following statement contains a magic number: if (in1.Remaining >= 4) {  	field_5_history = in1.ReadInt ();  }  
Magic Number,NPOI.HSSF.Record,BOFRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BOFRecord.cs,BOFRecord,The following statement contains a magic number: if (in1.Remaining >= 4) {  	field_6_rversion = in1.ReadInt ();  }  
Magic Number,NPOI.HSSF.Record,BoolErrRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BoolErrRecord.cs,BoolErrRecord,The following statement contains a magic number: switch (in1.Remaining) {  case 2:  	_value = in1.ReadByte ();  	break;  case 3:  	_value = in1.ReadUShort ();  	break;  default:  	throw new RecordFormatException ("Unexpected size (" + in1.Remaining + ") for BOOLERR record.");  }  
Magic Number,NPOI.HSSF.Record,BoolErrRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BoolErrRecord.cs,BoolErrRecord,The following statement contains a magic number: switch (in1.Remaining) {  case 2:  	_value = in1.ReadByte ();  	break;  case 3:  	_value = in1.ReadUShort ();  	break;  default:  	throw new RecordFormatException ("Unexpected size (" + in1.Remaining + ") for BOOLERR record.");  }  
Magic Number,NPOI.HSSF.Record,ColumnInfoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ColumnInfoRecord.cs,ColumnInfoRecord,The following statement contains a magic number: this.ColumnWidth = 2275;  
Magic Number,NPOI.HSSF.Record,ColumnInfoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ColumnInfoRecord.cs,ColumnInfoRecord,The following statement contains a magic number: _options = 2;  
Magic Number,NPOI.HSSF.Record,ColumnInfoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ColumnInfoRecord.cs,ColumnInfoRecord,The following statement contains a magic number: field_6_reserved = 2;  
Magic Number,NPOI.HSSF.Record,ColumnInfoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ColumnInfoRecord.cs,ColumnInfoRecord,The following statement contains a magic number: switch (in1.Remaining) {  case 2:  	// usual case  	field_6_reserved = in1.ReadUShort ();  	break;  case 1:  	// often COLINFO Gets encoded 1 byte short  	// shouldn't matter because this field Is Unused  	field_6_reserved = in1.ReadByte ();  	break;  case 0:  	// According to bugzilla 48332'  	// "SoftArtisans OfficeWriter for Excel" totally skips field 6  	// Excel seems to be OK with this' and assumes zero.  	field_6_reserved = 0;  	break;  default:  	throw new Exception ("Unusual record size remaining=(" + in1.Remaining + ")");  }  
Magic Number,NPOI.HSSF.Record,ContinueRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ContinueRecord.cs,Write,The following statement contains a magic number: LittleEndian.PutUShort (destBuf' destOffset + 2' totalLen);  
Magic Number,NPOI.HSSF.Record,ContinueRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ContinueRecord.cs,Write,The following statement contains a magic number: return 4 + totalLen;  
Magic Number,NPOI.HSSF.Record,DBCellRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DBCellRecord.cs,DBCellRecord,The following statement contains a magic number: field_2_cell_offsets = new short[size / 2];  
Magic Number,NPOI.HSSF.Record,DBCellRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DBCellRecord.cs,CalculateSizeOfRecords,The following statement contains a magic number: return nBlocks * 8 + nRows * 2;  
Magic Number,NPOI.HSSF.Record,DBCellRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DBCellRecord.cs,CalculateSizeOfRecords,The following statement contains a magic number: return nBlocks * 8 + nRows * 2;  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,GrossSizeFromDataSize,The following statement contains a magic number: return dataSize + ((dataSize - 1) / MAX_DATA_SIZE + 1) * 4;  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: while (writtenRawData < rawData.Length) {  	int segmentLength = Math.Min (rawData.Length - writtenRawData' MAX_DATA_SIZE);  	if (writtenRawData / MAX_DATA_SIZE >= 2)  		WriteContinueHeader (data' offset' segmentLength);  	else  		WriteHeader (data' offset' segmentLength);  	writtenActualData += 4;  	offset += 4;  	Array.Copy (rawData' writtenRawData' data' offset' segmentLength);  	offset += segmentLength;  	writtenRawData += segmentLength;  	writtenActualData += segmentLength;  }  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: while (writtenRawData < rawData.Length) {  	int segmentLength = Math.Min (rawData.Length - writtenRawData' MAX_DATA_SIZE);  	if (writtenRawData / MAX_DATA_SIZE >= 2)  		WriteContinueHeader (data' offset' segmentLength);  	else  		WriteHeader (data' offset' segmentLength);  	writtenActualData += 4;  	offset += 4;  	Array.Copy (rawData' writtenRawData' data' offset' segmentLength);  	offset += segmentLength;  	writtenRawData += segmentLength;  	writtenActualData += segmentLength;  }  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: while (writtenRawData < rawData.Length) {  	int segmentLength = Math.Min (rawData.Length - writtenRawData' MAX_DATA_SIZE);  	if (writtenRawData / MAX_DATA_SIZE >= 2)  		WriteContinueHeader (data' offset' segmentLength);  	else  		WriteHeader (data' offset' segmentLength);  	writtenActualData += 4;  	offset += 4;  	Array.Copy (rawData' writtenRawData' data' offset' segmentLength);  	offset += segmentLength;  	writtenRawData += segmentLength;  	writtenActualData += segmentLength;  }  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: if (writtenRawData / MAX_DATA_SIZE >= 2)  	WriteContinueHeader (data' offset' segmentLength);  else  	WriteHeader (data' offset' segmentLength);  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: writtenActualData += 4;  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteData,The following statement contains a magic number: offset += 4;  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteHeader,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)sizeExcludingHeader);  
Magic Number,NPOI.HSSF.Record,DrawingGroupRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DrawingGroupRecord.cs,WriteContinueHeader,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' (short)sizeExcludingHeader);  
Magic Number,NPOI.HSSF.Record,DVRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DVRecord.cs,GetUnicodeStringSize,The following statement contains a magic number: return 3 + str.Length * (StringUtil.HasMultibyte (str) ? 2 : 1);  
Magic Number,NPOI.HSSF.Record,DVRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\DVRecord.cs,GetUnicodeStringSize,The following statement contains a magic number: return 3 + str.Length * (StringUtil.HasMultibyte (str) ? 2 : 1);  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: while (loc + 1 < records.Count && GetSid (records' loc) == DrawingRecord.sid && IsObjectRecord (records' loc + 1)) {  	dataSize += ((DrawingRecord)records [loc]).Data.Length;  	loc += 2;  }  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: loc += 2;  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: while (loc + 1 < records.Count && GetSid (records' loc) == DrawingRecord.sid && IsObjectRecord (records' loc + 1)) {  	DrawingRecord drawingRecord = (DrawingRecord)records [loc];  	Array.Copy (drawingRecord.Data' 0' buffer' offset' drawingRecord.Data.Length);  	offset += drawingRecord.Data.Length;  	loc += 2;  }  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: loc += 2;  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: while (loc + 1 < records.Count && GetSid (records' loc) == DrawingRecord.sid && IsObjectRecord (records' loc + 1)) {  	Record objRecord = (Record)records [loc + 1];  	agg.shapeToObj [shapeRecords [shapeIndex++]] = objRecord;  	loc += 2;  }  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,CreateAggregate,The following statement contains a magic number: loc += 2;  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The following statement contains a magic number: for (int i = 1; i < tcc.Count; i++) {  	EscherContainerRecord shapeContainer = (EscherContainerRecord)tcc [i];  	//Console.Error.WriteLine("\n\n*****\n\n");  	//Console.Error.WriteLine(shapeContainer);  	// Could be a Group' or a base object  	if (shapeContainer.RecordId == EscherContainerRecord.SPGR_CONTAINER) {  		if (shapeContainer.ChildRecords.Count > 0) {  			// Group  			HSSFShapeGroup group = new HSSFShapeGroup (null' new HSSFClientAnchor ());  			patriarch.Children.Add (group);  			EscherContainerRecord groupContainer = (EscherContainerRecord)shapeContainer.GetChild (0);  			ConvertRecordsToUserModel (groupContainer' group);  		}  	}  	else if (shapeContainer.RecordId == EscherContainerRecord.SP_CONTAINER) {  		EscherSpRecord spRecord = shapeContainer.GetChildById (EscherSpRecord.RECORD_ID);  		int type = spRecord.Options >> 4;  		switch (type) {  		case ST_TEXTBOX:  			// TextBox  			HSSFTextbox box = new HSSFTextbox (null' new HSSFClientAnchor ());  			patriarch.Children.Add (box);  			ConvertRecordsToUserModel (shapeContainer' box);  			break;  		case ST_PICTUREFRAME:  			// Duplicated from  			// org.apache.poi.hslf.model.Picture.getPictureIndex()  			EscherOptRecord opt = (EscherOptRecord)GetEscherChild (shapeContainer' EscherOptRecord.RECORD_ID);  			EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  			if (prop != null) {  				int pictureIndex = prop.PropertyValue;  				EscherClientAnchorRecord anchorRecord = (EscherClientAnchorRecord)GetEscherChild (shapeContainer' EscherClientAnchorRecord.RECORD_ID);  				HSSFClientAnchor anchor = new HSSFClientAnchor ();  				anchor.Col1 = anchorRecord.Col1;  				anchor.Col2 = anchorRecord.Col2;  				anchor.Dx1 = anchorRecord.Dx1;  				anchor.Dx2 = anchorRecord.Dx2;  				anchor.Dy1 = anchorRecord.Dy1;  				anchor.Dy2 = anchorRecord.Dy2;  				anchor.Row1 = anchorRecord.Row1;  				anchor.Row2 = anchorRecord.Row2;  				HSSFPicture picture = new HSSFPicture (null' anchor);  				picture.PictureIndex = pictureIndex;  				patriarch.AddShape (picture);  			}  			break;  		}  	}  	else {  		// Base level  		ConvertRecordsToUserModel (shapeContainer' patriarch);  	}  }  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The following statement contains a magic number: if (shapeContainer.RecordId == EscherContainerRecord.SPGR_CONTAINER) {  	if (shapeContainer.ChildRecords.Count > 0) {  		// Group  		HSSFShapeGroup group = new HSSFShapeGroup (null' new HSSFClientAnchor ());  		patriarch.Children.Add (group);  		EscherContainerRecord groupContainer = (EscherContainerRecord)shapeContainer.GetChild (0);  		ConvertRecordsToUserModel (groupContainer' group);  	}  }  else if (shapeContainer.RecordId == EscherContainerRecord.SP_CONTAINER) {  	EscherSpRecord spRecord = shapeContainer.GetChildById (EscherSpRecord.RECORD_ID);  	int type = spRecord.Options >> 4;  	switch (type) {  	case ST_TEXTBOX:  		// TextBox  		HSSFTextbox box = new HSSFTextbox (null' new HSSFClientAnchor ());  		patriarch.Children.Add (box);  		ConvertRecordsToUserModel (shapeContainer' box);  		break;  	case ST_PICTUREFRAME:  		// Duplicated from  		// org.apache.poi.hslf.model.Picture.getPictureIndex()  		EscherOptRecord opt = (EscherOptRecord)GetEscherChild (shapeContainer' EscherOptRecord.RECORD_ID);  		EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  		if (prop != null) {  			int pictureIndex = prop.PropertyValue;  			EscherClientAnchorRecord anchorRecord = (EscherClientAnchorRecord)GetEscherChild (shapeContainer' EscherClientAnchorRecord.RECORD_ID);  			HSSFClientAnchor anchor = new HSSFClientAnchor ();  			anchor.Col1 = anchorRecord.Col1;  			anchor.Col2 = anchorRecord.Col2;  			anchor.Dx1 = anchorRecord.Dx1;  			anchor.Dx2 = anchorRecord.Dx2;  			anchor.Dy1 = anchorRecord.Dy1;  			anchor.Dy2 = anchorRecord.Dy2;  			anchor.Row1 = anchorRecord.Row1;  			anchor.Row2 = anchorRecord.Row2;  			HSSFPicture picture = new HSSFPicture (null' anchor);  			picture.PictureIndex = pictureIndex;  			patriarch.AddShape (picture);  		}  		break;  	}  }  else {  	// Base level  	ConvertRecordsToUserModel (shapeContainer' patriarch);  }  
Magic Number,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The following statement contains a magic number: if (shapeContainer.RecordId == EscherContainerRecord.SP_CONTAINER) {  	EscherSpRecord spRecord = shapeContainer.GetChildById (EscherSpRecord.RECORD_ID);  	int type = spRecord.Options >> 4;  	switch (type) {  	case ST_TEXTBOX:  		// TextBox  		HSSFTextbox box = new HSSFTextbox (null' new HSSFClientAnchor ());  		patriarch.Children.Add (box);  		ConvertRecordsToUserModel (shapeContainer' box);  		break;  	case ST_PICTUREFRAME:  		// Duplicated from  		// org.apache.poi.hslf.model.Picture.getPictureIndex()  		EscherOptRecord opt = (EscherOptRecord)GetEscherChild (shapeContainer' EscherOptRecord.RECORD_ID);  		EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  		if (prop != null) {  			int pictureIndex = prop.PropertyValue;  			EscherClientAnchorRecord anchorRecord = (EscherClientAnchorRecord)GetEscherChild (shapeContainer' EscherClientAnchorRecord.RECORD_ID);  			HSSFClientAnchor anchor = new HSSFClientAnchor ();  			anchor.Col1 = anchorRecord.Col1;  			anchor.Col2 = anchorRecord.Col2;  			anchor.Dx1 = anchorRecord.Dx1;  			anchor.Dx2 = anchorRecord.Dx2;  			anchor.Dy1 = anchorRecord.Dy1;  			anchor.Dy2 = anchorRecord.Dy2;  			anchor.Row1 = anchorRecord.Row1;  			anchor.Row2 = anchorRecord.Row2;  			HSSFPicture picture = new HSSFPicture (null' anchor);  			picture.PictureIndex = pictureIndex;  			patriarch.AddShape (picture);  		}  		break;  	}  }  else {  	// Base level  	ConvertRecordsToUserModel (shapeContainer' patriarch);  }  
Magic Number,NPOI.HSSF.Record,ExternSheetSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExternSheetSubRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 2 + offset' GetIndexToFirstSupBook ());  
Magic Number,NPOI.HSSF.Record,ExternSheetSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExternSheetSubRecord.cs,Serialize,The following statement contains a magic number: LittleEndian.PutShort (data' 4 + offset' GetIndexToLastSupBook ());  
Magic Number,NPOI.HSSF.Record,ExtSSTRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExtSSTRecord.cs,GetRecordSizeForStrings,The following statement contains a magic number: return 4 + 2 + (GetNumberOfInfoRecsForStrings (numStrings) * 8);  
Magic Number,NPOI.HSSF.Record,ExtSSTRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExtSSTRecord.cs,GetRecordSizeForStrings,The following statement contains a magic number: return 4 + 2 + (GetNumberOfInfoRecsForStrings (numStrings) * 8);  
Magic Number,NPOI.HSSF.Record,ExtSSTRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ExtSSTRecord.cs,GetRecordSizeForStrings,The following statement contains a magic number: return 4 + 2 + (GetNumberOfInfoRecsForStrings (numStrings) * 8);  
Magic Number,NPOI.HSSF.Record,FilePassRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FilePassRecord.cs,FilePassRecord,The following statement contains a magic number: _docId = Read (in1' 16);  
Magic Number,NPOI.HSSF.Record,FilePassRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FilePassRecord.cs,FilePassRecord,The following statement contains a magic number: _saltData = Read (in1' 16);  
Magic Number,NPOI.HSSF.Record,FilePassRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FilePassRecord.cs,FilePassRecord,The following statement contains a magic number: _saltHash = Read (in1' 16);  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: while (charIndex-- > 0) {  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars [charIndex];  }  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  
Magic Number,NPOI.HSSF.Record,FileSharingRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FileSharingRecord.cs,HashPassword,The following statement contains a magic number: hash ^= (0x8000 | ('N' << 8) | 'K');  
Magic Number,NPOI.HSSF.Record,SpecialCachedValue,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FormulaRecord.cs,Create,The following statement contains a magic number: for (int i = 0; i < VARIABLE_DATA_LENGTH; i++) {  	result [i] = (byte)x;  	x >>= 8;  }  
Magic Number,NPOI.HSSF.Record,SpecialCachedValue,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FormulaRecord.cs,Create,The following statement contains a magic number: x >>= 8;  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker = new GUID (in1);  	if (URL_MONIKER.Equals (_moniker)) {  		int length = in1.ReadInt ();  		/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  		if (length == remaining) {  			int nChars = length / 2;  			_address = in1.ReadUnicodeLEString (nChars);  		}  		else {  			int nChars = (length - TAIL_SIZE) / 2;  			_address = in1.ReadUnicodeLEString (nChars);  			/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  		}  	}  	else if (FILE_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  		_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  		int size = in1.ReadInt ();  		if (size > 0) {  			int charDataSize = in1.ReadInt ();  			//From the spec: An optional unsigned integer that MUST be 3 if present  			int optFlags = in1.ReadUShort ();  			if (optFlags != 0x0003) {  				throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  			}  			_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  		}  		else {  			_address = null;  		}  	}  	else if (STD_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		byte[] path_bytes = new byte[len];  		in1.ReadFully (path_bytes);  		_address = Encoding.UTF8.GetString (path_bytes);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker = new GUID (in1);  	if (URL_MONIKER.Equals (_moniker)) {  		int length = in1.ReadInt ();  		/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  		if (length == remaining) {  			int nChars = length / 2;  			_address = in1.ReadUnicodeLEString (nChars);  		}  		else {  			int nChars = (length - TAIL_SIZE) / 2;  			_address = in1.ReadUnicodeLEString (nChars);  			/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  		}  	}  	else if (FILE_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  		_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  		int size = in1.ReadInt ();  		if (size > 0) {  			int charDataSize = in1.ReadInt ();  			//From the spec: An optional unsigned integer that MUST be 3 if present  			int optFlags = in1.ReadUShort ();  			if (optFlags != 0x0003) {  				throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  			}  			_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  		}  		else {  			_address = null;  		}  	}  	else if (STD_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		byte[] path_bytes = new byte[len];  		in1.ReadFully (path_bytes);  		_address = Encoding.UTF8.GetString (path_bytes);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker = new GUID (in1);  	if (URL_MONIKER.Equals (_moniker)) {  		int length = in1.ReadInt ();  		/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  		if (length == remaining) {  			int nChars = length / 2;  			_address = in1.ReadUnicodeLEString (nChars);  		}  		else {  			int nChars = (length - TAIL_SIZE) / 2;  			_address = in1.ReadUnicodeLEString (nChars);  			/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  		}  	}  	else if (FILE_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  		_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  		int size = in1.ReadInt ();  		if (size > 0) {  			int charDataSize = in1.ReadInt ();  			//From the spec: An optional unsigned integer that MUST be 3 if present  			int optFlags = in1.ReadUShort ();  			if (optFlags != 0x0003) {  				throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  			}  			_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  		}  		else {  			_address = null;  		}  	}  	else if (STD_MONIKER.Equals (_moniker)) {  		_fileOpts = in1.ReadShort ();  		int len = in1.ReadInt ();  		byte[] path_bytes = new byte[len];  		in1.ReadFully (path_bytes);  		_address = Encoding.UTF8.GetString (path_bytes);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (URL_MONIKER.Equals (_moniker)) {  	int length = in1.ReadInt ();  	/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  	if (length == remaining) {  		int nChars = length / 2;  		_address = in1.ReadUnicodeLEString (nChars);  	}  	else {  		int nChars = (length - TAIL_SIZE) / 2;  		_address = in1.ReadUnicodeLEString (nChars);  		/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  	}  }  else if (FILE_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  	_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  	int size = in1.ReadInt ();  	if (size > 0) {  		int charDataSize = in1.ReadInt ();  		//From the spec: An optional unsigned integer that MUST be 3 if present  		int optFlags = in1.ReadUShort ();  		if (optFlags != 0x0003) {  			throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  		}  		_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  	}  	else {  		_address = null;  	}  }  else if (STD_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	byte[] path_bytes = new byte[len];  	in1.ReadFully (path_bytes);  	_address = Encoding.UTF8.GetString (path_bytes);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (URL_MONIKER.Equals (_moniker)) {  	int length = in1.ReadInt ();  	/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  	if (length == remaining) {  		int nChars = length / 2;  		_address = in1.ReadUnicodeLEString (nChars);  	}  	else {  		int nChars = (length - TAIL_SIZE) / 2;  		_address = in1.ReadUnicodeLEString (nChars);  		/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  	}  }  else if (FILE_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  	_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  	int size = in1.ReadInt ();  	if (size > 0) {  		int charDataSize = in1.ReadInt ();  		//From the spec: An optional unsigned integer that MUST be 3 if present  		int optFlags = in1.ReadUShort ();  		if (optFlags != 0x0003) {  			throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  		}  		_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  	}  	else {  		_address = null;  	}  }  else if (STD_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	byte[] path_bytes = new byte[len];  	in1.ReadFully (path_bytes);  	_address = Encoding.UTF8.GetString (path_bytes);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (URL_MONIKER.Equals (_moniker)) {  	int length = in1.ReadInt ();  	/*                      * The value of <code>length<code> be either the byte size of the url field                      * (including the terminating NULL character) or the byte size of the url field plus 24.                      * If the value of this field is set to the byte size of the url field'                      * then the tail bytes fields are not present.                      */int remaining = in1.Remaining;  	if (length == remaining) {  		int nChars = length / 2;  		_address = in1.ReadUnicodeLEString (nChars);  	}  	else {  		int nChars = (length - TAIL_SIZE) / 2;  		_address = in1.ReadUnicodeLEString (nChars);  		/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  	}  }  else if (FILE_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  	_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  	int size = in1.ReadInt ();  	if (size > 0) {  		int charDataSize = in1.ReadInt ();  		//From the spec: An optional unsigned integer that MUST be 3 if present  		int optFlags = in1.ReadUShort ();  		if (optFlags != 0x0003) {  			throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  		}  		_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  	}  	else {  		_address = null;  	}  }  else if (STD_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	byte[] path_bytes = new byte[len];  	in1.ReadFully (path_bytes);  	_address = Encoding.UTF8.GetString (path_bytes);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (length == remaining) {  	int nChars = length / 2;  	_address = in1.ReadUnicodeLEString (nChars);  }  else {  	int nChars = (length - TAIL_SIZE) / 2;  	_address = in1.ReadUnicodeLEString (nChars);  	/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (length == remaining) {  	int nChars = length / 2;  	_address = in1.ReadUnicodeLEString (nChars);  }  else {  	int nChars = (length - TAIL_SIZE) / 2;  	_address = in1.ReadUnicodeLEString (nChars);  	/*                          * TODO: make sense of the remaining bytes                          * According to the spec they consist of:                          * 1. 16-byte  GUID: This field MUST equal                          *    {0xF4815879' 0x1D3B' 0x487F' 0xAF' 0x2C' 0x82' 0x5D' 0xC4' 0x85' 0x27' 0x63}                          * 2. Serial version' this field MUST equal 0 if present.                          * 3. URI Flags                          */_uninterpretedTail = ReadTail (URL_uninterpretedTail' in1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (FILE_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	_shortFilename = StringUtil.ReadCompressedUnicode (in1' len);  	_uninterpretedTail = ReadTail (FILE_uninterpretedTail' in1);  	int size = in1.ReadInt ();  	if (size > 0) {  		int charDataSize = in1.ReadInt ();  		//From the spec: An optional unsigned integer that MUST be 3 if present  		int optFlags = in1.ReadUShort ();  		if (optFlags != 0x0003) {  			throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  		}  		_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  	}  	else {  		_address = null;  	}  }  else if (STD_MONIKER.Equals (_moniker)) {  	_fileOpts = in1.ReadShort ();  	int len = in1.ReadInt ();  	byte[] path_bytes = new byte[len];  	in1.ReadFully (path_bytes);  	_address = Encoding.UTF8.GetString (path_bytes);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: if (size > 0) {  	int charDataSize = in1.ReadInt ();  	//From the spec: An optional unsigned integer that MUST be 3 if present  	int optFlags = in1.ReadUShort ();  	if (optFlags != 0x0003) {  		throw new RecordFormatException ("Expected 0x3 but found " + optFlags);  	}  	_address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  }  else {  	_address = null;  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,HyperlinkRecord,The following statement contains a magic number: _address = StringUtil.ReadUnicodeLE (in1' charDataSize / 2);  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker.Serialize (out1);  	if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  		if (_uninterpretedTail == null) {  			out1.WriteInt (_address.Length * 2);  			StringUtil.PutUnicodeLE (_address' out1);  		}  		else {  			out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  			StringUtil.PutUnicodeLE (_address' out1);  			WriteTail (_uninterpretedTail' out1);  		}  	}  	else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  		out1.WriteShort (_fileOpts);  		out1.WriteInt (_shortFilename.Length);  		StringUtil.PutCompressedUnicode (_shortFilename' out1);  		WriteTail (_uninterpretedTail' out1);  		if (string.IsNullOrEmpty (_address)) {  			out1.WriteInt (0);  		}  		else {  			int addrLen = _address.Length * 2;  			out1.WriteInt (addrLen + 6);  			out1.WriteInt (addrLen);  			out1.WriteShort (0x0003);  			// TODO const  			StringUtil.PutUnicodeLE (_address' out1);  		}  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker.Serialize (out1);  	if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  		if (_uninterpretedTail == null) {  			out1.WriteInt (_address.Length * 2);  			StringUtil.PutUnicodeLE (_address' out1);  		}  		else {  			out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  			StringUtil.PutUnicodeLE (_address' out1);  			WriteTail (_uninterpretedTail' out1);  		}  	}  	else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  		out1.WriteShort (_fileOpts);  		out1.WriteInt (_shortFilename.Length);  		StringUtil.PutCompressedUnicode (_shortFilename' out1);  		WriteTail (_uninterpretedTail' out1);  		if (string.IsNullOrEmpty (_address)) {  			out1.WriteInt (0);  		}  		else {  			int addrLen = _address.Length * 2;  			out1.WriteInt (addrLen + 6);  			out1.WriteInt (addrLen);  			out1.WriteShort (0x0003);  			// TODO const  			StringUtil.PutUnicodeLE (_address' out1);  		}  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker.Serialize (out1);  	if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  		if (_uninterpretedTail == null) {  			out1.WriteInt (_address.Length * 2);  			StringUtil.PutUnicodeLE (_address' out1);  		}  		else {  			out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  			StringUtil.PutUnicodeLE (_address' out1);  			WriteTail (_uninterpretedTail' out1);  		}  	}  	else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  		out1.WriteShort (_fileOpts);  		out1.WriteInt (_shortFilename.Length);  		StringUtil.PutCompressedUnicode (_shortFilename' out1);  		WriteTail (_uninterpretedTail' out1);  		if (string.IsNullOrEmpty (_address)) {  			out1.WriteInt (0);  		}  		else {  			int addrLen = _address.Length * 2;  			out1.WriteInt (addrLen + 6);  			out1.WriteInt (addrLen);  			out1.WriteShort (0x0003);  			// TODO const  			StringUtil.PutUnicodeLE (_address' out1);  		}  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if ((_linkOpts & HLINK_URL) != 0 && (_linkOpts & HLINK_UNC_PATH) == 0) {  	_moniker.Serialize (out1);  	if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  		if (_uninterpretedTail == null) {  			out1.WriteInt (_address.Length * 2);  			StringUtil.PutUnicodeLE (_address' out1);  		}  		else {  			out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  			StringUtil.PutUnicodeLE (_address' out1);  			WriteTail (_uninterpretedTail' out1);  		}  	}  	else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  		out1.WriteShort (_fileOpts);  		out1.WriteInt (_shortFilename.Length);  		StringUtil.PutCompressedUnicode (_shortFilename' out1);  		WriteTail (_uninterpretedTail' out1);  		if (string.IsNullOrEmpty (_address)) {  			out1.WriteInt (0);  		}  		else {  			int addrLen = _address.Length * 2;  			out1.WriteInt (addrLen + 6);  			out1.WriteInt (addrLen);  			out1.WriteShort (0x0003);  			// TODO const  			StringUtil.PutUnicodeLE (_address' out1);  		}  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  	if (_uninterpretedTail == null) {  		out1.WriteInt (_address.Length * 2);  		StringUtil.PutUnicodeLE (_address' out1);  	}  	else {  		out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  		StringUtil.PutUnicodeLE (_address' out1);  		WriteTail (_uninterpretedTail' out1);  	}  }  else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  	if (_uninterpretedTail == null) {  		out1.WriteInt (_address.Length * 2);  		StringUtil.PutUnicodeLE (_address' out1);  	}  	else {  		out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  		StringUtil.PutUnicodeLE (_address' out1);  		WriteTail (_uninterpretedTail' out1);  	}  }  else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  	if (_uninterpretedTail == null) {  		out1.WriteInt (_address.Length * 2);  		StringUtil.PutUnicodeLE (_address' out1);  	}  	else {  		out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  		StringUtil.PutUnicodeLE (_address' out1);  		WriteTail (_uninterpretedTail' out1);  	}  }  else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && URL_MONIKER.Equals (_moniker)) {  	if (_uninterpretedTail == null) {  		out1.WriteInt (_address.Length * 2);  		StringUtil.PutUnicodeLE (_address' out1);  	}  	else {  		out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  		StringUtil.PutUnicodeLE (_address' out1);  		WriteTail (_uninterpretedTail' out1);  	}  }  else if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_uninterpretedTail == null) {  	out1.WriteInt (_address.Length * 2);  	StringUtil.PutUnicodeLE (_address' out1);  }  else {  	out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  	StringUtil.PutUnicodeLE (_address' out1);  	WriteTail (_uninterpretedTail' out1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_uninterpretedTail == null) {  	out1.WriteInt (_address.Length * 2);  	StringUtil.PutUnicodeLE (_address' out1);  }  else {  	out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  	StringUtil.PutUnicodeLE (_address' out1);  	WriteTail (_uninterpretedTail' out1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: out1.WriteInt (_address.Length * 2);  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: out1.WriteInt (_address.Length * 2 + TAIL_SIZE);  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (_moniker != null && FILE_MONIKER.Equals (_moniker)) {  	out1.WriteShort (_fileOpts);  	out1.WriteInt (_shortFilename.Length);  	StringUtil.PutCompressedUnicode (_shortFilename' out1);  	WriteTail (_uninterpretedTail' out1);  	if (string.IsNullOrEmpty (_address)) {  		out1.WriteInt (0);  	}  	else {  		int addrLen = _address.Length * 2;  		out1.WriteInt (addrLen + 6);  		out1.WriteInt (addrLen);  		out1.WriteShort (0x0003);  		// TODO const  		StringUtil.PutUnicodeLE (_address' out1);  	}  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (string.IsNullOrEmpty (_address)) {  	out1.WriteInt (0);  }  else {  	int addrLen = _address.Length * 2;  	out1.WriteInt (addrLen + 6);  	out1.WriteInt (addrLen);  	out1.WriteShort (0x0003);  	// TODO const  	StringUtil.PutUnicodeLE (_address' out1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: if (string.IsNullOrEmpty (_address)) {  	out1.WriteInt (0);  }  else {  	int addrLen = _address.Length * 2;  	out1.WriteInt (addrLen + 6);  	out1.WriteInt (addrLen);  	out1.WriteShort (0x0003);  	// TODO const  	StringUtil.PutUnicodeLE (_address' out1);  }  
Magic Number,NPOI.HSSF.Record,HyperlinkRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\HyperlinkRecord.cs,Serialize,The following statement contains a magic number: out1.WriteInt (addrLen + 6);  
Magic Number,NPOI.HSSF.Record,IndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\IndexRecord.cs,GetRecordSizeForBlockCount,The following statement contains a magic number: return 20 + (4 * blockCount);  
Magic Number,NPOI.HSSF.Record,IndexRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\IndexRecord.cs,GetRecordSizeForBlockCount,The following statement contains a magic number: return 20 + (4 * blockCount);  
Magic Number,NPOI.HSSF.Record,InterfaceEndRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\InterfaceEndRecord.cs,Create,The following statement contains a magic number: switch (in1.Remaining) {  case 0:  	return Instance;  case 2:  	return new InterfaceHdrRecord (in1);  }  
Magic Number,NPOI.HSSF.Record,LinkedDataFormulaField,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\LinkedDataFormulaField.cs,FillField,The following statement contains a magic number: return tokenSize + 2;  
Magic Number,NPOI.HSSF.Record,LinkedDataFormulaField,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\LinkedDataFormulaField.cs,SerializeField,The following statement contains a magic number: LittleEndian.PutShort (data' offset' (short)(size - 2));  
Magic Number,NPOI.HSSF.Record,ObjRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\ObjRecord.cs,ObjRecord,The following statement contains a magic number: subrecords = new List<SubRecord> (2);  
Magic Number,NPOI.HSSF.Record,PageBreakRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PageBreakRecord.cs,PageBreakRecord,The following statement contains a magic number: _breaks = new List<Break> (nBreaks + 2);  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PaletteRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PaletteRecord.cs,CreateDefaultPalette,The following statement contains a magic number: return new PColor[] {  	pc (0' 0' 0)'  	pc (255' 255' 255)'  	pc (255' 0' 0)'  	pc (0' 255' 0)'  	pc (0' 0' 255)'  	pc (255' 255' 0)'  	pc (255' 0' 255)'  	pc (0' 255' 255)'  	pc (128' 0' 0)'  	pc (0' 128' 0)'  	pc (0' 0' 128)'  	pc (128' 128' 0)'  	pc (128' 0' 128)'  	pc (0' 128' 128)'  	pc (192' 192' 192)'  	pc (128' 128' 128)'  	pc (153' 153' 255)'  	pc (153' 51' 102)'  	pc (255' 255' 204)'  	pc (204' 255' 255)'  	pc (102' 0' 102)'  	pc (255' 128' 128)'  	pc (0' 102' 204)'  	pc (204' 204' 255)'  	pc (0' 0' 128)'  	pc (255' 0' 255)'  	pc (255' 255' 0)'  	pc (0' 255' 255)'  	pc (128' 0' 128)'  	pc (128' 0' 0)'  	pc (0' 128' 128)'  	pc (0' 0' 255)'  	pc (0' 204' 255)'  	pc (204' 255' 255)'  	pc (204' 255' 204)'  	pc (255' 255' 153)'  	pc (153' 204' 255)'  	pc (255' 153' 204)'  	pc (204' 153' 255)'  	pc (255' 204' 153)'  	pc (51' 102' 255)'  	pc (51' 204' 204)'  	pc (153' 204' 0)'  	pc (255' 204' 0)'  	pc (255' 153' 0)'  	pc (255' 102' 0)'  	pc (102' 102' 153)'  	pc (150' 150' 150)'  	pc (0' 51' 102)'  	pc (51' 153' 102)'  	pc (0' 51' 0)'  	pc (51' 51' 0)'  	pc (153' 51' 0)'  	pc (153' 51' 102)'  	pc (51' 51' 153)'  	pc (51' 51' 51)'  };  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: if (passwordChars.Length > 0) {  	int charIndex = passwordChars.Length;  	while (charIndex-- > 0) {  		hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  		hash ^= passwordChars [charIndex];  	}  	// also hash with charcount  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars.Length;  	hash ^= (0x8000 | ('N' << 8) | 'K');  }  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: while (charIndex-- > 0) {  	hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  	hash ^= passwordChars [charIndex];  }  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: hash = ((hash >> 14) & 0x01) | ((hash << 1) & 0x7fff);  
Magic Number,NPOI.HSSF.Record,PasswordRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PasswordRecord.cs,HashPassword,The following statement contains a magic number: hash ^= (0x8000 | ('N' << 8) | 'K');  
Magic Number,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,ReadUByte,The following statement contains a magic number: if (s < 0) {  	s += 256;  }  
Magic Number,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,ReadUByte,The following statement contains a magic number: s += 256;  
Magic Number,NPOI.HSSF.Record,RecordInputStream,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\RecordInputStream.cs,ReadAllContinuedRemainder,The following statement contains a magic number: using (MemoryStream out1 = new MemoryStream (2 * MAX_RECORD_DATA_SIZE)) {  	while (true) {  		byte[] b = ReadRemainder ();  		out1.Write (b' 0' b.Length);  		if (!IsContinueNext) {  			break;  		}  		NextRecord ();  	}  	return out1.ToArray ();  }  
Magic Number,NPOI.HSSF.Record,SelectionRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SelectionRecord.cs,SelectionRecord,The following statement contains a magic number: field_1_pane = 3;  
Magic Number,NPOI.HSSF.Record,SSTRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SSTRecord.cs,CreateExtSSTRecord,The following statement contains a magic number: extSST.NumStringsPerBucket = ((short)8);  
Magic Number,NPOI.HSSF.Record,CommonObjectDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\CommonObjectDataSubRecord.cs,CommonObjectDataSubRecord,The following statement contains a magic number: if (size != 18) {  	throw new RecordFormatException ("Expected size 18 but got (" + size + ")");  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (remaining >= dataLenAfterFormula + 3) {  	int tag = in1.ReadByte ();  	stringByteCount = LittleEndianConsts.BYTE_SIZE;  	if (tag != 0x03) {  		throw new RecordFormatException ("Expected byte 0x03 here");  	}  	int nChars = in1.ReadUShort ();  	stringByteCount += LittleEndianConsts.SHORT_SIZE;  	if (nChars > 0) {  		// OOO: the 4th way Xcl stores a unicode string: not even a Grbit byte present if Length 0  		field_3_unicode_flag = (in1.ReadByte () & 0x01) != 0;  		stringByteCount += LittleEndianConsts.BYTE_SIZE;  		if (field_3_unicode_flag) {  			field_4_ole_classname = StringUtil.ReadUnicodeLE (in1' nChars);  			stringByteCount += nChars * 2;  		}  		else {  			field_4_ole_classname = StringUtil.ReadCompressedUnicode (in1' nChars);  			stringByteCount += nChars;  		}  	}  	else {  		field_4_ole_classname = "";  	}  }  else {  	field_4_ole_classname = null;  	stringByteCount = 0;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (remaining >= dataLenAfterFormula + 3) {  	int tag = in1.ReadByte ();  	stringByteCount = LittleEndianConsts.BYTE_SIZE;  	if (tag != 0x03) {  		throw new RecordFormatException ("Expected byte 0x03 here");  	}  	int nChars = in1.ReadUShort ();  	stringByteCount += LittleEndianConsts.SHORT_SIZE;  	if (nChars > 0) {  		// OOO: the 4th way Xcl stores a unicode string: not even a Grbit byte present if Length 0  		field_3_unicode_flag = (in1.ReadByte () & 0x01) != 0;  		stringByteCount += LittleEndianConsts.BYTE_SIZE;  		if (field_3_unicode_flag) {  			field_4_ole_classname = StringUtil.ReadUnicodeLE (in1' nChars);  			stringByteCount += nChars * 2;  		}  		else {  			field_4_ole_classname = StringUtil.ReadCompressedUnicode (in1' nChars);  			stringByteCount += nChars;  		}  	}  	else {  		field_4_ole_classname = "";  	}  }  else {  	field_4_ole_classname = null;  	stringByteCount = 0;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (nChars > 0) {  	// OOO: the 4th way Xcl stores a unicode string: not even a Grbit byte present if Length 0  	field_3_unicode_flag = (in1.ReadByte () & 0x01) != 0;  	stringByteCount += LittleEndianConsts.BYTE_SIZE;  	if (field_3_unicode_flag) {  		field_4_ole_classname = StringUtil.ReadUnicodeLE (in1' nChars);  		stringByteCount += nChars * 2;  	}  	else {  		field_4_ole_classname = StringUtil.ReadCompressedUnicode (in1' nChars);  		stringByteCount += nChars;  	}  }  else {  	field_4_ole_classname = "";  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (field_3_unicode_flag) {  	field_4_ole_classname = StringUtil.ReadUnicodeLE (in1' nChars);  	stringByteCount += nChars * 2;  }  else {  	field_4_ole_classname = StringUtil.ReadCompressedUnicode (in1' nChars);  	stringByteCount += nChars;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: stringByteCount += nChars * 2;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (((stringByteCount + formulaSize) % 2) != 0) {  	int b = in1.ReadByte ();  	remaining -= LittleEndianConsts.BYTE_SIZE;  	if (field_2_refPtg != null && field_4_ole_classname == null) {  		field_4_unknownByte = (byte)b;  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,EmbeddedObjectRefSubRecord,The following statement contains a magic number: if (dataLenAfterFormula >= 4) {  	field_5_stream_id = in1.ReadInt ();  	remaining -= LittleEndianConsts.INT_SIZE;  }  else {  	field_5_stream_id = null;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: if (field_4_ole_classname == null) {  	// don't write 0x03' stringLen' flag' text  	stringLen = 0;  }  else {  	result += 1 + 2;  	// 0x03' stringLen' flag  	stringLen = field_4_ole_classname.Length;  	if (stringLen > 0) {  		result += 1;  		// flag  		if (field_3_unicode_flag) {  			result += stringLen * 2;  		}  		else {  			result += stringLen;  		}  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: if (field_4_ole_classname == null) {  	// don't write 0x03' stringLen' flag' text  	stringLen = 0;  }  else {  	result += 1 + 2;  	// 0x03' stringLen' flag  	stringLen = field_4_ole_classname.Length;  	if (stringLen > 0) {  		result += 1;  		// flag  		if (field_3_unicode_flag) {  			result += stringLen * 2;  		}  		else {  			result += stringLen;  		}  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: result += 1 + 2;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: if (stringLen > 0) {  	result += 1;  	// flag  	if (field_3_unicode_flag) {  		result += stringLen * 2;  	}  	else {  		result += stringLen;  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: if (field_3_unicode_flag) {  	result += stringLen * 2;  }  else {  	result += stringLen;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: result += stringLen * 2;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetStreamIDOffset,The following statement contains a magic number: if ((result % 2) != 0) {  	result++;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetDataSize,The following statement contains a magic number: if (field_5_stream_id != null) {  	result += 4;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,GetDataSize,The following statement contains a magic number: result += 4;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: if (field_4_ole_classname == null) {  	// don't write 0x03' stringLen' flag' text  	stringLen = 0;  }  else {  	out1.WriteByte (0x03);  	pos += 1;  	stringLen = field_4_ole_classname.Length;  	out1.WriteShort (stringLen);  	pos += 2;  	if (stringLen > 0) {  		out1.WriteByte (field_3_unicode_flag ? 0x01 : 0x00);  		pos += 1;  		if (field_3_unicode_flag) {  			StringUtil.PutUnicodeLE (field_4_ole_classname' out1);  			pos += stringLen * 2;  		}  		else {  			StringUtil.PutCompressedUnicode (field_4_ole_classname' out1);  			pos += stringLen;  		}  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: if (field_4_ole_classname == null) {  	// don't write 0x03' stringLen' flag' text  	stringLen = 0;  }  else {  	out1.WriteByte (0x03);  	pos += 1;  	stringLen = field_4_ole_classname.Length;  	out1.WriteShort (stringLen);  	pos += 2;  	if (stringLen > 0) {  		out1.WriteByte (field_3_unicode_flag ? 0x01 : 0x00);  		pos += 1;  		if (field_3_unicode_flag) {  			StringUtil.PutUnicodeLE (field_4_ole_classname' out1);  			pos += stringLen * 2;  		}  		else {  			StringUtil.PutCompressedUnicode (field_4_ole_classname' out1);  			pos += stringLen;  		}  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: if (stringLen > 0) {  	out1.WriteByte (field_3_unicode_flag ? 0x01 : 0x00);  	pos += 1;  	if (field_3_unicode_flag) {  		StringUtil.PutUnicodeLE (field_4_ole_classname' out1);  		pos += stringLen * 2;  	}  	else {  		StringUtil.PutCompressedUnicode (field_4_ole_classname' out1);  		pos += stringLen;  	}  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: if (field_3_unicode_flag) {  	StringUtil.PutUnicodeLE (field_4_ole_classname' out1);  	pos += stringLen * 2;  }  else {  	StringUtil.PutCompressedUnicode (field_4_ole_classname' out1);  	pos += stringLen;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: pos += stringLen * 2;  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: switch (idOffset - (pos - 6)) {  // 6 for 3 shorts: sid' dataSize' idOffset  case 1:  	out1.WriteByte (field_4_unknownByte == null ? 0x00 : (int)Convert.ToByte (field_4_unknownByte' CultureInfo.InvariantCulture));  	pos++;  	break;  case 0:  	break;  default:  	throw new InvalidOperationException ("Bad padding calculation (" + idOffset + "' " + pos + ")");  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: if (field_5_stream_id != null) {  	out1.WriteInt (Convert.ToInt32 (field_5_stream_id' CultureInfo.InvariantCulture));  	pos += 4;  }  
Magic Number,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,Serialize,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,LbsDataSubRecord,The following statement contains a magic number: if (encodedTokenLen > 0) {  	int formulaSize = in1.ReadUShort ();  	_unknownPreFormulaInt = in1.ReadInt ();  	Ptg[] ptgs = Ptg.ReadTokens (formulaSize' in1);  	if (ptgs.Length != 1) {  		throw new RecordFormatException ("Read " + ptgs.Length + " tokens but expected exactly 1");  	}  	_linkPtg = ptgs [0];  	switch (encodedTokenLen - formulaSize - 6) {  	case 1:  		_unknownPostFormulaByte = (byte)in1.ReadByte ();  		break;  	case 0:  		_unknownPostFormulaByte = null;  		break;  	default:  		throw new RecordFormatException ("Unexpected leftover bytes");  	}  }  
Magic Number,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,LbsDataSubRecord,The following statement contains a magic number: switch (encodedTokenLen - formulaSize - 6) {  case 1:  	_unknownPostFormulaByte = (byte)in1.ReadByte ();  	break;  case 0:  	_unknownPostFormulaByte = null;  	break;  default:  	throw new RecordFormatException ("Unexpected leftover bytes");  }  
Magic Number,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,LbsDataSubRecord,The following statement contains a magic number: if (((_flags >> 4) & 0x2) != 0) {  	_bsels = new bool[_cLines];  	for (int i = 0; i < _cLines; i++) {  		_bsels [i] = in1.ReadByte () == 1;  	}  }  
Magic Number,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,Serialize,The following statement contains a magic number: if (_linkPtg == null) {  	out1.WriteShort (0);  }  else {  	int formulaSize = _linkPtg.Size;  	int linkSize = formulaSize + 6;  	if (_unknownPostFormulaByte != null) {  		linkSize++;  	}  	out1.WriteShort (linkSize);  	out1.WriteShort (formulaSize);  	out1.WriteInt (_unknownPreFormulaInt);  	_linkPtg.Write (out1);  	if (_unknownPostFormulaByte != null) {  		out1.WriteByte (Convert.ToByte (_unknownPostFormulaByte' CultureInfo.InvariantCulture));  	}  }  
Magic Number,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,CreateAutoFilterInstance,The following statement contains a magic number: lbs._dropData._cLine = 8;  
Magic Number,NPOI.HSSF.Record,LbsDropData,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,LbsDropData,The following statement contains a magic number: if (StringUtil.GetEncodedSize (_str) % 2 != 0) {  	_unused = (byte)in1.ReadByte ();  }  
Magic Number,NPOI.HSSF.Record,TabIdRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TabIdRecord.cs,TabIdRecord,The following statement contains a magic number: _tabids = new short[in1.Remaining / 2];  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,TextObjectRecord,The following statement contains a magic number: if (in1.Remaining > 0) {  	// Text Objects can have simple reference formulas  	// (This bit not mentioned in the MS document)  	if (in1.Remaining < 11) {  		throw new RecordFormatException ("Not enough remaining data for a link formula");  	}  	int formulaSize = in1.ReadUShort ();  	_unknownPreFormulaInt = in1.ReadInt ();  	Ptg[] ptgs = Ptg.ReadTokens (formulaSize' in1);  	if (ptgs.Length != 1) {  		throw new RecordFormatException ("Read " + ptgs.Length + " tokens but expected exactly 1");  	}  	_linkRefPtg = (OperandPtg)ptgs [0];  	if (in1.Remaining > 0) {  		_unknownPostFormulaByte = (byte)in1.ReadByte ();  	}  	else {  		_unknownPostFormulaByte = null;  	}  }  else {  	_linkRefPtg = null;  }  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,TextObjectRecord,The following statement contains a magic number: if (in1.Remaining < 11) {  	throw new RecordFormatException ("Not enough remaining data for a link formula");  }  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: for (int i = 0; i < nRuns; i++) {  	LittleEndian.PutUShort (result' pos' str.GetIndexOfFormattingRun (i));  	pos += 2;  	int fontIndex = ((HSSFRichTextString)str).GetFontOfFormattingRun (i);  	LittleEndian.PutUShort (result' pos' fontIndex == HSSFRichTextString.NO_FONT ? 0 : fontIndex);  	pos += 2;  	pos += 4;  	// skip reserved  }  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: for (int i = 0; i < nRuns; i++) {  	LittleEndian.PutUShort (result' pos' str.GetIndexOfFormattingRun (i));  	pos += 2;  	int fontIndex = ((HSSFRichTextString)str).GetFontOfFormattingRun (i);  	LittleEndian.PutUShort (result' pos' fontIndex == HSSFRichTextString.NO_FONT ? 0 : fontIndex);  	pos += 2;  	pos += 4;  	// skip reserved  }  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: for (int i = 0; i < nRuns; i++) {  	LittleEndian.PutUShort (result' pos' str.GetIndexOfFormattingRun (i));  	pos += 2;  	int fontIndex = ((HSSFRichTextString)str).GetFontOfFormattingRun (i);  	LittleEndian.PutUShort (result' pos' fontIndex == HSSFRichTextString.NO_FONT ? 0 : fontIndex);  	pos += 2;  	pos += 4;  	// skip reserved  }  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Record,TextObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\TextObjectRecord.cs,CreateFormatData,The following statement contains a magic number: pos += 4;  
Magic Number,NPOI.HSSF.Record,WindowTwoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WindowTwoRecord.cs,WindowTwoRecord,The following statement contains a magic number: if (size > 10) {  	field_5_page_break_zoom = in1.ReadShort ();  	field_6_normal_zoom = in1.ReadShort ();  }  
Magic Number,NPOI.HSSF.Record,WindowTwoRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WindowTwoRecord.cs,WindowTwoRecord,The following statement contains a magic number: if (size > 14) {  	// there Is a special case of this record that has only 14 bytes...undocumented!  	field_7_reserved = in1.ReadInt ();  }  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: if (nChars > DATA_SIZE || (is16BitFlag & 0xFE) != 0) {  	// String header looks wrong (probably missing)  	// OOO doc says this is optional anyway.  	// reconstruct data  	byte[] data = new byte[3 + in1.Remaining];  	LittleEndian.PutUShort (data' 0' nChars);  	LittleEndian.PutByte (data' 2' is16BitFlag);  	in1.ReadFully (data' 3' data.Length - 3);  	char[] data1 = new char[data.Length];  	for (int i = 0; i < data.Length; i++) {  		data1 [i] = (char)data [i];  	}  	String rawValue = new String (data1);  	Username = rawValue.Trim ();  	return;  }  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: if (nChars > DATA_SIZE || (is16BitFlag & 0xFE) != 0) {  	// String header looks wrong (probably missing)  	// OOO doc says this is optional anyway.  	// reconstruct data  	byte[] data = new byte[3 + in1.Remaining];  	LittleEndian.PutUShort (data' 0' nChars);  	LittleEndian.PutByte (data' 2' is16BitFlag);  	in1.ReadFully (data' 3' data.Length - 3);  	char[] data1 = new char[data.Length];  	for (int i = 0; i < data.Length; i++) {  		data1 [i] = (char)data [i];  	}  	String rawValue = new String (data1);  	Username = rawValue.Trim ();  	return;  }  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: if (nChars > DATA_SIZE || (is16BitFlag & 0xFE) != 0) {  	// String header looks wrong (probably missing)  	// OOO doc says this is optional anyway.  	// reconstruct data  	byte[] data = new byte[3 + in1.Remaining];  	LittleEndian.PutUShort (data' 0' nChars);  	LittleEndian.PutByte (data' 2' is16BitFlag);  	in1.ReadFully (data' 3' data.Length - 3);  	char[] data1 = new char[data.Length];  	for (int i = 0; i < data.Length; i++) {  		data1 [i] = (char)data [i];  	}  	String rawValue = new String (data1);  	Username = rawValue.Trim ();  	return;  }  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: if (nChars > DATA_SIZE || (is16BitFlag & 0xFE) != 0) {  	// String header looks wrong (probably missing)  	// OOO doc says this is optional anyway.  	// reconstruct data  	byte[] data = new byte[3 + in1.Remaining];  	LittleEndian.PutUShort (data' 0' nChars);  	LittleEndian.PutByte (data' 2' is16BitFlag);  	in1.ReadFully (data' 3' data.Length - 3);  	char[] data1 = new char[data.Length];  	for (int i = 0; i < data.Length; i++) {  		data1 [i] = (char)data [i];  	}  	String rawValue = new String (data1);  	Username = rawValue.Trim ();  	return;  }  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: LittleEndian.PutByte (data' 2' is16BitFlag);  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: in1.ReadFully (data' 3' data.Length - 3);  
Magic Number,NPOI.HSSF.Record,WriteAccessRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\WriteAccessRecord.cs,WriteAccessRecord,The following statement contains a magic number: in1.ReadFully (data' 3' data.Length - 3);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadUShort,The following statement contains a magic number: return (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordInput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordInput.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,CreateForCountingOnly,The following statement contains a magic number: return new ContinuableRecordOutput (NOPOutput' -777);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteString,The following statement contains a magic number: if (numberOfRichTextRuns > 0) {  	optionFlags |= 0x08;  	keepTogetherSize += 2;  }  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteString,The following statement contains a magic number: keepTogetherSize += 2;  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteString,The following statement contains a magic number: if (extendedDataSize > 0) {  	optionFlags |= 0x04;  	keepTogetherSize += 4;  }  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteString,The following statement contains a magic number: keepTogetherSize += 4;  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteCharacterData,The following statement contains a magic number: if (is16bitEncoded) {  	while (true) {  		int nWritableChars = Math.Min (nChars - i' _ulrOutput.AvailableSpace / 2);  		for (; nWritableChars > 0; nWritableChars--) {  			_ulrOutput.WriteShort (text [i++]);  		}  		if (i >= nChars) {  			break;  		}  		WriteContinue ();  		WriteByte (0x01);  	}  }  else {  	while (true) {  		int nWritableChars = Math.Min (nChars - i' _ulrOutput.AvailableSpace / 1);  		for (; nWritableChars > 0; nWritableChars--) {  			_ulrOutput.WriteByte (text [i++]);  		}  		if (i >= nChars) {  			break;  		}  		WriteContinue ();  		WriteByte (0x00);  	}  }  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteCharacterData,The following statement contains a magic number: while (true) {  	int nWritableChars = Math.Min (nChars - i' _ulrOutput.AvailableSpace / 2);  	for (; nWritableChars > 0; nWritableChars--) {  		_ulrOutput.WriteShort (text [i++]);  	}  	if (i >= nChars) {  		break;  	}  	WriteContinue ();  	WriteByte (0x01);  }  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteDouble,The following statement contains a magic number: WriteContinueIfRequired (8);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteInt,The following statement contains a magic number: WriteContinueIfRequired (4);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteLong,The following statement contains a magic number: WriteContinueIfRequired (8);  
Magic Number,NPOI.HSSF.Record.Cont,ContinuableRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\ContinuableRecordOutput.cs,WriteShort,The following statement contains a magic number: WriteContinueIfRequired (2);  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,UnknownLengthRecordOutput,The following statement contains a magic number: if (out1 is IDelayableLittleEndianOutput) {  	// optimisation  	IDelayableLittleEndianOutput dleo = (IDelayableLittleEndianOutput)out1;  	_dataSizeOutput = dleo.CreateDelayedOutput (2);  	_byteBuffer = null;  	_out = out1;  }  else {  	// otherwise temporarily Write all subsequent data to a buffer  	_dataSizeOutput = out1;  	_byteBuffer = new byte[RecordInputStream.MAX_RECORD_DATA_SIZE];  	_out = new LittleEndianByteArrayOutputStream (_byteBuffer' 0);  }  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,UnknownLengthRecordOutput,The following statement contains a magic number: _dataSizeOutput = dleo.CreateDelayedOutput (2);  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,WriteDouble,The following statement contains a magic number: _size += 8;  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,WriteInt,The following statement contains a magic number: _size += 4;  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,WriteLong,The following statement contains a magic number: _size += 8;  
Magic Number,NPOI.HSSF.Record.Cont,UnknownLengthRecordOutput,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Cont\UnknownLengthRecordOutput.cs,WriteShort,The following statement contains a magic number: _size += 2;  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateChartRecord (0' 0' 30434904' 19031616));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateChartRecord (0' 0' 30434904' 19031616));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreatePlotGrowthRecord (65536' 65536));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreatePlotGrowthRecord (65536' 65536));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateFontIndexRecord (5));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateDefaultTextRecord ((short)3));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateFontIndexRecord ((short)6));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateSeriesIndexRecord (2));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarChart,The following statement contains a magic number: records.Add (CreateSeriesIndexRecord (3));  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateDimensionsRecord,The following statement contains a magic number: r.LastRow = (31);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreatePrintSetupRecord,The following statement contains a magic number: r.Scale = ((short)18);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreatePrintSetupRecord,The following statement contains a magic number: r.HeaderMargin = (0.5);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreatePrintSetupRecord,The following statement contains a magic number: r.FooterMargin = (0.5);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreatePrintSetupRecord,The following statement contains a magic number: r.Copies = ((short)15);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateFontBasisRecord1,The following statement contains a magic number: r.XBasis = ((short)9120);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateFontBasisRecord1,The following statement contains a magic number: r.YBasis = ((short)5640);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateFontBasisRecord1,The following statement contains a magic number: r.HeightBasis = ((short)200);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateFontBasisRecord1,The following statement contains a magic number: r.IndexToFontTable = ((short)5);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateFontBasisRecord2,The following statement contains a magic number: r.IndexToFontTable = ((short)6);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBOFRecord,The following statement contains a magic number: r.Version = ((short)600);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBOFRecord,The following statement contains a magic number: r.Type = ((short)20);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBOFRecord,The following statement contains a magic number: r.BuildYear = ((short)1997);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBOFRecord,The following statement contains a magic number: r.RequiredVersion = (106);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTextRecord,The following statement contains a magic number: r.X = (-37);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTextRecord,The following statement contains a magic number: r.Y = (-60);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTextRecord,The following statement contains a magic number: r.IndexOfColorValue = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLegendRecord,The following statement contains a magic number: r.XAxisUpperLeft = (3542);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLegendRecord,The following statement contains a magic number: r.YAxisUpperLeft = (1566);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLegendRecord,The following statement contains a magic number: r.XSize = (437);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLegendRecord,The following statement contains a magic number: r.YSize = (213);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateBarRecord,The following statement contains a magic number: r.CategorySpace = ((short)150);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTickRecord1,The following statement contains a magic number: r.MajorTickType = ((byte)2);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTickRecord1,The following statement contains a magic number: r.LabelPosition = ((byte)3);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTickRecord1,The following statement contains a magic number: r.Zero3 = ((short)45);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateTickRecord1,The following statement contains a magic number: r.TickColor = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisOptionsRecord,The following statement contains a magic number: r.MinimumCategory = ((short)-28644);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisOptionsRecord,The following statement contains a magic number: r.MaximumCategory = ((short)-28715);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisOptionsRecord,The following statement contains a magic number: r.MajorUnitValue = ((short)2);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisOptionsRecord,The following statement contains a magic number: r.CrossingPoint = ((short)-28644);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisParentRecord,The following statement contains a magic number: r.X = (479);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisParentRecord,The following statement contains a magic number: r.Y = (221);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisParentRecord,The following statement contains a magic number: r.Width = (2995);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAxisParentRecord,The following statement contains a magic number: r.Height = (2902);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAllTextRecord,The following statement contains a magic number: r.X = (-37);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAllTextRecord,The following statement contains a magic number: r.Y = (-60);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAllTextRecord,The following statement contains a magic number: r.IndexOfColorValue = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateUnknownTextRecord,The following statement contains a magic number: r.X = (-37);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateUnknownTextRecord,The following statement contains a magic number: r.Y = (-60);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateUnknownTextRecord,The following statement contains a magic number: r.IndexOfColorValue = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateUnknownTextRecord,The following statement contains a magic number: r.DataLabelPlacement = ((short)11088);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateSeriesRecord,The following statement contains a magic number: r.NumCategories = ((short)32);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateSeriesRecord,The following statement contains a magic number: r.NumValues = ((short)31);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAreaFormatRecord1,The following statement contains a magic number: r.ForegroundColor = (16777215);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAreaFormatRecord1,The following statement contains a magic number: r.ForecolorIndex = ((short)78);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAreaFormatRecord1,The following statement contains a magic number: r.BackcolorIndex = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAreaFormatRecord2,The following statement contains a magic number: r.ForecolorIndex = ((short)22);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateAreaFormatRecord2,The following statement contains a magic number: r.BackcolorIndex = ((short)79);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLineFormatRecord,The following statement contains a magic number: r.ColourPaletteIndex = ((short)77);  
Magic Number,NPOI.HSSF.UserModel,HSSFChart,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFChart.cs,CreateLineFormatRecord2,The following statement contains a magic number: r.ColourPaletteIndex = ((short)23);  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,EscherGraphics,The following statement contains a magic number: this.font = new Font ("Arial"' 10);  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) {  	FontDetails d = StaticFontMetrics.GetFontDetails (excelFont);  	int width = (int)((d.GetStringWidth (str) * 8) + 12);  	int height = (int)((font.Size / verticalPixelsPerPoint) + 6) * 2;  	y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  	// we want to Draw the shape from the top-left  	HSSFTextbox textbox = escherGroup.CreateTextbox (new HSSFChildAnchor (x' y' x + width' y + height));  	textbox.IsNoFill = (true);  	textbox.LineStyle = LineStyle.None;  	HSSFRichTextString s = new HSSFRichTextString (str);  	HSSFFont hssfFont = MatchFont (excelFont);  	s.ApplyFont (hssfFont);  	textbox.String = (s);  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) {  	FontDetails d = StaticFontMetrics.GetFontDetails (excelFont);  	int width = (int)((d.GetStringWidth (str) * 8) + 12);  	int height = (int)((font.Size / verticalPixelsPerPoint) + 6) * 2;  	y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  	// we want to Draw the shape from the top-left  	HSSFTextbox textbox = escherGroup.CreateTextbox (new HSSFChildAnchor (x' y' x + width' y + height));  	textbox.IsNoFill = (true);  	textbox.LineStyle = LineStyle.None;  	HSSFRichTextString s = new HSSFRichTextString (str);  	HSSFFont hssfFont = MatchFont (excelFont);  	s.ApplyFont (hssfFont);  	textbox.String = (s);  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) {  	FontDetails d = StaticFontMetrics.GetFontDetails (excelFont);  	int width = (int)((d.GetStringWidth (str) * 8) + 12);  	int height = (int)((font.Size / verticalPixelsPerPoint) + 6) * 2;  	y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  	// we want to Draw the shape from the top-left  	HSSFTextbox textbox = escherGroup.CreateTextbox (new HSSFChildAnchor (x' y' x + width' y + height));  	textbox.IsNoFill = (true);  	textbox.LineStyle = LineStyle.None;  	HSSFRichTextString s = new HSSFRichTextString (str);  	HSSFFont hssfFont = MatchFont (excelFont);  	s.ApplyFont (hssfFont);  	textbox.String = (s);  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) {  	FontDetails d = StaticFontMetrics.GetFontDetails (excelFont);  	int width = (int)((d.GetStringWidth (str) * 8) + 12);  	int height = (int)((font.Size / verticalPixelsPerPoint) + 6) * 2;  	y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  	// we want to Draw the shape from the top-left  	HSSFTextbox textbox = escherGroup.CreateTextbox (new HSSFChildAnchor (x' y' x + width' y + height));  	textbox.IsNoFill = (true);  	textbox.LineStyle = LineStyle.None;  	HSSFRichTextString s = new HSSFRichTextString (str);  	HSSFFont hssfFont = MatchFont (excelFont);  	s.ApplyFont (hssfFont);  	textbox.String = (s);  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: using (Font excelFont = new Font (font.Name.Equals ("SansSerif") ? "Arial" : font.Name' (int)(font.Size / verticalPixelsPerPoint)' font.Style)) {  	FontDetails d = StaticFontMetrics.GetFontDetails (excelFont);  	int width = (int)((d.GetStringWidth (str) * 8) + 12);  	int height = (int)((font.Size / verticalPixelsPerPoint) + 6) * 2;  	y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  	// we want to Draw the shape from the top-left  	HSSFTextbox textbox = escherGroup.CreateTextbox (new HSSFChildAnchor (x' y' x + width' y + height));  	textbox.IsNoFill = (true);  	textbox.LineStyle = LineStyle.None;  	HSSFRichTextString s = new HSSFRichTextString (str);  	HSSFFont hssfFont = MatchFont (excelFont);  	s.ApplyFont (hssfFont);  	textbox.String = (s);  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,DrawString,The following statement contains a magic number: y -= Convert.ToInt32 ((font.Size / verticalPixelsPerPoint) + 2 * verticalPixelsPerPoint);  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,MatchFont,The following statement contains a magic number: if (hssfFont == null) {  	hssfFont = (HSSFFont)workbook.CreateFont ();  	hssfFont.Boldweight = (short)(bold ? NPOI.SS.UserModel.FontBoldWeight.BOLD : 0);  	hssfFont.Color = (hssfColor.GetIndex ());  	hssfFont.FontHeight = ((short)(font.Size * 20));  	hssfFont.FontName = font.Name;  	hssfFont.IsItalic = (italic);  	hssfFont.IsStrikeout = (false);  	hssfFont.TypeOffset = 0;  	hssfFont.Underline = 0;  }  
Magic Number,NPOI.HSSF.UserModel,EscherGraphics,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\EscherGraphics.cs,MatchFont,The following statement contains a magic number: hssfFont.FontHeight = ((short)(font.Size * 20));  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: while (text.Length > 1) {  	if (text [0] != '&') {  		_center = text;  		break;  	}  	int pos = text.Length;  	switch (text [1]) {  	case 'L':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_left = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'C':  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  		}  		_center = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	case 'R':  		if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  		}  		if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  			pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  		}  		_right = text.Substring (2' pos - 2);  		text = text.Substring (pos);  		break;  	default:  		_center = text;  		break;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: switch (text [1]) {  case 'L':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_left = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'C':  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&R"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&R"' StringComparison.Ordinal));  	}  	_center = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  case 'R':  	if (text.IndexOf ("&C"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&C"' StringComparison.Ordinal));  	}  	if (text.IndexOf ("&L"' StringComparison.Ordinal) >= 0) {  		pos = Math.Min (pos' text.IndexOf ("&L"' StringComparison.Ordinal));  	}  	_right = text.Substring (2' pos - 2);  	text = text.Substring (pos);  	break;  default:  	_center = text;  	break;  }  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _left = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _left = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _center = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _center = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _right = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HeaderFooter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HeaderFooter.cs,SplitParts,The following statement contains a magic number: _right = text.Substring (2' pos - 2);  
Magic Number,NPOI.HSSF.UserModel,HSSFAutoFilter,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFAutoFilter.cs,HSSFAutoFilter,The following statement contains a magic number: CreateAutoFilterInfoRecord (sheet' loc + 2' ptg);  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellFormula,The following statement contains a magic number: frec.Options = ((short)2);  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (comment.TextObjectRecord != null) {  	TextObjectRecord txo = comment.TextObjectRecord;  	int txoAt = sheetRecords.IndexOf (txo);  	if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  		// Zap these' in reverse order  		sheetRecords.RemoveAt (txoAt - 1);  		sheetRecords.RemoveAt (txoAt - 2);  		sheetRecords.RemoveAt (txoAt - 3);  	}  	else {  		throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  	}  	// Now Remove the text record  	sheetRecords.Remove (txo);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (comment.TextObjectRecord != null) {  	TextObjectRecord txo = comment.TextObjectRecord;  	int txoAt = sheetRecords.IndexOf (txo);  	if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  		// Zap these' in reverse order  		sheetRecords.RemoveAt (txoAt - 1);  		sheetRecords.RemoveAt (txoAt - 2);  		sheetRecords.RemoveAt (txoAt - 3);  	}  	else {  		throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  	}  	// Now Remove the text record  	sheetRecords.Remove (txo);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (comment.TextObjectRecord != null) {  	TextObjectRecord txo = comment.TextObjectRecord;  	int txoAt = sheetRecords.IndexOf (txo);  	if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  		// Zap these' in reverse order  		sheetRecords.RemoveAt (txoAt - 1);  		sheetRecords.RemoveAt (txoAt - 2);  		sheetRecords.RemoveAt (txoAt - 3);  	}  	else {  		throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  	}  	// Now Remove the text record  	sheetRecords.Remove (txo);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (comment.TextObjectRecord != null) {  	TextObjectRecord txo = comment.TextObjectRecord;  	int txoAt = sheetRecords.IndexOf (txo);  	if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  		// Zap these' in reverse order  		sheetRecords.RemoveAt (txoAt - 1);  		sheetRecords.RemoveAt (txoAt - 2);  		sheetRecords.RemoveAt (txoAt - 3);  	}  	else {  		throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  	}  	// Now Remove the text record  	sheetRecords.Remove (txo);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  	// Zap these' in reverse order  	sheetRecords.RemoveAt (txoAt - 1);  	sheetRecords.RemoveAt (txoAt - 2);  	sheetRecords.RemoveAt (txoAt - 3);  }  else {  	throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  	// Zap these' in reverse order  	sheetRecords.RemoveAt (txoAt - 1);  	sheetRecords.RemoveAt (txoAt - 2);  	sheetRecords.RemoveAt (txoAt - 3);  }  else {  	throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  	// Zap these' in reverse order  	sheetRecords.RemoveAt (txoAt - 1);  	sheetRecords.RemoveAt (txoAt - 2);  	sheetRecords.RemoveAt (txoAt - 3);  }  else {  	throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: if (sheetRecords [txoAt - 3] is DrawingRecord && sheetRecords [txoAt - 2] is ObjRecord && sheetRecords [txoAt - 1] is DrawingRecord) {  	// Zap these' in reverse order  	sheetRecords.RemoveAt (txoAt - 1);  	sheetRecords.RemoveAt (txoAt - 2);  	sheetRecords.RemoveAt (txoAt - 3);  }  else {  	throw new InvalidOperationException ("Found the wrong records before the TextObjectRecord' can't Remove comment");  }  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: sheetRecords.RemoveAt (txoAt - 2);  
Magic Number,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,RemoveCellComment,The following statement contains a magic number: sheetRecords.RemoveAt (txoAt - 3);  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (dx1' 0' 1023' "dx1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (dx2' 0' 1023' "dx2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (dy1' 0' 255' "dy1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (dy2' 0' 255' "dy2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (col1' 0' 255' "col1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (col2' 0' 255' "col2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (row1' 0' 255 * 256' "row1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (row1' 0' 255 * 256' "row1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (row2' 0' 255 * 256' "row2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,HSSFClientAnchor,The following statement contains a magic number: CheckRange (row2' 0' 255 * 256' "row2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (x1' 0' 1023' "dx1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (x2' 0' 1023' "dx2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (y1' 0' 255' "dy1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (y2' 0' 255' "dy2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (col1' 0' 255' "col1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (col2' 0' 255' "col2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (row1' 0' 255 * 256' "row1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (row1' 0' 255 * 256' "row1");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (row2' 0' 255 * 256' "row2");  
Magic Number,NPOI.HSSF.UserModel,HSSFClientAnchor,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFClientAnchor.cs,SetAnchor,The following statement contains a magic number: CheckRange (row2' 0' 255 * 256' "row2");  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int i = 0; i < newPos.Length; i++) {  	// There is no 4!  	if (i == 4)  		continue;  	frecs [i] = workbook.Workbook.GetFontRecordAt (i);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: if (i == 4)  	continue;  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int i = 5; i < newPos.Length; i++) {  	// Check this one for being a duplicate  	//  of an earlier one  	int earlierDuplicate = -1;  	for (int j = 0; j < i && earlierDuplicate == -1; j++) {  		if (j == 4)  			continue;  		FontRecord frCheck = workbook.Workbook.GetFontRecordAt (j);  		if (frCheck.SameProperties (frecs [i])) {  			earlierDuplicate = j;  		}  	}  	// If we got a duplicate' mark it as such  	if (earlierDuplicate != -1) {  		newPos [i] = (short)earlierDuplicate;  		zapRecords [i] = true;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int i = 5; i < newPos.Length; i++) {  	// Check this one for being a duplicate  	//  of an earlier one  	int earlierDuplicate = -1;  	for (int j = 0; j < i && earlierDuplicate == -1; j++) {  		if (j == 4)  			continue;  		FontRecord frCheck = workbook.Workbook.GetFontRecordAt (j);  		if (frCheck.SameProperties (frecs [i])) {  			earlierDuplicate = j;  		}  	}  	// If we got a duplicate' mark it as such  	if (earlierDuplicate != -1) {  		newPos [i] = (short)earlierDuplicate;  		zapRecords [i] = true;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int j = 0; j < i && earlierDuplicate == -1; j++) {  	if (j == 4)  		continue;  	FontRecord frCheck = workbook.Workbook.GetFontRecordAt (j);  	if (frCheck.SameProperties (frecs [i])) {  		earlierDuplicate = j;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: if (j == 4)  	continue;  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int i = 5; i < newPos.Length; i++) {  	// Find the number deleted to that  	//  point' and adjust  	short preDeletePos = newPos [i];  	short newPosition = preDeletePos;  	for (int j = 0; j < preDeletePos; j++) {  		if (zapRecords [j])  			newPosition--;  	}  	// Update the new position  	newPos [i] = newPosition;  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int i = 5; i < newPos.Length; i++) {  	if (zapRecords [i]) {  		workbook.Workbook.RemoveFontRecord (frecs [i]);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (int sheetNum = 0; sheetNum < workbook.NumberOfSheets; sheetNum++) {  	NPOI.SS.UserModel.ISheet s = workbook.GetSheetAt (sheetNum);  	IEnumerator rIt = s.GetRowEnumerator ();  	while (rIt.MoveNext ()) {  		HSSFRow row = (HSSFRow)rIt.Current;  		IEnumerator cIt = row.GetEnumerator ();  		while (cIt.MoveNext ()) {  			ICell cell = (HSSFCell)cIt.Current;  			if (cell.CellType == NPOI.SS.UserModel.CellType.STRING) {  				HSSFRichTextString rtr = (HSSFRichTextString)cell.RichStringCellValue;  				UnicodeString u = rtr.RawUnicodeString;  				// Have we done this string already?  				if (!doneUnicodeStrings.Contains (u)) {  					// Update for each new position  					for (short i = 5; i < newPos.Length; i++) {  						if (i != newPos [i]) {  							u.SwapFontUse (i' newPos [i]);  						}  					}  					// Mark as done  					doneUnicodeStrings.Add (u);  				}  			}  		}  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: while (rIt.MoveNext ()) {  	HSSFRow row = (HSSFRow)rIt.Current;  	IEnumerator cIt = row.GetEnumerator ();  	while (cIt.MoveNext ()) {  		ICell cell = (HSSFCell)cIt.Current;  		if (cell.CellType == NPOI.SS.UserModel.CellType.STRING) {  			HSSFRichTextString rtr = (HSSFRichTextString)cell.RichStringCellValue;  			UnicodeString u = rtr.RawUnicodeString;  			// Have we done this string already?  			if (!doneUnicodeStrings.Contains (u)) {  				// Update for each new position  				for (short i = 5; i < newPos.Length; i++) {  					if (i != newPos [i]) {  						u.SwapFontUse (i' newPos [i]);  					}  				}  				// Mark as done  				doneUnicodeStrings.Add (u);  			}  		}  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: while (cIt.MoveNext ()) {  	ICell cell = (HSSFCell)cIt.Current;  	if (cell.CellType == NPOI.SS.UserModel.CellType.STRING) {  		HSSFRichTextString rtr = (HSSFRichTextString)cell.RichStringCellValue;  		UnicodeString u = rtr.RawUnicodeString;  		// Have we done this string already?  		if (!doneUnicodeStrings.Contains (u)) {  			// Update for each new position  			for (short i = 5; i < newPos.Length; i++) {  				if (i != newPos [i]) {  					u.SwapFontUse (i' newPos [i]);  				}  			}  			// Mark as done  			doneUnicodeStrings.Add (u);  		}  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: if (cell.CellType == NPOI.SS.UserModel.CellType.STRING) {  	HSSFRichTextString rtr = (HSSFRichTextString)cell.RichStringCellValue;  	UnicodeString u = rtr.RawUnicodeString;  	// Have we done this string already?  	if (!doneUnicodeStrings.Contains (u)) {  		// Update for each new position  		for (short i = 5; i < newPos.Length; i++) {  			if (i != newPos [i]) {  				u.SwapFontUse (i' newPos [i]);  			}  		}  		// Mark as done  		doneUnicodeStrings.Add (u);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: if (!doneUnicodeStrings.Contains (u)) {  	// Update for each new position  	for (short i = 5; i < newPos.Length; i++) {  		if (i != newPos [i]) {  			u.SwapFontUse (i' newPos [i]);  		}  	}  	// Mark as done  	doneUnicodeStrings.Add (u);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseFonts,The following statement contains a magic number: for (short i = 5; i < newPos.Length; i++) {  	if (i != newPos [i]) {  		u.SwapFontUse (i' newPos [i]);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseCellStyles,The following statement contains a magic number: for (int i = 21; i < newPos.Length; i++) {  	// Check this one for being a duplicate  	//  of an earlier one  	int earlierDuplicate = -1;  	for (int j = 0; j < i && earlierDuplicate == -1; j++) {  		ExtendedFormatRecord xfCheck = workbook.Workbook.GetExFormatAt (j);  		if (xfCheck.Equals (xfrs [i])) {  			earlierDuplicate = j;  		}  	}  	// If we got a duplicate' mark it as such  	if (earlierDuplicate != -1) {  		newPos [i] = (short)earlierDuplicate;  		zapRecords [i] = true;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseCellStyles,The following statement contains a magic number: for (int i = 21; i < newPos.Length; i++) {  	// Find the number deleted to that  	//  point' and adjust  	short preDeletePos = newPos [i];  	short newPosition = preDeletePos;  	for (int j = 0; j < preDeletePos; j++) {  		if (zapRecords [j])  			newPosition--;  	}  	// Update the new position  	newPos [i] = newPosition;  }  
Magic Number,NPOI.HSSF.UserModel,HSSFOptimiser,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFOptimiser.cs,OptimiseCellStyles,The following statement contains a magic number: for (int i = 21; i < newPos.Length; i++) {  	if (zapRecords [i]) {  		workbook.Workbook.RemoveExFormatRecord (xfrs [i]);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPalette,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPalette.cs,FindColor,The following statement contains a magic number: for (short i = (short)PaletteRecord.FIRST_COLOR_INDEX; b != null; b = palette.GetColor (++i)) {  	if (b [0] == red && b [1] == green && b [2] == blue) {  		return new CustomColor (i' b);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPalette,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPalette.cs,FindColor,The following statement contains a magic number: if (b [0] == red && b [1] == green && b [2] == blue) {  	return new CustomColor (i' b);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPalette,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPalette.cs,FindSimilarColor,The following statement contains a magic number: for (short i = (short)PaletteRecord.FIRST_COLOR_INDEX; b != null; b = palette.GetColor (++i)) {  	int colorDistance = Math.Abs (red - b [0]) + Math.Abs (green - b [1]) + Math.Abs (blue - b [2]);  	if (colorDistance < minColorDistance) {  		minColorDistance = colorDistance;  		result = GetColor (i);  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPatriarch,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPatriarch.cs,ContainsChart,The following statement contains a magic number: for (IEnumerator it = optRecord.EscherProperties.GetEnumerator (); it.MoveNext ();) {  	EscherProperty prop = (EscherProperty)it.Current;  	if (prop.PropertyNumber == 896 && prop.IsComplex) {  		EscherComplexProperty cp = (EscherComplexProperty)prop;  		String str = StringUtil.GetFromUnicodeLE (cp.ComplexData);  		//Console.Error.WriteLine(str);  		if (str.Equals ("Chart 1\0")) {  			return true;  		}  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPatriarch,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPatriarch.cs,ContainsChart,The following statement contains a magic number: if (prop.PropertyNumber == 896 && prop.IsComplex) {  	EscherComplexProperty cp = (EscherComplexProperty)prop;  	String str = StringUtil.GetFromUnicodeLE (cp.ComplexData);  	//Console.Error.WriteLine(str);  	if (str.Equals ("Chart 1\0")) {  		return true;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,Resize,The following statement contains a magic number: anchor.AnchorType = 2;  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: w += GetColumnWidthInPixels (anchor.Col1) * (1 - (float)anchor.Dx1 / 1024);  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: if (w > scaledWidth) {  	//calculate dx2' offset in the rightmost cell  	col2--;  	double cw = GetColumnWidthInPixels (col2);  	double delta = w - scaledWidth;  	dx2 = (int)((cw - delta) / cw * 1024);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: dx2 = (int)((cw - delta) / cw * 1024);  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: h += (1 - (float)anchor.Dy1 / 256) * GetRowHeightInPixels (anchor.Row1);  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: if (h > scaledHeight) {  	row2--;  	double ch = GetRowHeightInPixels (row2);  	double delta = h - scaledHeight;  	dy2 = (int)((ch - delta) / ch * 256);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFPicture,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFPicture.cs,GetPreferredSize,The following statement contains a magic number: dy2 = (int)((ch - delta) / ch * 256);  
Magic Number,NPOI.HSSF.UserModel,HSSFShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFShape.cs,SetLineStyleColor,The following statement contains a magic number: this.lineStyleColor = ((blue) << 16) | ((green) << 8) | red;  
Magic Number,NPOI.HSSF.UserModel,HSSFShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFShape.cs,SetLineStyleColor,The following statement contains a magic number: this.lineStyleColor = ((blue) << 16) | ((green) << 8) | red;  
Magic Number,NPOI.HSSF.UserModel,HSSFShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFShape.cs,SetFillColor,The following statement contains a magic number: this.FillColor = ((blue) << 16) | ((green) << 8) | red;  
Magic Number,NPOI.HSSF.UserModel,HSSFShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFShape.cs,SetFillColor,The following statement contains a magic number: this.FillColor = ((blue) << 16) | ((green) << 8) | red;  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetZoom,The following statement contains a magic number: if (numerator < 1 || numerator > 65535)  	throw new ArgumentException ("Numerator must be greater than 1 and less than 65536");  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetZoom,The following statement contains a magic number: if (denominator < 1 || denominator > 65535)  	throw new ArgumentException ("Denominator must be greater than 1 and less than 65536");  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,ShiftRows,The following statement contains a magic number: for (int rowNum = s; rowNum >= startRow && rowNum <= endRow && rowNum >= 0 && rowNum < 65536; rowNum += inc) {  	HSSFRow row = (HSSFRow)GetRow (rowNum);  	// notify all cells in this row that we are going to shift them'  	// it can throw IllegalStateException if the operation is not allowed' for example'  	// if the row contains cells included in a multi-cell array formula  	if (row != null)  		NotifyRowShifting (row);  	HSSFRow row2Replace = (HSSFRow)GetRow (rowNum + n);  	if (row2Replace == null)  		row2Replace = (HSSFRow)CreateRow (rowNum + n);  	// Remove all the old cells from the row we'll  	//  be writing too' before we start overwriting   	//  any cells. This avoids issues with cells   	//  changing type' and records not being correctly  	//  overwritten  	row2Replace.RemoveAllCells ();  	// If this row doesn't exist' nothing needs to  	//  be done for the now empty destination row  	if (row == null)  		continue;  	// Nothing to do for this row  	// Fix up row heights if required  	if (copyRowHeight) {  		row2Replace.Height = (row.Height);  	}  	if (resetOriginalRowHeight) {  		row.Height = ((short)0xff);  	}  	// Copy each cell from the source row to  	//  the destination row  	List<ICell> cells = row.Cells;  	foreach (ICell cell in cells) {  		row.RemoveCell (cell);  		CellValueRecordInterface cellRecord = ((HSSFCell)cell).CellValueRecord;  		cellRecord.Row = (rowNum + n);  		row2Replace.CreateCellFromRecord (cellRecord);  		_sheet.AddValueRecord (rowNum + n' cellRecord);  		NPOI.SS.UserModel.IHyperlink link = cell.Hyperlink;  		if (link != null) {  			link.FirstRow = (link.FirstRow + n);  			link.LastRow = (link.LastRow + n);  		}  	}  	// Now zap all the cells in the source row  	row.RemoveAllCells ();  	// Move comments from the source row to the  	//  destination row. Note that comments can  	//  exist for cells which are null  	if (moveComments) {  		// This code would get simpler if NoteRecords could be organised by HSSFRow.  		for (int i = noteRecs.Length - 1; i >= 0; i--) {  			NoteRecord nr = noteRecs [i];  			if (nr.Row != rowNum) {  				continue;  			}  			IComment comment = GetCellComment (rowNum' nr.Column);  			if (comment != null) {  				comment.Row = (rowNum + n);  			}  		}  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetRowBreak,The following statement contains a magic number: _sheet.PageSettings.SetRowBreak (row' (short)0' (short)255);  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,SetColumnBreak,The following statement contains a magic number: _sheet.PageSettings.SetColumnBreak (column' (short)0' unchecked((short)65535));  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,AutoSizeColumn,The following statement contains a magic number: if (width != -1) {  	width *= 256;  	int maxColumnWidth = 255 * 256;  	// The maximum column width for an individual cell is 255 characters  	if (width > maxColumnWidth) {  		width = maxColumnWidth;  	}  	SetColumnWidth (column' (int)width);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,AutoSizeColumn,The following statement contains a magic number: if (width != -1) {  	width *= 256;  	int maxColumnWidth = 255 * 256;  	// The maximum column width for an individual cell is 255 characters  	if (width > maxColumnWidth) {  		width = maxColumnWidth;  	}  	SetColumnWidth (column' (int)width);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,AutoSizeColumn,The following statement contains a magic number: if (width != -1) {  	width *= 256;  	int maxColumnWidth = 255 * 256;  	// The maximum column width for an individual cell is 255 characters  	if (width > maxColumnWidth) {  		width = maxColumnWidth;  	}  	SetColumnWidth (column' (int)width);  }  
Magic Number,NPOI.HSSF.UserModel,HSSFSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheet.cs,AutoSizeColumn,The following statement contains a magic number: width *= 256;  
Magic Number,NPOI.HSSF.UserModel,HSSFSheetConditionalFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFSheetConditionalFormatting.cs,AddConditionalFormatting,The following statement contains a magic number: if (cfRules.Length > 3) {  	throw new ArgumentException ("Number of rules must not exceed 3");  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: if (bracketPos > 0 && srcName.EndsWith (")"' StringComparison.Ordinal)) {  	String suffix = srcName.Substring (bracketPos + 1' srcName.Length - bracketPos - 2);  	try {  		uniqueIndex = Int32.Parse (suffix.Trim ()' CultureInfo.InvariantCulture);  		uniqueIndex++;  		baseName = srcName.Substring (0' bracketPos).Trim ();  	}  	catch (FormatException) {  		// contents of brackets not numeric  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: while (true) {  	// Try and find the next sheet name that is unique  	String index = (uniqueIndex++).ToString (CultureInfo.CurrentCulture);  	String name;  	if (baseName.Length + index.Length + 2 < 31) {  		name = baseName + " (" + index + ")";  	}  	else {  		name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  	}  	//If the sheet name is unique' then set it otherwise move on to the next number.  	if (workbook.GetSheetIndex (name) == -1) {  		return name;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: while (true) {  	// Try and find the next sheet name that is unique  	String index = (uniqueIndex++).ToString (CultureInfo.CurrentCulture);  	String name;  	if (baseName.Length + index.Length + 2 < 31) {  		name = baseName + " (" + index + ")";  	}  	else {  		name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  	}  	//If the sheet name is unique' then set it otherwise move on to the next number.  	if (workbook.GetSheetIndex (name) == -1) {  		return name;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: while (true) {  	// Try and find the next sheet name that is unique  	String index = (uniqueIndex++).ToString (CultureInfo.CurrentCulture);  	String name;  	if (baseName.Length + index.Length + 2 < 31) {  		name = baseName + " (" + index + ")";  	}  	else {  		name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  	}  	//If the sheet name is unique' then set it otherwise move on to the next number.  	if (workbook.GetSheetIndex (name) == -1) {  		return name;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: while (true) {  	// Try and find the next sheet name that is unique  	String index = (uniqueIndex++).ToString (CultureInfo.CurrentCulture);  	String name;  	if (baseName.Length + index.Length + 2 < 31) {  		name = baseName + " (" + index + ")";  	}  	else {  		name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  	}  	//If the sheet name is unique' then set it otherwise move on to the next number.  	if (workbook.GetSheetIndex (name) == -1) {  		return name;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: if (baseName.Length + index.Length + 2 < 31) {  	name = baseName + " (" + index + ")";  }  else {  	name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: if (baseName.Length + index.Length + 2 < 31) {  	name = baseName + " (" + index + ")";  }  else {  	name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: if (baseName.Length + index.Length + 2 < 31) {  	name = baseName + " (" + index + ")";  }  else {  	name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: if (baseName.Length + index.Length + 2 < 31) {  	name = baseName + " (" + index + ")";  }  else {  	name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,GetUniqueSheetName,The following statement contains a magic number: name = baseName.Substring (0' 31 - index.Length - 2) + "(" + index + ")";  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,The following statement contains a magic number: if (startRow < -1 || startRow > 65535)  	throw new ArgumentException ("Invalid row range specification");  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,The following statement contains a magic number: if (endRow < -1 || endRow > 65535)  	throw new ArgumentException ("Invalid row range specification");  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,The following statement contains a magic number: if (settingRowAndColumn) {  	int exprsSize = 2 * 11 + 1;  	// 2 * Area3DPtg.SIZE + UnionPtg.SIZE  	temp.Add (new MemFuncPtg (exprsSize));  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,SetRepeatingRowsAndColumns,The following statement contains a magic number: if (settingRowAndColumn) {  	int exprsSize = 2 * 11 + 1;  	// 2 * Area3DPtg.SIZE + UnionPtg.SIZE  	temp.Add (new MemFuncPtg (exprsSize));  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,IsRowColHeaderRecord,The following statement contains a magic number: return r.OptionFlag == 0x20 && ("" + ((char)7)).Equals (r.NameText);  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,CreateFont,The following statement contains a magic number: if (fontindex > 3) {  	fontindex++;  	// THERE Is NO FOUR!!  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The following statement contains a magic number: for (short i = 0; i <= this.NumberOfFonts; i++) {  	// Remember - there is no 4!  	if (i == 4)  		continue;  	NPOI.SS.UserModel.IFont hssfFont = GetFontAt (i);  	//            Console.WriteLine( hssfFont.GetBoldweight() + "' " + hssfFont.GetColor() + "' " + hssfFont.FontHeight + "' " + hssfFont.FontName + "' " + hssfFont.GetItalic() + "' " + hssfFont.GetStrikeout() + "' " + hssfFont.GetTypeOffset() + "' " + hssfFont.Underline );  	if (hssfFont.Boldweight == boldWeight && hssfFont.Color == color && hssfFont.FontHeight == fontHeight && hssfFont.FontName.Equals (name) && hssfFont.IsItalic == italic && hssfFont.IsStrikeout == strikeout && hssfFont.TypeOffset == typeOffset && hssfFont.Underline == Underline) {  		//                Console.WriteLine( "Found font" );  		return hssfFont;  	}  }  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,FindFont,The following statement contains a magic number: if (i == 4)  	continue;  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,AddPicture,The following statement contains a magic number: r.Options = (short)(0x0002 | ((int)format << 4));  
Magic Number,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,AddPicture,The following statement contains a magic number: r.Size = pictureData.Length + 25;  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings = new UnicodeMapping[15];  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [2] = um ("gamma"' "\u03B3");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [3] = um ("delta"' "\u03B4");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [4] = um ("epsilon"' "\u03B5");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [5] = um ("zeta"' "\u03B6");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [6] = um ("eta"' "\u03B7");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [7] = um ("theta"' "\u03B8");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [8] = um ("iota"' "\u03B9");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [9] = um ("kappa"' "\u03BA");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [10] = um ("lambda"' "\u03BB");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [11] = um ("mu"' "\u03BC");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [12] = um ("nu"' "\u03BD");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [13] = um ("xi"' "\u03BE");  
Magic Number,NPOI.HSSF.Util,HSSFCellUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellUtil.cs,HSSFCellUtil,The following statement contains a magic number: unicodeMappings [14] = um ("omicron"' "\u03BF");  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (HexDump.IntToHex (_d1)' PREFIX_LEN' 8);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (HexDump.ShortToHex (_d2)' PREFIX_LEN' 4);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (HexDump.ShortToHex (_d3)' PREFIX_LEN' 4);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (d4Chars' PREFIX_LEN' 4);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (d4Chars' PREFIX_LEN + 4' 12);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,FormatAsString,The following statement contains a magic number: sb.Append (d4Chars' PREFIX_LEN + 4' 12);  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,Parse,The following statement contains a magic number: for (int i = 23; i > 19; i--) {  	cc [i] = cc [i - 1];  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,Parse,The following statement contains a magic number: for (int i = 23; i > 19; i--) {  	cc [i] = cc [i - 1];  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: for (int i = startIndex + 14; i >= startIndex; i -= 2) {  	acc <<= 4;  	acc += ParseHexChar (cc [i + 0]);  	acc <<= 4;  	acc += ParseHexChar (cc [i + 1]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: for (int i = startIndex + 14; i >= startIndex; i -= 2) {  	acc <<= 4;  	acc += ParseHexChar (cc [i + 0]);  	acc <<= 4;  	acc += ParseHexChar (cc [i + 1]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: for (int i = startIndex + 14; i >= startIndex; i -= 2) {  	acc <<= 4;  	acc += ParseHexChar (cc [i + 0]);  	acc <<= 4;  	acc += ParseHexChar (cc [i + 1]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: for (int i = startIndex + 14; i >= startIndex; i -= 2) {  	acc <<= 4;  	acc += ParseHexChar (cc [i + 0]);  	acc <<= 4;  	acc += ParseHexChar (cc [i + 1]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: i -= 2
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: acc <<= 4;  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseLELong,The following statement contains a magic number: acc <<= 4;  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseShort,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	acc <<= 4;  	acc += ParseHexChar (cc [startIndex + i]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseShort,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	acc <<= 4;  	acc += ParseHexChar (cc [startIndex + i]);  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseShort,The following statement contains a magic number: acc <<= 4;  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseHexChar,The following statement contains a magic number: if (c >= 'A' && c <= 'F') {  	return c - 'A' + 10;  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseHexChar,The following statement contains a magic number: return c - 'A' + 10;  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseHexChar,The following statement contains a magic number: if (c >= 'a' && c <= 'f') {  	return c - 'a' + 10;  }  
Magic Number,NPOI.HSSF.Util,GUID,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\GUID.cs,ParseHexChar,The following statement contains a magic number: return c - 'a' + 10;  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,FillFields,The following statement contains a magic number: for (int k = 0; k < this.field_Addr_number; k++) {  	short first_row = in1.ReadShort ();  	short first_col = in1.ReadShort ();  	short last_row = first_row;  	short last_col = first_col;  	if (in1.Remaining >= 4) {  		last_row = in1.ReadShort ();  		last_col = in1.ReadShort ();  	}  	else {  		// Ran out of data  		// For now' Issue a warning' finish' and   		//  hope for the best....  		logger.Log (POILogger.WARN' "Ran out of data reading cell references for DVRecord");  		k = this.field_Addr_number;  	}  	AddrStructure region = new AddrStructure (first_row' first_col' last_row' last_col);  	this.field_regions_list.Add (region);  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,FillFields,The following statement contains a magic number: if (in1.Remaining >= 4) {  	last_row = in1.ReadShort ();  	last_col = in1.ReadShort ();  }  else {  	// Ran out of data  	// For now' Issue a warning' finish' and   	//  hope for the best....  	logger.Log (POILogger.WARN' "Ran out of data reading cell references for DVRecord");  	k = this.field_Addr_number;  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,AddAddRStructure,The following statement contains a magic number: if (this.field_regions_list == null) {  	//just to be sure :-)  	this.field_Addr_number = 0;  	this.field_regions_list = new ArrayList (10);  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,AddAddRStructure,The following statement contains a magic number: this.field_regions_list = new ArrayList (10);  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: for (int k = 0; k < this.AddRStructureNumber; k++) {  	AddrStructure region = this.GetAddRStructureAt (k);  	LittleEndian.PutShort (data' offSet + pos' region.FirstRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.FirstColumn);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastColumn);  	pos += 2;  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: for (int k = 0; k < this.AddRStructureNumber; k++) {  	AddrStructure region = this.GetAddRStructureAt (k);  	LittleEndian.PutShort (data' offSet + pos' region.FirstRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.FirstColumn);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastColumn);  	pos += 2;  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: for (int k = 0; k < this.AddRStructureNumber; k++) {  	AddrStructure region = this.GetAddRStructureAt (k);  	LittleEndian.PutShort (data' offSet + pos' region.FirstRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.FirstColumn);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastColumn);  	pos += 2;  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: for (int k = 0; k < this.AddRStructureNumber; k++) {  	AddrStructure region = this.GetAddRStructureAt (k);  	LittleEndian.PutShort (data' offSet + pos' region.FirstRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastRow);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.FirstColumn);  	pos += 2;  	LittleEndian.PutShort (data' offSet + pos' region.LastColumn);  	pos += 2;  }  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Util,HSSFCellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\HSSFCellRangeAddress.cs,Serialize,The following statement contains a magic number: pos += 2;  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,init,The following statement contains a magic number: m_cellTo = urls [2];  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: if (index >= 0) {  	String fromStr = _url.Substring (0' index);  	String toStr = _url.Substring (index + 1);  	index = fromStr.IndexOf ('!');  	if (index >= 0) {  		result [0] = fromStr.Substring (0' index);  		result [1] = fromStr.Substring (index + 1);  	}  	else {  		result [1] = fromStr;  	}  	index = toStr.IndexOf ('!');  	if (index >= 0) {  		result [2] = toStr.Substring (index + 1);  	}  	else {  		result [2] = toStr;  	}  }  else {  	index = _url.IndexOf ('!');  	if (index >= 0) {  		result [0] = _url.Substring (0' index);  		result [1] = _url.Substring (index + 1);  	}  	else {  		result [1] = _url;  	}  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: if (index >= 0) {  	String fromStr = _url.Substring (0' index);  	String toStr = _url.Substring (index + 1);  	index = fromStr.IndexOf ('!');  	if (index >= 0) {  		result [0] = fromStr.Substring (0' index);  		result [1] = fromStr.Substring (index + 1);  	}  	else {  		result [1] = fromStr;  	}  	index = toStr.IndexOf ('!');  	if (index >= 0) {  		result [2] = toStr.Substring (index + 1);  	}  	else {  		result [2] = toStr;  	}  }  else {  	index = _url.IndexOf ('!');  	if (index >= 0) {  		result [0] = _url.Substring (0' index);  		result [1] = _url.Substring (index + 1);  	}  	else {  		result [1] = _url;  	}  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: if (index >= 0) {  	result [2] = toStr.Substring (index + 1);  }  else {  	result [2] = toStr;  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: if (index >= 0) {  	result [2] = toStr.Substring (index + 1);  }  else {  	result [2] = toStr;  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: result [2] = toStr.Substring (index + 1);  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,ParseURL,The following statement contains a magic number: result [2] = toStr;  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,GetXPosition,The following statement contains a magic number: if (IsLetter (tmp) && ((tmp.Length == 2) || (tmp.Length == 1))) {  	result = Get26Sys (tmp);  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,Get26Sys,The following statement contains a magic number: if (!string.IsNullOrEmpty (_s)) {  	for (int i = _s.Length - 1; i >= 0; i--) {  		char ch = _s [i];  		int val = (int)(Char.GetNumericValue (ch) - Char.GetNumericValue ('A') + 1);  		sum = sum + val * multiplier;  		multiplier = multiplier * 26;  	}  	return sum;  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,Get26Sys,The following statement contains a magic number: for (int i = _s.Length - 1; i >= 0; i--) {  	char ch = _s [i];  	int val = (int)(Char.GetNumericValue (ch) - Char.GetNumericValue ('A') + 1);  	sum = sum + val * multiplier;  	multiplier = multiplier * 26;  }  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,Get26Sys,The following statement contains a magic number: multiplier = multiplier * 26;  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,NumTo26Sys,The following statement contains a magic number: do {  	_num--;  	reminder = _num % 26;  	int val = 65 + reminder;  	_num = _num / 26;  	s = (char)val + s;  	// reverce  }  while (_num > 0);  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,NumTo26Sys,The following statement contains a magic number: do {  	_num--;  	reminder = _num % 26;  	int val = 65 + reminder;  	_num = _num / 26;  	s = (char)val + s;  	// reverce  }  while (_num > 0);  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,NumTo26Sys,The following statement contains a magic number: do {  	_num--;  	reminder = _num % 26;  	int val = 65 + reminder;  	_num = _num / 26;  	s = (char)val + s;  	// reverce  }  while (_num > 0);  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,NumTo26Sys,The following statement contains a magic number: reminder = _num % 26;  
Magic Number,NPOI.HSSF.Util,RangeAddress,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RangeAddress.cs,NumTo26Sys,The following statement contains a magic number: _num = _num / 26;  
Magic Number,NPOI.HSSF.Util,RKUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RKUtil.cs,DecodeNumber,The following statement contains a magic number: raw_number = raw_number >> 2;  
Magic Number,NPOI.HSSF.Util,RKUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RKUtil.cs,DecodeNumber,The following statement contains a magic number: if ((number & 0x02) == 0x02) {  	// ok' it's just a plain ol' int; we can handle this  	// trivially by casting  	rvalue = (double)(raw_number);  }  else {  	// also trivial' but not as obvious ... left Shift the  	// bits high and use that clever static method in double  	// to convert the resulting bit image to a double  	rvalue = BitConverter.Int64BitsToDouble (raw_number << 34);  }  
Magic Number,NPOI.HSSF.Util,RKUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RKUtil.cs,DecodeNumber,The following statement contains a magic number: rvalue = BitConverter.Int64BitsToDouble (raw_number << 34);  
Magic Number,NPOI.HSSF.Util,RKUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RKUtil.cs,DecodeNumber,The following statement contains a magic number: if ((number & 0x01) == 0x01) {  	// low-order bit says divide by 100' and so we do. Why?  	// 'cause that's what the algorithm says. Can't fight city  	// hall' especially if it's the city of Redmond  	rvalue /= 100;  }  
Magic Number,NPOI.HSSF.Util,RKUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Util\RKUtil.cs,DecodeNumber,The following statement contains a magic number: rvalue /= 100;  
Magic Number,NPOI.HPSF,DocumentSummaryInformation,C:\repos\xoposhiy_npoi\trunk\main\HPSF\DocumentSummaryInformation.cs,EnsureSection2,The following statement contains a magic number: if (SectionCount < 2) {  	MutableSection s2 = new MutableSection ();  	s2.SetFormatID (SectionIDMap.DOCUMENT_SUMMARY_INFORMATION_ID2);  	AddSection (s2);  }  
Magic Number,NPOI.HPSF,DocumentSummaryInformation,C:\repos\xoposhiy_npoi\trunk\main\HPSF\DocumentSummaryInformation.cs,RemoveCustomProperties,The following statement contains a magic number: if (SectionCount >= 2)  	Sections.RemoveAt (1);  else  	throw new HPSFRuntimeException ("Illegal internal format of Document SummaryInformation stream: second section is missing.");  
Magic Number,NPOI.HPSF,MutablePropertySet,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutablePropertySet.cs,MutablePropertySet,The following statement contains a magic number: osVersion = (OS_WIN32 << 16) | 0x0A04;  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyStream = new MemoryStream ()) {  	/* The property list is established here. After each property that has                  * been written To "propertyStream"' a property list entry is written To                  * "propertyListStream". */using (MemoryStream propertyListStream = new MemoryStream ()) {  		/* Maintain the current position in the list. */int position = 0;  		/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  		/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  		if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  			Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  			if (p1 != null) {  				if (!(p1 is int))  					throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  			}  			else  				/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  			codepage = Codepage;  		}  		/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  		/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  			MutableProperty p = (MutableProperty)preprops [i];  			long id = p.ID;  			/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  			TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  			/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  				/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  			}  			else {  				if (codepage == -1)  					throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  				position += WriteDictionary (propertyStream' dictionary' codepage);  			}  		}  		propertyStream.Flush ();  		propertyListStream.Flush ();  		/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  		byte[] pb2 = propertyStream.ToArray ();  		/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  		/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  		/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  		/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  		int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  		return streamLength;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyStream = new MemoryStream ()) {  	/* The property list is established here. After each property that has                  * been written To "propertyStream"' a property list entry is written To                  * "propertyListStream". */using (MemoryStream propertyListStream = new MemoryStream ()) {  		/* Maintain the current position in the list. */int position = 0;  		/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  		/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  		if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  			Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  			if (p1 != null) {  				if (!(p1 is int))  					throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  			}  			else  				/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  			codepage = Codepage;  		}  		/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  		/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  			MutableProperty p = (MutableProperty)preprops [i];  			long id = p.ID;  			/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  			TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  			/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  				/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  			}  			else {  				if (codepage == -1)  					throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  				position += WriteDictionary (propertyStream' dictionary' codepage);  			}  		}  		propertyStream.Flush ();  		propertyListStream.Flush ();  		/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  		byte[] pb2 = propertyStream.ToArray ();  		/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  		/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  		/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  		/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  		int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  		return streamLength;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyStream = new MemoryStream ()) {  	/* The property list is established here. After each property that has                  * been written To "propertyStream"' a property list entry is written To                  * "propertyListStream". */using (MemoryStream propertyListStream = new MemoryStream ()) {  		/* Maintain the current position in the list. */int position = 0;  		/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  		/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  		if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  			Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  			if (p1 != null) {  				if (!(p1 is int))  					throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  			}  			else  				/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  			codepage = Codepage;  		}  		/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  		/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  			MutableProperty p = (MutableProperty)preprops [i];  			long id = p.ID;  			/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  			TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  			/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  				/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  			}  			else {  				if (codepage == -1)  					throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  				position += WriteDictionary (propertyStream' dictionary' codepage);  			}  		}  		propertyStream.Flush ();  		propertyListStream.Flush ();  		/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  		byte[] pb2 = propertyStream.ToArray ();  		/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  		/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  		/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  		/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  		int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  		return streamLength;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyStream = new MemoryStream ()) {  	/* The property list is established here. After each property that has                  * been written To "propertyStream"' a property list entry is written To                  * "propertyListStream". */using (MemoryStream propertyListStream = new MemoryStream ()) {  		/* Maintain the current position in the list. */int position = 0;  		/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  		/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  		if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  			Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  			if (p1 != null) {  				if (!(p1 is int))  					throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  			}  			else  				/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  			codepage = Codepage;  		}  		/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  		/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  			MutableProperty p = (MutableProperty)preprops [i];  			long id = p.ID;  			/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  			TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  			/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  				/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  			}  			else {  				if (codepage == -1)  					throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  				position += WriteDictionary (propertyStream' dictionary' codepage);  			}  		}  		propertyStream.Flush ();  		propertyListStream.Flush ();  		/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  		byte[] pb2 = propertyStream.ToArray ();  		/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  		/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  		/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  		/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  		int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  		return streamLength;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyListStream = new MemoryStream ()) {  	/* Maintain the current position in the list. */int position = 0;  	/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  	/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  	if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  		Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  		if (p1 != null) {  			if (!(p1 is int))  				throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  		}  		else  			/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  		codepage = Codepage;  	}  	/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  	/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  		MutableProperty p = (MutableProperty)preprops [i];  		long id = p.ID;  		/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  		TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  		/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  			/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  		}  		else {  			if (codepage == -1)  				throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  			position += WriteDictionary (propertyStream' dictionary' codepage);  		}  	}  	propertyStream.Flush ();  	propertyListStream.Flush ();  	/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  	byte[] pb2 = propertyStream.ToArray ();  	/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  	/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  	/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  	/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  	int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  	return streamLength;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyListStream = new MemoryStream ()) {  	/* Maintain the current position in the list. */int position = 0;  	/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  	/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  	if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  		Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  		if (p1 != null) {  			if (!(p1 is int))  				throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  		}  		else  			/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  		codepage = Codepage;  	}  	/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  	/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  		MutableProperty p = (MutableProperty)preprops [i];  		long id = p.ID;  		/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  		TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  		/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  			/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  		}  		else {  			if (codepage == -1)  				throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  			position += WriteDictionary (propertyStream' dictionary' codepage);  		}  	}  	propertyStream.Flush ();  	propertyListStream.Flush ();  	/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  	byte[] pb2 = propertyStream.ToArray ();  	/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  	/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  	/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  	/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  	int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  	return streamLength;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyListStream = new MemoryStream ()) {  	/* Maintain the current position in the list. */int position = 0;  	/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  	/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  	if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  		Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  		if (p1 != null) {  			if (!(p1 is int))  				throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  		}  		else  			/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  		codepage = Codepage;  	}  	/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  	/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  		MutableProperty p = (MutableProperty)preprops [i];  		long id = p.ID;  		/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  		TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  		/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  			/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  		}  		else {  			if (codepage == -1)  				throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  			position += WriteDictionary (propertyStream' dictionary' codepage);  		}  	}  	propertyStream.Flush ();  	propertyListStream.Flush ();  	/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  	byte[] pb2 = propertyStream.ToArray ();  	/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  	/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  	/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  	/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  	int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  	return streamLength;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: using (MemoryStream propertyListStream = new MemoryStream ()) {  	/* Maintain the current position in the list. */int position = 0;  	/* Increase the position variable by the size of the property list so                      * that it points behind the property list and To the beginning of the                      * properties themselves. */position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  	/* Writing the section's dictionary it tricky. If there is a dictionary                      * (property 0) the codepage property (property 1) must be Set' Too. */int codepage = -1;  	if (GetProperty (PropertyIDMap.PID_DICTIONARY) != null) {  		Object p1 = GetProperty (PropertyIDMap.PID_CODEPAGE);  		if (p1 != null) {  			if (!(p1 is int))  				throw new IllegalPropertySetDataException ("The codepage property (ID = 1) must be an " + "Integer object.");  		}  		else  			/* Warning: The codepage property is not Set although a                              * dictionary is present. In order To cope with this problem we                              * Add the codepage property and Set it To Unicode. */SetProperty (PropertyIDMap.PID_CODEPAGE' Variant.VT_I2' (int)Constants.CP_UNICODE);  		codepage = Codepage;  	}  	/* Sort the property list by their property IDs: */preprops.Sort (new PropertyComparer ());  	/* Write the properties and the property list into their respective                      * streams: */for (int i = 0; i < preprops.Count; i++) {  		MutableProperty p = (MutableProperty)preprops [i];  		long id = p.ID;  		/* Write the property list entry. */TypeWriter.WriteUIntToStream (propertyListStream' (uint)p.ID);  		TypeWriter.WriteUIntToStream (propertyListStream' (uint)position);  		/* If the property ID is not equal 0 we Write the property and all                          * is fine. However' if it Equals 0 we have To Write the section's                          * dictionary which has an implicit type only and an explicit                          * value. */if (id != 0) {  			/* Write the property and update the position To the next                              * property. */position += p.Write (propertyStream' Codepage);  		}  		else {  			if (codepage == -1)  				throw new IllegalPropertySetDataException ("Codepage (property 1) is undefined.");  			position += WriteDictionary (propertyStream' dictionary' codepage);  		}  	}  	propertyStream.Flush ();  	propertyListStream.Flush ();  	/* Write the section: */byte[] pb1 = propertyListStream.ToArray ();  	byte[] pb2 = propertyStream.ToArray ();  	/* Write the section's Length: */TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  	/* Write the section's number of properties: */TypeWriter.WriteToStream (out1' PropertyCount);  	/* Write the property list: */out1.Write (pb1' 0' pb1.Length);  	/* Write the properties: */out1.Write (pb2' 0' pb2.Length);  	int streamLength = LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length;  	return streamLength;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: position += 2 * LittleEndianConsts.INT_SIZE + PropertyCount * 2 * LittleEndianConsts.INT_SIZE;  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,Write,The following statement contains a magic number: TypeWriter.WriteToStream (out1' LittleEndianConsts.INT_SIZE * 2 + pb1.Length + pb2.Length);  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (IEnumerator i = dictionary.Keys.GetEnumerator (); i.MoveNext ();) {  	long key = Convert.ToInt64 (i.Current' CultureInfo.InvariantCulture);  	String value = (String)dictionary [key];  	//tony qu added: some key is int32 instead of int64  	if (value == null)  		value = (String)dictionary [(int)key];  	if (codepage == (int)Constants.CP_UNICODE) {  		/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  		if (sLength % 2 == 1)  			sLength++;  		length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  		byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  		 {  			out1.WriteByte (ca [j + 1]);  			out1.WriteByte (ca [j]);  			length += 2;  		}  		sLength -= value.Length;  		while (sLength > 0) {  			out1.WriteByte (0x00);  			out1.WriteByte (0x00);  			length += 2;  			sLength--;  		}  	}  	else {  		/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  		try {  			byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  			for (int j = 0; j < ba.Length; j++) {  				out1.WriteByte (ba [j]);  				length++;  			}  		}  		catch (Exception ex) {  			throw new IllegalPropertySetDataException (ex);  		}  		out1.WriteByte (0x00);  		length++;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (IEnumerator i = dictionary.Keys.GetEnumerator (); i.MoveNext ();) {  	long key = Convert.ToInt64 (i.Current' CultureInfo.InvariantCulture);  	String value = (String)dictionary [key];  	//tony qu added: some key is int32 instead of int64  	if (value == null)  		value = (String)dictionary [(int)key];  	if (codepage == (int)Constants.CP_UNICODE) {  		/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  		if (sLength % 2 == 1)  			sLength++;  		length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  		byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  		 {  			out1.WriteByte (ca [j + 1]);  			out1.WriteByte (ca [j]);  			length += 2;  		}  		sLength -= value.Length;  		while (sLength > 0) {  			out1.WriteByte (0x00);  			out1.WriteByte (0x00);  			length += 2;  			sLength--;  		}  	}  	else {  		/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  		try {  			byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  			for (int j = 0; j < ba.Length; j++) {  				out1.WriteByte (ba [j]);  				length++;  			}  		}  		catch (Exception ex) {  			throw new IllegalPropertySetDataException (ex);  		}  		out1.WriteByte (0x00);  		length++;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (IEnumerator i = dictionary.Keys.GetEnumerator (); i.MoveNext ();) {  	long key = Convert.ToInt64 (i.Current' CultureInfo.InvariantCulture);  	String value = (String)dictionary [key];  	//tony qu added: some key is int32 instead of int64  	if (value == null)  		value = (String)dictionary [(int)key];  	if (codepage == (int)Constants.CP_UNICODE) {  		/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  		if (sLength % 2 == 1)  			sLength++;  		length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  		byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  		 {  			out1.WriteByte (ca [j + 1]);  			out1.WriteByte (ca [j]);  			length += 2;  		}  		sLength -= value.Length;  		while (sLength > 0) {  			out1.WriteByte (0x00);  			out1.WriteByte (0x00);  			length += 2;  			sLength--;  		}  	}  	else {  		/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  		try {  			byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  			for (int j = 0; j < ba.Length; j++) {  				out1.WriteByte (ba [j]);  				length++;  			}  		}  		catch (Exception ex) {  			throw new IllegalPropertySetDataException (ex);  		}  		out1.WriteByte (0x00);  		length++;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (IEnumerator i = dictionary.Keys.GetEnumerator (); i.MoveNext ();) {  	long key = Convert.ToInt64 (i.Current' CultureInfo.InvariantCulture);  	String value = (String)dictionary [key];  	//tony qu added: some key is int32 instead of int64  	if (value == null)  		value = (String)dictionary [(int)key];  	if (codepage == (int)Constants.CP_UNICODE) {  		/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  		if (sLength % 2 == 1)  			sLength++;  		length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  		byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  		 {  			out1.WriteByte (ca [j + 1]);  			out1.WriteByte (ca [j]);  			length += 2;  		}  		sLength -= value.Length;  		while (sLength > 0) {  			out1.WriteByte (0x00);  			out1.WriteByte (0x00);  			length += 2;  			sLength--;  		}  	}  	else {  		/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  		length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  		try {  			byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  			for (int j = 0; j < ba.Length; j++) {  				out1.WriteByte (ba [j]);  				length++;  			}  		}  		catch (Exception ex) {  			throw new IllegalPropertySetDataException (ex);  		}  		out1.WriteByte (0x00);  		length++;  	}  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: if (codepage == (int)Constants.CP_UNICODE) {  	/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  	if (sLength % 2 == 1)  		sLength++;  	length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  	byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  	for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  	 {  		out1.WriteByte (ca [j + 1]);  		out1.WriteByte (ca [j]);  		length += 2;  	}  	sLength -= value.Length;  	while (sLength > 0) {  		out1.WriteByte (0x00);  		out1.WriteByte (0x00);  		length += 2;  		sLength--;  	}  }  else {  	/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  	try {  		byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ba.Length; j++) {  			out1.WriteByte (ba [j]);  			length++;  		}  	}  	catch (Exception ex) {  		throw new IllegalPropertySetDataException (ex);  	}  	out1.WriteByte (0x00);  	length++;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: if (codepage == (int)Constants.CP_UNICODE) {  	/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  	if (sLength % 2 == 1)  		sLength++;  	length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  	byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  	for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  	 {  		out1.WriteByte (ca [j + 1]);  		out1.WriteByte (ca [j]);  		length += 2;  	}  	sLength -= value.Length;  	while (sLength > 0) {  		out1.WriteByte (0x00);  		out1.WriteByte (0x00);  		length += 2;  		sLength--;  	}  }  else {  	/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  	try {  		byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ba.Length; j++) {  			out1.WriteByte (ba [j]);  			length++;  		}  	}  	catch (Exception ex) {  		throw new IllegalPropertySetDataException (ex);  	}  	out1.WriteByte (0x00);  	length++;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: if (codepage == (int)Constants.CP_UNICODE) {  	/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  	if (sLength % 2 == 1)  		sLength++;  	length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  	byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  	for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  	 {  		out1.WriteByte (ca [j + 1]);  		out1.WriteByte (ca [j]);  		length += 2;  	}  	sLength -= value.Length;  	while (sLength > 0) {  		out1.WriteByte (0x00);  		out1.WriteByte (0x00);  		length += 2;  		sLength--;  	}  }  else {  	/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  	try {  		byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ba.Length; j++) {  			out1.WriteByte (ba [j]);  			length++;  		}  	}  	catch (Exception ex) {  		throw new IllegalPropertySetDataException (ex);  	}  	out1.WriteByte (0x00);  	length++;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: if (codepage == (int)Constants.CP_UNICODE) {  	/* Write the dictionary item in Unicode. */int sLength = value.Length + 1;  	if (sLength % 2 == 1)  		sLength++;  	length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)sLength);  	byte[] ca = Encoding.GetEncoding (codepage).GetBytes (value);  	for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug  	 {  		out1.WriteByte (ca [j + 1]);  		out1.WriteByte (ca [j]);  		length += 2;  	}  	sLength -= value.Length;  	while (sLength > 0) {  		out1.WriteByte (0x00);  		out1.WriteByte (0x00);  		length += 2;  		sLength--;  	}  }  else {  	/* Write the dictionary item in another codepage than                      * Unicode. */length += TypeWriter.WriteUIntToStream (out1' (uint)key);  	length += TypeWriter.WriteUIntToStream (out1' (uint)value.Length + 1);  	try {  		byte[] ba = Encoding.GetEncoding (codepage).GetBytes (value);  		for (int j = 0; j < ba.Length; j++) {  			out1.WriteByte (ba [j]);  			length++;  		}  	}  	catch (Exception ex) {  		throw new IllegalPropertySetDataException (ex);  	}  	out1.WriteByte (0x00);  	length++;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: if (sLength % 2 == 1)  	sLength++;  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug   {  	out1.WriteByte (ca [j + 1]);  	out1.WriteByte (ca [j]);  	length += 2;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: for (int j = 0; j < ca.Length; j += 2)//Tony qu fixed the bug   {  	out1.WriteByte (ca [j + 1]);  	out1.WriteByte (ca [j]);  	length += 2;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: j += 2
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: length += 2;  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: while (sLength > 0) {  	out1.WriteByte (0x00);  	out1.WriteByte (0x00);  	length += 2;  	sLength--;  }  
Magic Number,NPOI.HPSF,MutableSection,C:\repos\xoposhiy_npoi\trunk\main\HPSF\MutableSection.cs,WriteDictionary,The following statement contains a magic number: length += 2;  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: try {  	for (int i = 0; i < nrEntries; i++) {  		/* The key. */long id = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* Read the string. */StringBuilder b = new StringBuilder ();  		switch (codepage) {  		case -1: {  			/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  			break;  		}  		case (int)Constants.CP_UNICODE: {  			/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  			byte[] h = new byte[nrBytes];  			for (int i2 = 0; i2 < nrBytes; i2 += 2) {  				h [i2] = src [o + i2 + 1];  				h [i2 + 1] = src [o + i2];  			}  			b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  			break;  		}  		default: {  			/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  			break;  		}  		}  		/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  			b.Length = b.Length - 1;  		if (codepage == (int)Constants.CP_UNICODE) {  			if (sLength % 2 == 1)  				sLength++;  			o += (int)(sLength + sLength);  		}  		else  			o += (int)sLength;  		m [id] = b.ToString ();  	}  }  catch (Exception ex) {  	POILogger l = POILogFactory.GetLogger (typeof(Property));  	l.Log (POILogger.WARN' "The property Set's dictionary Contains bogus data. " + "All dictionary entries starting with the one with ID " + id + " will be ignored."' ex);  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: try {  	for (int i = 0; i < nrEntries; i++) {  		/* The key. */long id = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* Read the string. */StringBuilder b = new StringBuilder ();  		switch (codepage) {  		case -1: {  			/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  			break;  		}  		case (int)Constants.CP_UNICODE: {  			/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  			byte[] h = new byte[nrBytes];  			for (int i2 = 0; i2 < nrBytes; i2 += 2) {  				h [i2] = src [o + i2 + 1];  				h [i2 + 1] = src [o + i2];  			}  			b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  			break;  		}  		default: {  			/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  			break;  		}  		}  		/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  			b.Length = b.Length - 1;  		if (codepage == (int)Constants.CP_UNICODE) {  			if (sLength % 2 == 1)  				sLength++;  			o += (int)(sLength + sLength);  		}  		else  			o += (int)sLength;  		m [id] = b.ToString ();  	}  }  catch (Exception ex) {  	POILogger l = POILogFactory.GetLogger (typeof(Property));  	l.Log (POILogger.WARN' "The property Set's dictionary Contains bogus data. " + "All dictionary entries starting with the one with ID " + id + " will be ignored."' ex);  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: try {  	for (int i = 0; i < nrEntries; i++) {  		/* The key. */long id = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  		o += LittleEndianConsts.INT_SIZE;  		/* Read the string. */StringBuilder b = new StringBuilder ();  		switch (codepage) {  		case -1: {  			/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  			break;  		}  		case (int)Constants.CP_UNICODE: {  			/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  			byte[] h = new byte[nrBytes];  			for (int i2 = 0; i2 < nrBytes; i2 += 2) {  				h [i2] = src [o + i2 + 1];  				h [i2 + 1] = src [o + i2];  			}  			b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  			break;  		}  		default: {  			/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  			break;  		}  		}  		/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  			b.Length = b.Length - 1;  		if (codepage == (int)Constants.CP_UNICODE) {  			if (sLength % 2 == 1)  				sLength++;  			o += (int)(sLength + sLength);  		}  		else  			o += (int)sLength;  		m [id] = b.ToString ();  	}  }  catch (Exception ex) {  	POILogger l = POILogFactory.GetLogger (typeof(Property));  	l.Log (POILogger.WARN' "The property Set's dictionary Contains bogus data. " + "All dictionary entries starting with the one with ID " + id + " will be ignored."' ex);  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: for (int i = 0; i < nrEntries; i++) {  	/* The key. */long id = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* Read the string. */StringBuilder b = new StringBuilder ();  	switch (codepage) {  	case -1: {  		/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  		break;  	}  	case (int)Constants.CP_UNICODE: {  		/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  		byte[] h = new byte[nrBytes];  		for (int i2 = 0; i2 < nrBytes; i2 += 2) {  			h [i2] = src [o + i2 + 1];  			h [i2 + 1] = src [o + i2];  		}  		b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  		break;  	}  	default: {  		/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  		break;  	}  	}  	/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  		b.Length = b.Length - 1;  	if (codepage == (int)Constants.CP_UNICODE) {  		if (sLength % 2 == 1)  			sLength++;  		o += (int)(sLength + sLength);  	}  	else  		o += (int)sLength;  	m [id] = b.ToString ();  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: for (int i = 0; i < nrEntries; i++) {  	/* The key. */long id = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* Read the string. */StringBuilder b = new StringBuilder ();  	switch (codepage) {  	case -1: {  		/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  		break;  	}  	case (int)Constants.CP_UNICODE: {  		/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  		byte[] h = new byte[nrBytes];  		for (int i2 = 0; i2 < nrBytes; i2 += 2) {  			h [i2] = src [o + i2 + 1];  			h [i2 + 1] = src [o + i2];  		}  		b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  		break;  	}  	default: {  		/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  		break;  	}  	}  	/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  		b.Length = b.Length - 1;  	if (codepage == (int)Constants.CP_UNICODE) {  		if (sLength % 2 == 1)  			sLength++;  		o += (int)(sLength + sLength);  	}  	else  		o += (int)sLength;  	m [id] = b.ToString ();  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: for (int i = 0; i < nrEntries; i++) {  	/* The key. */long id = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* The value (a string). The Length is the either the                      * number of (two-byte) characters if the character Set is Unicode                      * or the number of bytes if the character Set is not Unicode.                      * The Length includes terminating 0x00 bytes which we have To strip                      * off To Create a Java string. */long sLength = LittleEndian.GetUInt (src' o);  	o += LittleEndianConsts.INT_SIZE;  	/* Read the string. */StringBuilder b = new StringBuilder ();  	switch (codepage) {  	case -1: {  		/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  		break;  	}  	case (int)Constants.CP_UNICODE: {  		/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  		byte[] h = new byte[nrBytes];  		for (int i2 = 0; i2 < nrBytes; i2 += 2) {  			h [i2] = src [o + i2 + 1];  			h [i2 + 1] = src [o + i2];  		}  		b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  		break;  	}  	default: {  		/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  		break;  	}  	}  	/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  		b.Length = b.Length - 1;  	if (codepage == (int)Constants.CP_UNICODE) {  		if (sLength % 2 == 1)  			sLength++;  		o += (int)(sLength + sLength);  	}  	else  		o += (int)sLength;  	m [id] = b.ToString ();  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: switch (codepage) {  case -1: {  	/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  	break;  }  case (int)Constants.CP_UNICODE: {  	/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  	byte[] h = new byte[nrBytes];  	for (int i2 = 0; i2 < nrBytes; i2 += 2) {  		h [i2] = src [o + i2 + 1];  		h [i2 + 1] = src [o + i2];  	}  	b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  	break;  }  default: {  	/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  	break;  }  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: switch (codepage) {  case -1: {  	/* Without a codepage the Length is equal To the number of                                  * bytes. */b.Append (Encoding.UTF8.GetString (src' o' (int)sLength));  	break;  }  case (int)Constants.CP_UNICODE: {  	/* The Length is the number of characters' i.e. the number                                  * of bytes is twice the number of the characters. */int nrBytes = (int)(sLength * 2);  	byte[] h = new byte[nrBytes];  	for (int i2 = 0; i2 < nrBytes; i2 += 2) {  		h [i2] = src [o + i2 + 1];  		h [i2 + 1] = src [o + i2];  	}  	b.Append (Encoding.GetEncoding (codepage).GetString (h' 0' nrBytes));  	break;  }  default: {  	/* For encodings other than Unicode the Length is the number                                  * of bytes. */b.Append (Encoding.GetEncoding (codepage).GetString (src' o' (int)sLength));  	break;  }  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: for (int i2 = 0; i2 < nrBytes; i2 += 2) {  	h [i2] = src [o + i2 + 1];  	h [i2 + 1] = src [o + i2];  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: i2 += 2
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: if (codepage == (int)Constants.CP_UNICODE) {  	if (sLength % 2 == 1)  		sLength++;  	o += (int)(sLength + sLength);  }  else  	o += (int)sLength;  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ReadDictionary,The following statement contains a magic number: if (sLength % 2 == 1)  	sLength++;  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (value is String) {  	String s = (String)value;  	int l = s.Length;  	if (l > 0) {  		byte[] bytes = new byte[l * 2];  		for (int i = 0; i < l; i++) {  			char c = s [i];  			byte high = (byte)((c & 0x00ff00) >> 8);  			byte low = (byte)((c & 0x0000ff) >> 0);  			bytes [i * 2] = high;  			bytes [i * 2 + 1] = low;  		}  		String hex = HexDump.Dump (bytes' 0L' 0);  		b.Append (" [");  		b.Append (hex);  		b.Append ("]");  	}  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (value is String) {  	String s = (String)value;  	int l = s.Length;  	if (l > 0) {  		byte[] bytes = new byte[l * 2];  		for (int i = 0; i < l; i++) {  			char c = s [i];  			byte high = (byte)((c & 0x00ff00) >> 8);  			byte low = (byte)((c & 0x0000ff) >> 0);  			bytes [i * 2] = high;  			bytes [i * 2 + 1] = low;  		}  		String hex = HexDump.Dump (bytes' 0L' 0);  		b.Append (" [");  		b.Append (hex);  		b.Append ("]");  	}  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (value is String) {  	String s = (String)value;  	int l = s.Length;  	if (l > 0) {  		byte[] bytes = new byte[l * 2];  		for (int i = 0; i < l; i++) {  			char c = s [i];  			byte high = (byte)((c & 0x00ff00) >> 8);  			byte low = (byte)((c & 0x0000ff) >> 0);  			bytes [i * 2] = high;  			bytes [i * 2 + 1] = low;  		}  		String hex = HexDump.Dump (bytes' 0L' 0);  		b.Append (" [");  		b.Append (hex);  		b.Append ("]");  	}  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (value is String) {  	String s = (String)value;  	int l = s.Length;  	if (l > 0) {  		byte[] bytes = new byte[l * 2];  		for (int i = 0; i < l; i++) {  			char c = s [i];  			byte high = (byte)((c & 0x00ff00) >> 8);  			byte low = (byte)((c & 0x0000ff) >> 0);  			bytes [i * 2] = high;  			bytes [i * 2 + 1] = low;  		}  		String hex = HexDump.Dump (bytes' 0L' 0);  		b.Append (" [");  		b.Append (hex);  		b.Append ("]");  	}  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (l > 0) {  	byte[] bytes = new byte[l * 2];  	for (int i = 0; i < l; i++) {  		char c = s [i];  		byte high = (byte)((c & 0x00ff00) >> 8);  		byte low = (byte)((c & 0x0000ff) >> 0);  		bytes [i * 2] = high;  		bytes [i * 2 + 1] = low;  	}  	String hex = HexDump.Dump (bytes' 0L' 0);  	b.Append (" [");  	b.Append (hex);  	b.Append ("]");  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (l > 0) {  	byte[] bytes = new byte[l * 2];  	for (int i = 0; i < l; i++) {  		char c = s [i];  		byte high = (byte)((c & 0x00ff00) >> 8);  		byte low = (byte)((c & 0x0000ff) >> 0);  		bytes [i * 2] = high;  		bytes [i * 2 + 1] = low;  	}  	String hex = HexDump.Dump (bytes' 0L' 0);  	b.Append (" [");  	b.Append (hex);  	b.Append ("]");  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (l > 0) {  	byte[] bytes = new byte[l * 2];  	for (int i = 0; i < l; i++) {  		char c = s [i];  		byte high = (byte)((c & 0x00ff00) >> 8);  		byte low = (byte)((c & 0x0000ff) >> 0);  		bytes [i * 2] = high;  		bytes [i * 2 + 1] = low;  	}  	String hex = HexDump.Dump (bytes' 0L' 0);  	b.Append (" [");  	b.Append (hex);  	b.Append ("]");  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: if (l > 0) {  	byte[] bytes = new byte[l * 2];  	for (int i = 0; i < l; i++) {  		char c = s [i];  		byte high = (byte)((c & 0x00ff00) >> 8);  		byte low = (byte)((c & 0x0000ff) >> 0);  		bytes [i * 2] = high;  		bytes [i * 2 + 1] = low;  	}  	String hex = HexDump.Dump (bytes' 0L' 0);  	b.Append (" [");  	b.Append (hex);  	b.Append ("]");  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: for (int i = 0; i < l; i++) {  	char c = s [i];  	byte high = (byte)((c & 0x00ff00) >> 8);  	byte low = (byte)((c & 0x0000ff) >> 0);  	bytes [i * 2] = high;  	bytes [i * 2 + 1] = low;  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: for (int i = 0; i < l; i++) {  	char c = s [i];  	byte high = (byte)((c & 0x00ff00) >> 8);  	byte low = (byte)((c & 0x0000ff) >> 0);  	bytes [i * 2] = high;  	bytes [i * 2 + 1] = low;  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: for (int i = 0; i < l; i++) {  	char c = s [i];  	byte high = (byte)((c & 0x00ff00) >> 8);  	byte low = (byte)((c & 0x0000ff) >> 0);  	bytes [i * 2] = high;  	bytes [i * 2 + 1] = low;  }  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: bytes [i * 2] = high;  
Magic Number,NPOI.HPSF,Property,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Property.cs,ToString,The following statement contains a magic number: bytes [i * 2 + 1] = low;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [2] = "VT_I2";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [3] = "VT_I4";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [4] = "VT_R4";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [5] = "VT_R8";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [6] = "VT_CY";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [7] = "VT_DATE";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [8] = "VT_BSTR";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [9] = "VT_DISPATCH";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [10] = "VT_ERROR";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [11] = "VT_BOOL";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [12] = "VT_VARIANT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [13] = "VT_UNKNOWN";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [14] = "VT_DECIMAL";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [16] = "VT_I1";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [17] = "VT_UI1";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [18] = "VT_UI2";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [19] = "VT_UI4";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [20] = "VT_I8";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [21] = "VT_UI8";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [22] = "VT_INT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [23] = "VT_UINT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [24] = "VT_VOID";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [25] = "VT_HRESULT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [26] = "VT_PTR";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [27] = "VT_SAFEARRAY";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [28] = "VT_CARRAY";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [29] = "VT_USERDEFINED";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [30] = "VT_LPSTR";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [31] = "VT_LPWSTR";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [64] = "VT_FILETIME";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [65] = "VT_BLOB";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [66] = "VT_STREAM";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [67] = "VT_STORAGE";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [68] = "VT_STREAMED_OBJECT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [69] = "VT_STORED_OBJECT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [70] = "VT_BLOB_OBJECT";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [71] = "VT_CF";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm1 [72] = "VT_CLSID";  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [2] = Length_2;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [3] = Length_4;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [4] = Length_4;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [5] = Length_8;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [6] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [7] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [8] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [9] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [10] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [11] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [12] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [13] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [14] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [16] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [17] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [18] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [19] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [20] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [21] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [22] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [23] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [24] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [25] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [26] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [27] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [28] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [29] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [30] = Length_VARIABLE;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [31] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [64] = Length_8;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [65] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [66] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [67] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [68] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [69] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [70] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [71] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,Variant,The following statement contains a magic number: tm2 [72] = Length_UNKNOWN;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,GetVariantLength,The following statement contains a magic number: if (numberToLength.Contains (key))  	return -2;  
Magic Number,NPOI.HPSF,Variant,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Variant.cs,GetVariantLength,The following statement contains a magic number: return -2;  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The following statement contains a magic number: switch ((int)lType) {  case Variant.VT_EMPTY: {  	value = null;  	break;  }  case Variant.VT_I2: {  	/*                          * Read a short. In Java it is represented as an                          * Integer object.                          */value = LittleEndian.GetShort (src' o1);  	break;  }  case Variant.VT_I4: {  	/*                          * Read a word. In Java it is represented as an                          * Integer object.                          */value = LittleEndian.GetInt (src' o1);  	break;  }  case Variant.VT_I8: {  	/*                          * Read a double word. In Java it is represented as a                          * long object.                          */value = LittleEndian.GetLong (src' o1);  	break;  }  case Variant.VT_R8: {  	/*                          * Read an eight-byte double value. In Java it is represented as                          * a Double object.                          */value = LittleEndian.GetDouble (src' o1);  	break;  }  case Variant.VT_FILETIME: {  	/*                          * Read a FILETIME object. In Java it is represented                          * as a Date object.                          */int low = LittleEndian.GetInt (src' o1);  	o1 += LittleEndianConsts.INT_SIZE;  	int high = LittleEndian.GetInt (src' o1);  	if (low == 0 && high == 0)  		value = null;  	else  		value = Util.FiletimeToDate (high' low);  	break;  }  case Variant.VT_LPSTR: {  	/*                          * Read a byte string. In Java it is represented as a                          * String object. The 0x00 bytes at the end must be                          * stripped.                          */int first = o1 + LittleEndianConsts.INT_SIZE;  	long last = first + LittleEndian.GetUInt (src' o1) - 1;  	o1 += LittleEndianConsts.INT_SIZE;  	while (src [(int)last] == 0 && first <= last)  		last--;  	int l = (int)(last - first + 1);  	value = codepage != -1 ? Encoding.GetEncoding (codepage).GetString (src' first' l) : Encoding.UTF8.GetString (src' first' l);  	break;  }  case Variant.VT_LPWSTR: {  	/*                          * Read a Unicode string. In Java it is represented as                          * a String object. The 0x00 bytes at the end must be                          * stripped.                          */int first = o1 + LittleEndianConsts.INT_SIZE;  	long last = first + LittleEndian.GetUInt (src' o1) - 1;  	long l = last - first;  	o1 += LittleEndianConsts.INT_SIZE;  	StringBuilder b = new StringBuilder ((int)(last - first));  	for (int i = 0; i <= l; i++) {  		int i1 = o1 + (i * 2);  		int i2 = i1 + 1;  		int high = src [i2] << 8;  		int low = src [i1] & 0x00ff;  		char c = (char)(high | low);  		b.Append (c);  	}  	/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  		b.Length = b.Length - 1;  	value = b.ToString ();  	break;  }  case Variant.VT_CF: {  	if (l1 < 0) {  		/**                              *  YK: reading the ClipboardData packet (VT_CF) is not quite correct.                              *  The size of the data is determined by the first four bytes of the packet                              *  while the current implementation calculates it in the Section constructor.                              *  Test files in Bugzilla 42726 and 45583 clearly show that this approach does not always work.                              *  The workaround below attempts to gracefully handle such cases instead of throwing exceptions.                              *                              *  August 20' 2009                              */l1 = LittleEndian.GetInt (src' o1);  		o1 += LittleEndian.INT_SIZE;  	}  	byte[] v = new byte[l1];  	for (int i = 0; i < l1; i++)  		v [i] = src [(o1 + i)];  	value = v;  	break;  }  case Variant.VT_BOOL: {  	/*                          * The first four bytes in src' from src[offset] To                          * src[offset + 3] contain the DWord for VT_BOOL' so                          * skip it' we don't need it.                          */// int first = offset + LittleEndianConstants.INT_SIZE;  	long boolean = LittleEndian.GetUInt (src' o1);  	if (boolean != 0)  		value = true;  	else  		value = false;  	break;  }  default: {  	byte[] v = new byte[l1];  	for (int i = 0; i < l1; i++)  		v [i] = src [(o1 + i)];  	throw new ReadingNotSupportedException (type' v);  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The following statement contains a magic number: switch ((int)lType) {  case Variant.VT_EMPTY: {  	value = null;  	break;  }  case Variant.VT_I2: {  	/*                          * Read a short. In Java it is represented as an                          * Integer object.                          */value = LittleEndian.GetShort (src' o1);  	break;  }  case Variant.VT_I4: {  	/*                          * Read a word. In Java it is represented as an                          * Integer object.                          */value = LittleEndian.GetInt (src' o1);  	break;  }  case Variant.VT_I8: {  	/*                          * Read a double word. In Java it is represented as a                          * long object.                          */value = LittleEndian.GetLong (src' o1);  	break;  }  case Variant.VT_R8: {  	/*                          * Read an eight-byte double value. In Java it is represented as                          * a Double object.                          */value = LittleEndian.GetDouble (src' o1);  	break;  }  case Variant.VT_FILETIME: {  	/*                          * Read a FILETIME object. In Java it is represented                          * as a Date object.                          */int low = LittleEndian.GetInt (src' o1);  	o1 += LittleEndianConsts.INT_SIZE;  	int high = LittleEndian.GetInt (src' o1);  	if (low == 0 && high == 0)  		value = null;  	else  		value = Util.FiletimeToDate (high' low);  	break;  }  case Variant.VT_LPSTR: {  	/*                          * Read a byte string. In Java it is represented as a                          * String object. The 0x00 bytes at the end must be                          * stripped.                          */int first = o1 + LittleEndianConsts.INT_SIZE;  	long last = first + LittleEndian.GetUInt (src' o1) - 1;  	o1 += LittleEndianConsts.INT_SIZE;  	while (src [(int)last] == 0 && first <= last)  		last--;  	int l = (int)(last - first + 1);  	value = codepage != -1 ? Encoding.GetEncoding (codepage).GetString (src' first' l) : Encoding.UTF8.GetString (src' first' l);  	break;  }  case Variant.VT_LPWSTR: {  	/*                          * Read a Unicode string. In Java it is represented as                          * a String object. The 0x00 bytes at the end must be                          * stripped.                          */int first = o1 + LittleEndianConsts.INT_SIZE;  	long last = first + LittleEndian.GetUInt (src' o1) - 1;  	long l = last - first;  	o1 += LittleEndianConsts.INT_SIZE;  	StringBuilder b = new StringBuilder ((int)(last - first));  	for (int i = 0; i <= l; i++) {  		int i1 = o1 + (i * 2);  		int i2 = i1 + 1;  		int high = src [i2] << 8;  		int low = src [i1] & 0x00ff;  		char c = (char)(high | low);  		b.Append (c);  	}  	/* Strip 0x00 characters from the end of the string: */while (b.Length > 0 && b [b.Length - 1] == 0x00)  		b.Length = b.Length - 1;  	value = b.ToString ();  	break;  }  case Variant.VT_CF: {  	if (l1 < 0) {  		/**                              *  YK: reading the ClipboardData packet (VT_CF) is not quite correct.                              *  The size of the data is determined by the first four bytes of the packet                              *  while the current implementation calculates it in the Section constructor.                              *  Test files in Bugzilla 42726 and 45583 clearly show that this approach does not always work.                              *  The workaround below attempts to gracefully handle such cases instead of throwing exceptions.                              *                              *  August 20' 2009                              */l1 = LittleEndian.GetInt (src' o1);  		o1 += LittleEndian.INT_SIZE;  	}  	byte[] v = new byte[l1];  	for (int i = 0; i < l1; i++)  		v [i] = src [(o1 + i)];  	value = v;  	break;  }  case Variant.VT_BOOL: {  	/*                          * The first four bytes in src' from src[offset] To                          * src[offset + 3] contain the DWord for VT_BOOL' so                          * skip it' we don't need it.                          */// int first = offset + LittleEndianConstants.INT_SIZE;  	long boolean = LittleEndian.GetUInt (src' o1);  	if (boolean != 0)  		value = true;  	else  		value = false;  	break;  }  default: {  	byte[] v = new byte[l1];  	for (int i = 0; i < l1; i++)  		v [i] = src [(o1 + i)];  	throw new ReadingNotSupportedException (type' v);  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The following statement contains a magic number: for (int i = 0; i <= l; i++) {  	int i1 = o1 + (i * 2);  	int i2 = i1 + 1;  	int high = src [i2] << 8;  	int low = src [i1] & 0x00ff;  	char c = (char)(high | low);  	b.Append (c);  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Read,The following statement contains a magic number: for (int i = 0; i <= l; i++) {  	int i1 = o1 + (i * 2);  	int i2 = i1 + 1;  	int high = src [i2] << 8;  	int low = src [i1] & 0x00ff;  	char c = (char)(high | low);  	b.Append (c);  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: switch ((int)type) {  case Variant.VT_BOOL: {  	int trueOrFalse;  	if ((bool)value)  		trueOrFalse = 1;  	else  		trueOrFalse = 0;  	length = TypeWriter.WriteUIntToStream (out1' (uint)trueOrFalse);  	break;  }  case Variant.VT_LPSTR: {  	if (codepage == 0)  		throw new ArgumentOutOfRangeException ("codepage");  	byte[] bytes = (codepage == -1 ? Encoding.UTF8.GetBytes ((string)value) : Encoding.GetEncoding (codepage).GetBytes ((string)value));  	length = TypeWriter.WriteUIntToStream (out1' (uint)bytes.Length + 1);  	byte[] b = new byte[bytes.Length + 1];  	Array.Copy (bytes' 0' b' 0' bytes.Length);  	b [b.Length - 1] = 0x00;  	out1.Write (b' 0' b.Length);  	length += b.Length;  	break;  }  case Variant.VT_LPWSTR: {  	int nrOfChars = ((String)value).Length + 1;  	length += TypeWriter.WriteUIntToStream (out1' (uint)nrOfChars);  	char[] s = Util.Pad4 ((String)value);  	for (int i = 0; i < s.Length; i++) {  		int high = ((s [i] & 0x0000ff00) >> 8);  		int low = (s [i] & 0x000000ff);  		byte highb = (byte)high;  		byte lowb = (byte)low;  		out1.WriteByte (lowb);  		out1.WriteByte (highb);  		length += 2;  	}  	out1.WriteByte (0x00);  	out1.WriteByte (0x00);  	length += 2;  	break;  }  case Variant.VT_CF: {  	byte[] b = (byte[])value;  	out1.Write (b' 0' b.Length);  	length = b.Length;  	break;  }  case Variant.VT_EMPTY: {  	TypeWriter.WriteUIntToStream (out1' Variant.VT_EMPTY);  	length = LittleEndianConsts.INT_SIZE;  	break;  }  case Variant.VT_I2: {  	short x;  	try {  		x = Convert.ToInt16 (value' CultureInfo.InvariantCulture);  	}  	catch (OverflowException) {  		x = (short)((int)value);  	}  	TypeWriter.WriteToStream (out1' x);  	length = LittleEndianConsts.SHORT_SIZE;  	break;  }  case Variant.VT_I4: {  	if (!(value is int)) {  		throw new Exception ("Could not cast an object To " + "int" + ": " + value.GetType ().Name + "' " + value.ToString ());  	}  	length += TypeWriter.WriteToStream (out1' (int)value);  	break;  }  case Variant.VT_I8: {  	TypeWriter.WriteToStream (out1' Convert.ToInt64 (value' CultureInfo.CurrentCulture));  	length = LittleEndianConsts.LONG_SIZE;  	break;  }  case Variant.VT_R8: {  	length += TypeWriter.WriteToStream (out1' (Double)value);  	break;  }  case Variant.VT_FILETIME: {  	long filetime;  	if (value != null) {  		filetime = Util.DateToFileTime ((DateTime)value);  	}  	else {  		filetime = 0;  	}  	int high = (int)((filetime >> 32) & 0x00000000FFFFFFFFL);  	int low = (int)(filetime & 0x00000000FFFFFFFFL);  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & low));  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & high));  	break;  }  default: {  	/* The variant type is not supported yet. However' if the value                          * is a byte array we can Write it nevertheless. */if (value is byte[]) {  		byte[] b = (byte[])value;  		out1.Write (b' 0' b.Length);  		length = b.Length;  		WriteUnsupportedTypeMessage (new WritingNotSupportedException (type' value));  	}  	else  		throw new WritingNotSupportedException (type' value);  	break;  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: switch ((int)type) {  case Variant.VT_BOOL: {  	int trueOrFalse;  	if ((bool)value)  		trueOrFalse = 1;  	else  		trueOrFalse = 0;  	length = TypeWriter.WriteUIntToStream (out1' (uint)trueOrFalse);  	break;  }  case Variant.VT_LPSTR: {  	if (codepage == 0)  		throw new ArgumentOutOfRangeException ("codepage");  	byte[] bytes = (codepage == -1 ? Encoding.UTF8.GetBytes ((string)value) : Encoding.GetEncoding (codepage).GetBytes ((string)value));  	length = TypeWriter.WriteUIntToStream (out1' (uint)bytes.Length + 1);  	byte[] b = new byte[bytes.Length + 1];  	Array.Copy (bytes' 0' b' 0' bytes.Length);  	b [b.Length - 1] = 0x00;  	out1.Write (b' 0' b.Length);  	length += b.Length;  	break;  }  case Variant.VT_LPWSTR: {  	int nrOfChars = ((String)value).Length + 1;  	length += TypeWriter.WriteUIntToStream (out1' (uint)nrOfChars);  	char[] s = Util.Pad4 ((String)value);  	for (int i = 0; i < s.Length; i++) {  		int high = ((s [i] & 0x0000ff00) >> 8);  		int low = (s [i] & 0x000000ff);  		byte highb = (byte)high;  		byte lowb = (byte)low;  		out1.WriteByte (lowb);  		out1.WriteByte (highb);  		length += 2;  	}  	out1.WriteByte (0x00);  	out1.WriteByte (0x00);  	length += 2;  	break;  }  case Variant.VT_CF: {  	byte[] b = (byte[])value;  	out1.Write (b' 0' b.Length);  	length = b.Length;  	break;  }  case Variant.VT_EMPTY: {  	TypeWriter.WriteUIntToStream (out1' Variant.VT_EMPTY);  	length = LittleEndianConsts.INT_SIZE;  	break;  }  case Variant.VT_I2: {  	short x;  	try {  		x = Convert.ToInt16 (value' CultureInfo.InvariantCulture);  	}  	catch (OverflowException) {  		x = (short)((int)value);  	}  	TypeWriter.WriteToStream (out1' x);  	length = LittleEndianConsts.SHORT_SIZE;  	break;  }  case Variant.VT_I4: {  	if (!(value is int)) {  		throw new Exception ("Could not cast an object To " + "int" + ": " + value.GetType ().Name + "' " + value.ToString ());  	}  	length += TypeWriter.WriteToStream (out1' (int)value);  	break;  }  case Variant.VT_I8: {  	TypeWriter.WriteToStream (out1' Convert.ToInt64 (value' CultureInfo.CurrentCulture));  	length = LittleEndianConsts.LONG_SIZE;  	break;  }  case Variant.VT_R8: {  	length += TypeWriter.WriteToStream (out1' (Double)value);  	break;  }  case Variant.VT_FILETIME: {  	long filetime;  	if (value != null) {  		filetime = Util.DateToFileTime ((DateTime)value);  	}  	else {  		filetime = 0;  	}  	int high = (int)((filetime >> 32) & 0x00000000FFFFFFFFL);  	int low = (int)(filetime & 0x00000000FFFFFFFFL);  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & low));  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & high));  	break;  }  default: {  	/* The variant type is not supported yet. However' if the value                          * is a byte array we can Write it nevertheless. */if (value is byte[]) {  		byte[] b = (byte[])value;  		out1.Write (b' 0' b.Length);  		length = b.Length;  		WriteUnsupportedTypeMessage (new WritingNotSupportedException (type' value));  	}  	else  		throw new WritingNotSupportedException (type' value);  	break;  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: switch ((int)type) {  case Variant.VT_BOOL: {  	int trueOrFalse;  	if ((bool)value)  		trueOrFalse = 1;  	else  		trueOrFalse = 0;  	length = TypeWriter.WriteUIntToStream (out1' (uint)trueOrFalse);  	break;  }  case Variant.VT_LPSTR: {  	if (codepage == 0)  		throw new ArgumentOutOfRangeException ("codepage");  	byte[] bytes = (codepage == -1 ? Encoding.UTF8.GetBytes ((string)value) : Encoding.GetEncoding (codepage).GetBytes ((string)value));  	length = TypeWriter.WriteUIntToStream (out1' (uint)bytes.Length + 1);  	byte[] b = new byte[bytes.Length + 1];  	Array.Copy (bytes' 0' b' 0' bytes.Length);  	b [b.Length - 1] = 0x00;  	out1.Write (b' 0' b.Length);  	length += b.Length;  	break;  }  case Variant.VT_LPWSTR: {  	int nrOfChars = ((String)value).Length + 1;  	length += TypeWriter.WriteUIntToStream (out1' (uint)nrOfChars);  	char[] s = Util.Pad4 ((String)value);  	for (int i = 0; i < s.Length; i++) {  		int high = ((s [i] & 0x0000ff00) >> 8);  		int low = (s [i] & 0x000000ff);  		byte highb = (byte)high;  		byte lowb = (byte)low;  		out1.WriteByte (lowb);  		out1.WriteByte (highb);  		length += 2;  	}  	out1.WriteByte (0x00);  	out1.WriteByte (0x00);  	length += 2;  	break;  }  case Variant.VT_CF: {  	byte[] b = (byte[])value;  	out1.Write (b' 0' b.Length);  	length = b.Length;  	break;  }  case Variant.VT_EMPTY: {  	TypeWriter.WriteUIntToStream (out1' Variant.VT_EMPTY);  	length = LittleEndianConsts.INT_SIZE;  	break;  }  case Variant.VT_I2: {  	short x;  	try {  		x = Convert.ToInt16 (value' CultureInfo.InvariantCulture);  	}  	catch (OverflowException) {  		x = (short)((int)value);  	}  	TypeWriter.WriteToStream (out1' x);  	length = LittleEndianConsts.SHORT_SIZE;  	break;  }  case Variant.VT_I4: {  	if (!(value is int)) {  		throw new Exception ("Could not cast an object To " + "int" + ": " + value.GetType ().Name + "' " + value.ToString ());  	}  	length += TypeWriter.WriteToStream (out1' (int)value);  	break;  }  case Variant.VT_I8: {  	TypeWriter.WriteToStream (out1' Convert.ToInt64 (value' CultureInfo.CurrentCulture));  	length = LittleEndianConsts.LONG_SIZE;  	break;  }  case Variant.VT_R8: {  	length += TypeWriter.WriteToStream (out1' (Double)value);  	break;  }  case Variant.VT_FILETIME: {  	long filetime;  	if (value != null) {  		filetime = Util.DateToFileTime ((DateTime)value);  	}  	else {  		filetime = 0;  	}  	int high = (int)((filetime >> 32) & 0x00000000FFFFFFFFL);  	int low = (int)(filetime & 0x00000000FFFFFFFFL);  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & low));  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & high));  	break;  }  default: {  	/* The variant type is not supported yet. However' if the value                          * is a byte array we can Write it nevertheless. */if (value is byte[]) {  		byte[] b = (byte[])value;  		out1.Write (b' 0' b.Length);  		length = b.Length;  		WriteUnsupportedTypeMessage (new WritingNotSupportedException (type' value));  	}  	else  		throw new WritingNotSupportedException (type' value);  	break;  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: switch ((int)type) {  case Variant.VT_BOOL: {  	int trueOrFalse;  	if ((bool)value)  		trueOrFalse = 1;  	else  		trueOrFalse = 0;  	length = TypeWriter.WriteUIntToStream (out1' (uint)trueOrFalse);  	break;  }  case Variant.VT_LPSTR: {  	if (codepage == 0)  		throw new ArgumentOutOfRangeException ("codepage");  	byte[] bytes = (codepage == -1 ? Encoding.UTF8.GetBytes ((string)value) : Encoding.GetEncoding (codepage).GetBytes ((string)value));  	length = TypeWriter.WriteUIntToStream (out1' (uint)bytes.Length + 1);  	byte[] b = new byte[bytes.Length + 1];  	Array.Copy (bytes' 0' b' 0' bytes.Length);  	b [b.Length - 1] = 0x00;  	out1.Write (b' 0' b.Length);  	length += b.Length;  	break;  }  case Variant.VT_LPWSTR: {  	int nrOfChars = ((String)value).Length + 1;  	length += TypeWriter.WriteUIntToStream (out1' (uint)nrOfChars);  	char[] s = Util.Pad4 ((String)value);  	for (int i = 0; i < s.Length; i++) {  		int high = ((s [i] & 0x0000ff00) >> 8);  		int low = (s [i] & 0x000000ff);  		byte highb = (byte)high;  		byte lowb = (byte)low;  		out1.WriteByte (lowb);  		out1.WriteByte (highb);  		length += 2;  	}  	out1.WriteByte (0x00);  	out1.WriteByte (0x00);  	length += 2;  	break;  }  case Variant.VT_CF: {  	byte[] b = (byte[])value;  	out1.Write (b' 0' b.Length);  	length = b.Length;  	break;  }  case Variant.VT_EMPTY: {  	TypeWriter.WriteUIntToStream (out1' Variant.VT_EMPTY);  	length = LittleEndianConsts.INT_SIZE;  	break;  }  case Variant.VT_I2: {  	short x;  	try {  		x = Convert.ToInt16 (value' CultureInfo.InvariantCulture);  	}  	catch (OverflowException) {  		x = (short)((int)value);  	}  	TypeWriter.WriteToStream (out1' x);  	length = LittleEndianConsts.SHORT_SIZE;  	break;  }  case Variant.VT_I4: {  	if (!(value is int)) {  		throw new Exception ("Could not cast an object To " + "int" + ": " + value.GetType ().Name + "' " + value.ToString ());  	}  	length += TypeWriter.WriteToStream (out1' (int)value);  	break;  }  case Variant.VT_I8: {  	TypeWriter.WriteToStream (out1' Convert.ToInt64 (value' CultureInfo.CurrentCulture));  	length = LittleEndianConsts.LONG_SIZE;  	break;  }  case Variant.VT_R8: {  	length += TypeWriter.WriteToStream (out1' (Double)value);  	break;  }  case Variant.VT_FILETIME: {  	long filetime;  	if (value != null) {  		filetime = Util.DateToFileTime ((DateTime)value);  	}  	else {  		filetime = 0;  	}  	int high = (int)((filetime >> 32) & 0x00000000FFFFFFFFL);  	int low = (int)(filetime & 0x00000000FFFFFFFFL);  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & low));  	length += TypeWriter.WriteUIntToStream (out1' (uint)(0x0000000FFFFFFFFL & high));  	break;  }  default: {  	/* The variant type is not supported yet. However' if the value                          * is a byte array we can Write it nevertheless. */if (value is byte[]) {  		byte[] b = (byte[])value;  		out1.Write (b' 0' b.Length);  		length = b.Length;  		WriteUnsupportedTypeMessage (new WritingNotSupportedException (type' value));  	}  	else  		throw new WritingNotSupportedException (type' value);  	break;  }  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	int high = ((s [i] & 0x0000ff00) >> 8);  	int low = (s [i] & 0x000000ff);  	byte highb = (byte)high;  	byte lowb = (byte)low;  	out1.WriteByte (lowb);  	out1.WriteByte (highb);  	length += 2;  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	int high = ((s [i] & 0x0000ff00) >> 8);  	int low = (s [i] & 0x000000ff);  	byte highb = (byte)high;  	byte lowb = (byte)low;  	out1.WriteByte (lowb);  	out1.WriteByte (highb);  	length += 2;  }  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: length += 2;  
Magic Number,NPOI.HPSF,VariantSupport,C:\repos\xoposhiy_npoi\trunk\main\HPSF\VariantSupport.cs,Write,The following statement contains a magic number: length += 2;  
Magic Number,NPOI.HPSF.Extractor,HPSFPropertiesExtractor,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Extractor\HPSFPropertiesExtractor.cs,GetPropertyValueText,The following statement contains a magic number: if (val is byte[]) {  	byte[] b = (byte[])val;  	if (b.Length == 0) {  		return "";  	}  	if (b.Length == 1) {  		return b [0].ToString (CultureInfo.InvariantCulture);  	}  	if (b.Length == 2) {  		return LittleEndian.GetUShort (b).ToString (CultureInfo.InvariantCulture);  	}  	if (b.Length == 4) {  		return LittleEndian.GetUInt (b).ToString (CultureInfo.InvariantCulture);  	}  	// Maybe it's a string? who knows!  	return b.ToString ();  }  
Magic Number,NPOI.HPSF.Extractor,HPSFPropertiesExtractor,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Extractor\HPSFPropertiesExtractor.cs,GetPropertyValueText,The following statement contains a magic number: if (val is byte[]) {  	byte[] b = (byte[])val;  	if (b.Length == 0) {  		return "";  	}  	if (b.Length == 1) {  		return b [0].ToString (CultureInfo.InvariantCulture);  	}  	if (b.Length == 2) {  		return LittleEndian.GetUShort (b).ToString (CultureInfo.InvariantCulture);  	}  	if (b.Length == 4) {  		return LittleEndian.GetUInt (b).ToString (CultureInfo.InvariantCulture);  	}  	// Maybe it's a string? who knows!  	return b.ToString ();  }  
Magic Number,NPOI.HPSF.Extractor,HPSFPropertiesExtractor,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Extractor\HPSFPropertiesExtractor.cs,GetPropertyValueText,The following statement contains a magic number: if (b.Length == 2) {  	return LittleEndian.GetUShort (b).ToString (CultureInfo.InvariantCulture);  }  
Magic Number,NPOI.HPSF.Extractor,HPSFPropertiesExtractor,C:\repos\xoposhiy_npoi\trunk\main\HPSF\Extractor\HPSFPropertiesExtractor.cs,GetPropertyValueText,The following statement contains a magic number: if (b.Length == 4) {  	return LittleEndian.GetUInt (b).ToString (CultureInfo.InvariantCulture);  }  
Magic Number,NPOI.HSSF.EventUserModel,HSSFRequest,C:\repos\xoposhiy_npoi\trunk\main\HSSF\EventUserModel\HSSFRequest.cs,HSSFRequest,The following statement contains a magic number: records = new Hashtable (50);  
Magic Number,NPOI.HSSF.Model,AbstractShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\AbstractShape.cs,AddStandardOptions,The following statement contains a magic number: if (shape.LineStyle != LineStyle.Solid) {  	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.LINESTYLE__LINEDASHING' (int)shape.LineStyle));  	opt.AddEscherProperty (new EscherSimpleProperty (EscherProperties.LINESTYLE__LINEENDCAPSTYLE' 0));  	if (shape.LineStyle == LineStyle.None)  		opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.LINESTYLE__NOLINEDRAWDASH' 0x00080000));  	else  		opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.LINESTYLE__NOLINEDRAWDASH' 0x00080008));  	options += 3;  }  
Magic Number,NPOI.HSSF.Model,AbstractShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\AbstractShape.cs,AddStandardOptions,The following statement contains a magic number: options += 3;  
Magic Number,NPOI.HSSF.Model,AbstractShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\AbstractShape.cs,GetCmoObjectId,The following statement contains a magic number: return shapeId - 1024;  
Magic Number,NPOI.HSSF.Model,ComboboxShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ComboboxShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = ((short)((EscherAggregate.ST_HOSTCONTROL << 4) | 0x2));  
Magic Number,NPOI.HSSF.Model,ComboboxShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ComboboxShape.cs,CreateSpContainer,The following statement contains a magic number: opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.PROTECTION__LOCKAGAINSTGROUPING' 17039620));  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,CreateDgRecord,The following statement contains a magic number: dg.Options = ((short)(dgId << 4));  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: if (lastShapeId % 1024 == 1023) {  	// Yes:  	// Find the starting shape id of the next free cluster  	newShapeId = FindFreeSPIDBlock ();  	// Create a new cluster in the dgg record.  	dgg.AddCluster (drawingGroupId' 1);  }  else {  	// No:  	// Find the cluster for this drawing Group with free space.  	for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  		EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  		if (c.DrawingGroupId == drawingGroupId) {  			if (c.NumShapeIdsUsed != 1024) {  				// Increment the number of shapes used for this cluster.  				c.IncrementShapeId ();  			}  		}  		// If the last shape id = -1 then we know to Find a free block;  		if (dg.LastMSOSPID == -1) {  			newShapeId = FindFreeSPIDBlock ();  		}  		else {  			// The new shape id to be the last shapeid of this cluster + 1  			newShapeId = dg.LastMSOSPID + 1;  		}  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: if (lastShapeId % 1024 == 1023) {  	// Yes:  	// Find the starting shape id of the next free cluster  	newShapeId = FindFreeSPIDBlock ();  	// Create a new cluster in the dgg record.  	dgg.AddCluster (drawingGroupId' 1);  }  else {  	// No:  	// Find the cluster for this drawing Group with free space.  	for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  		EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  		if (c.DrawingGroupId == drawingGroupId) {  			if (c.NumShapeIdsUsed != 1024) {  				// Increment the number of shapes used for this cluster.  				c.IncrementShapeId ();  			}  		}  		// If the last shape id = -1 then we know to Find a free block;  		if (dg.LastMSOSPID == -1) {  			newShapeId = FindFreeSPIDBlock ();  		}  		else {  			// The new shape id to be the last shapeid of this cluster + 1  			newShapeId = dg.LastMSOSPID + 1;  		}  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: if (lastShapeId % 1024 == 1023) {  	// Yes:  	// Find the starting shape id of the next free cluster  	newShapeId = FindFreeSPIDBlock ();  	// Create a new cluster in the dgg record.  	dgg.AddCluster (drawingGroupId' 1);  }  else {  	// No:  	// Find the cluster for this drawing Group with free space.  	for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  		EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  		if (c.DrawingGroupId == drawingGroupId) {  			if (c.NumShapeIdsUsed != 1024) {  				// Increment the number of shapes used for this cluster.  				c.IncrementShapeId ();  			}  		}  		// If the last shape id = -1 then we know to Find a free block;  		if (dg.LastMSOSPID == -1) {  			newShapeId = FindFreeSPIDBlock ();  		}  		else {  			// The new shape id to be the last shapeid of this cluster + 1  			newShapeId = dg.LastMSOSPID + 1;  		}  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  	EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  	if (c.DrawingGroupId == drawingGroupId) {  		if (c.NumShapeIdsUsed != 1024) {  			// Increment the number of shapes used for this cluster.  			c.IncrementShapeId ();  		}  	}  	// If the last shape id = -1 then we know to Find a free block;  	if (dg.LastMSOSPID == -1) {  		newShapeId = FindFreeSPIDBlock ();  	}  	else {  		// The new shape id to be the last shapeid of this cluster + 1  		newShapeId = dg.LastMSOSPID + 1;  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: if (c.DrawingGroupId == drawingGroupId) {  	if (c.NumShapeIdsUsed != 1024) {  		// Increment the number of shapes used for this cluster.  		c.IncrementShapeId ();  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager.cs,AllocateShapeId,The following statement contains a magic number: if (c.NumShapeIdsUsed != 1024) {  	// Increment the number of shapes used for this cluster.  	c.IncrementShapeId ();  }  
Magic Number,NPOI.HSSF.Model,DrawingManager2,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager2.cs,CreateDgRecord,The following statement contains a magic number: dg.Options = (short)(dgId << 4);  
Magic Number,NPOI.HSSF.Model,DrawingManager2,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager2.cs,AllocateShapeId,The following statement contains a magic number: for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  	EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  	if (c.DrawingGroupId == drawingGroupId && c.NumShapeIdsUsed != 1024) {  		int result = c.NumShapeIdsUsed + (1024 * (i + 1));  		c.IncrementShapeId ();  		dg.NumShapes = (dg.NumShapes + 1);  		dg.LastMSOSPID = (result);  		if (result >= dgg.ShapeIdMax)  			dgg.ShapeIdMax = (result + 1);  		return result;  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager2,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager2.cs,AllocateShapeId,The following statement contains a magic number: for (int i = 0; i < dgg.FileIdClusters.Length; i++) {  	EscherDggRecord.FileIdCluster c = dgg.FileIdClusters [i];  	if (c.DrawingGroupId == drawingGroupId && c.NumShapeIdsUsed != 1024) {  		int result = c.NumShapeIdsUsed + (1024 * (i + 1));  		c.IncrementShapeId ();  		dg.NumShapes = (dg.NumShapes + 1);  		dg.LastMSOSPID = (result);  		if (result >= dgg.ShapeIdMax)  			dgg.ShapeIdMax = (result + 1);  		return result;  	}  }  
Magic Number,NPOI.HSSF.Model,DrawingManager2,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager2.cs,AllocateShapeId,The following statement contains a magic number: if (c.DrawingGroupId == drawingGroupId && c.NumShapeIdsUsed != 1024) {  	int result = c.NumShapeIdsUsed + (1024 * (i + 1));  	c.IncrementShapeId ();  	dg.NumShapes = (dg.NumShapes + 1);  	dg.LastMSOSPID = (result);  	if (result >= dgg.ShapeIdMax)  		dgg.ShapeIdMax = (result + 1);  	return result;  }  
Magic Number,NPOI.HSSF.Model,DrawingManager2,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\DrawingManager2.cs,AllocateShapeId,The following statement contains a magic number: if (c.DrawingGroupId == drawingGroupId && c.NumShapeIdsUsed != 1024) {  	int result = c.NumShapeIdsUsed + (1024 * (i + 1));  	c.IncrementShapeId ();  	dg.NumShapes = (dg.NumShapes + 1);  	dg.LastMSOSPID = (result);  	if (result >= dgg.ShapeIdMax)  		dgg.ShapeIdMax = (result + 1);  	return result;  }  
Magic Number,NPOI.HSSF.Model,LineShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LineShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = (short)((EscherAggregate.ST_LINE << 4) | 0x2);  
Magic Number,NPOI.HSSF.Model,LineShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LineShape.cs,CreateSpContainer,The following statement contains a magic number: opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.LINESTYLE__NOLINEDRAWDASH' 1048592));  
Magic Number,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,LinkTable,The following statement contains a magic number: _recordCount = 2;  
Magic Number,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,AddNameXPtg,The following statement contains a magic number: if (extBlock == null) {  	extBlock = new ExternalBookBlock ();  	ExternalBookBlock[] tmp = new ExternalBookBlock[_externalBookBlocks.Length + 1];  	Array.Copy (_externalBookBlocks' 0' tmp' 0' _externalBookBlocks.Length);  	tmp [tmp.Length - 1] = extBlock;  	_externalBookBlocks = tmp;  	extBlockIndex = _externalBookBlocks.Length - 1;  	// add the created SupBookRecord before ExternSheetRecord  	int idx = FindFirstRecordLocBySid (ExternSheetRecord.sid);  	_workbookRecordList.Add (idx' extBlock.GetExternalBookRecord ());  	// register the SupBookRecord in the ExternSheetRecord  	// -2 means that the scope of this name is Workbook and the reference applies to the entire workbook.  	_externSheetRecord.AddRef (_externalBookBlocks.Length - 1' -2' -2);  }  
Magic Number,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,AddNameXPtg,The following statement contains a magic number: if (extBlock == null) {  	extBlock = new ExternalBookBlock ();  	ExternalBookBlock[] tmp = new ExternalBookBlock[_externalBookBlocks.Length + 1];  	Array.Copy (_externalBookBlocks' 0' tmp' 0' _externalBookBlocks.Length);  	tmp [tmp.Length - 1] = extBlock;  	_externalBookBlocks = tmp;  	extBlockIndex = _externalBookBlocks.Length - 1;  	// add the created SupBookRecord before ExternSheetRecord  	int idx = FindFirstRecordLocBySid (ExternSheetRecord.sid);  	_workbookRecordList.Add (idx' extBlock.GetExternalBookRecord ());  	// register the SupBookRecord in the ExternSheetRecord  	// -2 means that the scope of this name is Workbook and the reference applies to the entire workbook.  	_externSheetRecord.AddRef (_externalBookBlocks.Length - 1' -2' -2);  }  
Magic Number,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,AddNameXPtg,The following statement contains a magic number: _externSheetRecord.AddRef (_externalBookBlocks.Length - 1' -2' -2);  
Magic Number,NPOI.HSSF.Model,LinkTable,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\LinkTable.cs,AddNameXPtg,The following statement contains a magic number: _externSheetRecord.AddRef (_externalBookBlocks.Length - 1' -2' -2);  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (Children.Length > 2) {  	// false param present  	// false parameter  	Children [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.SumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.HSSF.Model,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: Children [2].CollectPtgs (temp);  
Magic Number,NPOI.HSSF.Model,PictureShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PictureShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = (short)((EscherAggregate.ST_PICTUREFRAME << 4) | 0x2);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = (short)((EscherAggregate.ST_DONUT << 4) | 0x2);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	byte[] data = new byte[4];  	LittleEndian.PutShort (data' 0' (short)hssfShape.XPoints [i]);  	LittleEndian.PutShort (data' 2' (short)hssfShape.YPoints [i]);  	verticesProp.SetElement (i' data);  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	byte[] data = new byte[4];  	LittleEndian.PutShort (data' 0' (short)hssfShape.XPoints [i]);  	LittleEndian.PutShort (data' 2' (short)hssfShape.YPoints [i]);  	verticesProp.SetElement (i' data);  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: LittleEndian.PutShort (data' 2' (short)hssfShape.YPoints [i]);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: LittleEndian.PutShort (data1' 2' (short)hssfShape.YPoints [0]);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.NumberOfElementsInArray = (hssfShape.XPoints.Length * 2 + 4);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.NumberOfElementsInArray = (hssfShape.XPoints.Length * 2 + 4);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.NumberOfElementsInMemory = (hssfShape.XPoints.Length * 2 + 4);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.NumberOfElementsInMemory = (hssfShape.XPoints.Length * 2 + 4);  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	segmentsProp.SetElement (2 + i * 2' new byte[] {  		(byte)0x01'  		(byte)0x00  	});  	segmentsProp.SetElement (3 + i * 2' new byte[] {  		(byte)0x00'  		(byte)0xAC  	});  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	segmentsProp.SetElement (2 + i * 2' new byte[] {  		(byte)0x01'  		(byte)0x00  	});  	segmentsProp.SetElement (3 + i * 2' new byte[] {  		(byte)0x00'  		(byte)0xAC  	});  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	segmentsProp.SetElement (2 + i * 2' new byte[] {  		(byte)0x01'  		(byte)0x00  	});  	segmentsProp.SetElement (3 + i * 2' new byte[] {  		(byte)0x00'  		(byte)0xAC  	});  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: for (int i = 0; i < hssfShape.XPoints.Length; i++) {  	segmentsProp.SetElement (2 + i * 2' new byte[] {  		(byte)0x01'  		(byte)0x00  	});  	segmentsProp.SetElement (3 + i * 2' new byte[] {  		(byte)0x00'  		(byte)0xAC  	});  }  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.SetElement (2 + i * 2' new byte[] {  	(byte)0x01'  	(byte)0x00  });  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.SetElement (2 + i * 2' new byte[] {  	(byte)0x01'  	(byte)0x00  });  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.SetElement (3 + i * 2' new byte[] {  	(byte)0x00'  	(byte)0xAC  });  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.SetElement (3 + i * 2' new byte[] {  	(byte)0x00'  	(byte)0xAC  });  
Magic Number,NPOI.HSSF.Model,PolygonShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\PolygonShape.cs,CreateSpContainer,The following statement contains a magic number: segmentsProp.SetElement (segmentsProp.NumberOfElementsInArray - 2' new byte[] {  	(byte)0x01'  	(byte)0x60  });  
Magic Number,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindInsertPosForNewCondFormatTable,The following statement contains a magic number: for (int i = records.Count - 2; i >= 0; i--) {  	// -2 to skip EOF record  	Object rb = records [i];  	if (rb is MergedCellsTable) {  		return i + 1;  	}  	if (rb is DataValidityTable) {  		continue;  	}  	Record rec = (Record)rb;  	switch (rec.Sid) {  	case WindowTwoRecord.sid:  	case SCLRecord.sid:  	case PaneRecord.sid:  	case SelectionRecord.sid:  	case UnknownRecord.STANDARDWIDTH_0099:  	// MergedCellsTable usually here   	case UnknownRecord.LABELRANGES_015F:  	case UnknownRecord.PHONETICPR_00EF:  		// ConditionalFormattingTable goes here  		return i + 1;  	// HyperlinkTable (not aggregated by POI yet)  	// DataValidityTable  	}  }  
Magic Number,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindInsertPosForNewMergedRecordTable,The following statement contains a magic number: for (int i = records.Count - 2; i >= 0; i--) {  	// -2 to skip EOF record  	Object rb = records [i];  	if (!(rb is Record)) {  		// DataValidityTable' ConditionalFormattingTable'   		// even PageSettingsBlock (which doesn't normally appear after 'View Settings')  		continue;  	}  	Record rec = (Record)rb;  	switch (rec.Sid) {  	// 'View Settings' (4 records)   	case WindowTwoRecord.sid:  	case SCLRecord.sid:  	case PaneRecord.sid:  	case SelectionRecord.sid:  	case UnknownRecord.STANDARDWIDTH_0099:  		return i + 1;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,InternalSheet,The following statement contains a magic number: records = new List<RecordBase> (128);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,InternalSheet,The following statement contains a magic number: records = new List<RecordBase> (32);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreateBOF,The following statement contains a magic number: retval.BuildYear = ((short)1996);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.Scale = ((short)100);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.Options = ((short)2);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.HResolution = ((short)300);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.VResolution = ((short)300);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.HeaderMargin = (0.5);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreatePrintSetup,The following statement contains a magic number: retval.FooterMargin = (0.5);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GetColumnWidth,The following statement contains a magic number: return (256 * defaultcolwidth.ColWidth);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,SetColumnWidth,The following statement contains a magic number: if (width > 255 * 256)  	throw new ArgumentException ("The maximum column width for an individual cell is 255 characters.");  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,SetColumnWidth,The following statement contains a magic number: if (width > 255 * 256)  	throw new ArgumentException ("The maximum column width for an individual cell is 255 characters.");  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupColumnRange,The following statement contains a magic number: if (maxLevel == 0)  	guts.TopColGutter = ((short)0);  else  	guts.TopColGutter = ((short)(29 + (12 * (maxLevel - 1))));  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupColumnRange,The following statement contains a magic number: if (maxLevel == 0)  	guts.TopColGutter = ((short)0);  else  	guts.TopColGutter = ((short)(29 + (12 * (maxLevel - 1))));  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupColumnRange,The following statement contains a magic number: guts.TopColGutter = ((short)(29 + (12 * (maxLevel - 1))));  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupColumnRange,The following statement contains a magic number: guts.TopColGutter = ((short)(29 + (12 * (maxLevel - 1))));  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreateFreezePane,The following statement contains a magic number: if (rowSplit == 0) {  	pane.TopRow = ((short)0);  	pane.ActivePane = ((short)1);  }  else if (colSplit == 0) {  	pane.LeftColumn = ((short)0);  	pane.ActivePane = ((short)2);  }  else {  	pane.ActivePane = ((short)0);  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreateFreezePane,The following statement contains a magic number: if (colSplit == 0) {  	pane.LeftColumn = ((short)0);  	pane.ActivePane = ((short)2);  }  else {  	pane.ActivePane = ((short)0);  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,CreateFreezePane,The following statement contains a magic number: pane.ActivePane = ((short)2);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,AggregateDrawingRecords,The following statement contains a magic number: if (noDrawingRecordsFound) {  	if (!CreateIfMissing) {  		// None found' and not allowed to Add in  		return -1;  	}  	EscherAggregate aggregate = new EscherAggregate (drawingManager);  	loc = FindFirstRecordLocBySid (EscherAggregate.sid);  	if (loc == -1) {  		loc = FindFirstRecordLocBySid (WindowTwoRecord.sid);  	}  	else {  		Records.RemoveAt (loc);  	}  	Records.Insert (loc' aggregate);  	return loc;  }  else {  	IList records = Records;  	EscherAggregate r = EscherAggregate.CreateAggregate (records' loc' drawingManager);  	int startloc = loc;  	while (loc + 1 < records.Count && records [loc] is DrawingRecord && (records [loc + 1] is ObjRecord || records [loc + 1] is TextObjectRecord)) {  		loc += 2;  		if (records [loc] is NoteRecord)  			loc++;  	}  	int endloc = loc - 1;  	for (int i = 0; i < (endloc - startloc + 1); i++) {  		records.RemoveAt (startloc);  	}  	records.Insert (startloc' r);  	return startloc;  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,AggregateDrawingRecords,The following statement contains a magic number: while (loc + 1 < records.Count && records [loc] is DrawingRecord && (records [loc + 1] is ObjRecord || records [loc + 1] is TextObjectRecord)) {  	loc += 2;  	if (records [loc] is NoteRecord)  		loc++;  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,AggregateDrawingRecords,The following statement contains a magic number: loc += 2;  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupRowRange,The following statement contains a magic number: for (int rowNum = fromRow; rowNum <= toRow; rowNum++) {  	RowRecord row = GetRow (rowNum);  	if (row == null) {  		row = CreateRow (rowNum);  		AddRow (row);  	}  	int level = row.OutlineLevel;  	if (indent)  		level++;  	else  		level--;  	level = Math.Max (0' level);  	level = Math.Min (7' level);  	row.OutlineLevel = ((short)(level));  }  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,GroupRowRange,The following statement contains a magic number: level = Math.Min (7' level);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,RecalcRowGutter,The following statement contains a magic number: guts.LeftRowGutter = (short)(29 + 12 * maxLevel);  
Magic Number,NPOI.HSSF.Model,InternalSheet,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalSheet.cs,RecalcRowGutter,The following statement contains a magic number: guts.LeftRowGutter = (short)(29 + 12 * maxLevel);  
Magic Number,NPOI.HSSF.Model,SimpleFilledShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\SimpleFilledShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = (short)((shapeType << 4) | 0x2);  
Magic Number,NPOI.HSSF.Model,TextboxShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\TextboxShape.cs,CreateSpContainer,The following statement contains a magic number: sp.Options = (short)((EscherAggregate.ST_TEXTBOX << 4) | 0x2);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following statement contains a magic number: retval.numfonts = 4;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following statement contains a magic number: for (int i = 0; i <= 7; i++) {  	Record rec = CreateFormat (i);  	retval.maxformatid = retval.maxformatid >= ((FormatRecord)rec).IndexCode ? retval.maxformatid : ((FormatRecord)rec).IndexCode;  	formats.Add ((FormatRecord)rec);  	records.Add (rec);  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following statement contains a magic number: for (int k = 0; k < 21; k++) {  	records.Add (CreateExtendedFormat (k));  	retval.numxfs++;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following statement contains a magic number: for (int k = 0; k < 6; k++) {  	records.Add (CreateStyle (k));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,GetFontRecordAt,The following statement contains a magic number: if (index > 4) {  	index -= 1;  	// adjust for "There is no 4"  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CloneDrawings,The following statement contains a magic number: if (aggLoc != -1) {  	EscherAggregate agg = (EscherAggregate)sheet.FindFirstRecordBySid (EscherAggregate.sid);  	EscherContainerRecord escherContainer = agg.GetEscherContainer ();  	if (escherContainer == null) {  		return;  	}  	EscherDggRecord dgg = drawingManager.GetDgg ();  	//register a new drawing group for the cloned sheet  	int dgId = drawingManager.FindNewDrawingGroupId ();  	dgg.AddCluster (dgId' 0);  	dgg.DrawingsSaved = dgg.DrawingsSaved + 1;  	EscherDgRecord dg = null;  	for (IEnumerator it = escherContainer.ChildRecords.GetEnumerator (); it.MoveNext ();) {  		Object er = it.Current;  		if (er is EscherDgRecord) {  			dg = (EscherDgRecord)er;  			//update id of the drawing in the cloned sheet  			dg.Options = ((short)(dgId << 4));  		}  		else if (er is EscherContainerRecord) {  			//recursively find shape records and re-generate shapeId  			ArrayList spRecords = new ArrayList ();  			EscherContainerRecord cp = (EscherContainerRecord)er;  			for (IEnumerator spIt = cp.ChildRecords.GetEnumerator (); spIt.MoveNext ();) {  				EscherContainerRecord shapeContainer = (EscherContainerRecord)spIt.Current;  				foreach (EscherRecord shapeChildRecord in shapeContainer.ChildRecords) {  					int recordId = shapeChildRecord.RecordId;  					if (recordId == EscherSpRecord.RECORD_ID) {  						EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;  						int shapeId = drawingManager.AllocateShapeId ((short)dgId' dg);  						//allocateShapeId increments the number of shapes. roll back to the previous value  						dg.NumShapes = (dg.NumShapes - 1);  						sp.ShapeId = (shapeId);  					}  					else if (recordId == EscherOptRecord.RECORD_ID) {  						EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;  						EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  						if (prop != null) {  							int pictureIndex = prop.PropertyValue;  							// increment reference count for pictures  							EscherBSERecord bse = GetBSERecord (pictureIndex);  							bse.Ref = bse.Ref + 1;  						}  					}  				}  			}  		}  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CloneDrawings,The following statement contains a magic number: for (IEnumerator it = escherContainer.ChildRecords.GetEnumerator (); it.MoveNext ();) {  	Object er = it.Current;  	if (er is EscherDgRecord) {  		dg = (EscherDgRecord)er;  		//update id of the drawing in the cloned sheet  		dg.Options = ((short)(dgId << 4));  	}  	else if (er is EscherContainerRecord) {  		//recursively find shape records and re-generate shapeId  		ArrayList spRecords = new ArrayList ();  		EscherContainerRecord cp = (EscherContainerRecord)er;  		for (IEnumerator spIt = cp.ChildRecords.GetEnumerator (); spIt.MoveNext ();) {  			EscherContainerRecord shapeContainer = (EscherContainerRecord)spIt.Current;  			foreach (EscherRecord shapeChildRecord in shapeContainer.ChildRecords) {  				int recordId = shapeChildRecord.RecordId;  				if (recordId == EscherSpRecord.RECORD_ID) {  					EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;  					int shapeId = drawingManager.AllocateShapeId ((short)dgId' dg);  					//allocateShapeId increments the number of shapes. roll back to the previous value  					dg.NumShapes = (dg.NumShapes - 1);  					sp.ShapeId = (shapeId);  				}  				else if (recordId == EscherOptRecord.RECORD_ID) {  					EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;  					EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  					if (prop != null) {  						int pictureIndex = prop.PropertyValue;  						// increment reference count for pictures  						EscherBSERecord bse = GetBSERecord (pictureIndex);  						bse.Ref = bse.Ref + 1;  					}  				}  			}  		}  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CloneDrawings,The following statement contains a magic number: if (er is EscherDgRecord) {  	dg = (EscherDgRecord)er;  	//update id of the drawing in the cloned sheet  	dg.Options = ((short)(dgId << 4));  }  else if (er is EscherContainerRecord) {  	//recursively find shape records and re-generate shapeId  	ArrayList spRecords = new ArrayList ();  	EscherContainerRecord cp = (EscherContainerRecord)er;  	for (IEnumerator spIt = cp.ChildRecords.GetEnumerator (); spIt.MoveNext ();) {  		EscherContainerRecord shapeContainer = (EscherContainerRecord)spIt.Current;  		foreach (EscherRecord shapeChildRecord in shapeContainer.ChildRecords) {  			int recordId = shapeChildRecord.RecordId;  			if (recordId == EscherSpRecord.RECORD_ID) {  				EscherSpRecord sp = (EscherSpRecord)shapeChildRecord;  				int shapeId = drawingManager.AllocateShapeId ((short)dgId' dg);  				//allocateShapeId increments the number of shapes. roll back to the previous value  				dg.NumShapes = (dg.NumShapes - 1);  				sp.ShapeId = (shapeId);  			}  			else if (recordId == EscherOptRecord.RECORD_ID) {  				EscherOptRecord opt = (EscherOptRecord)shapeChildRecord;  				EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  				if (prop != null) {  					int pictureIndex = prop.PropertyValue;  					// increment reference count for pictures  					EscherBSERecord bse = GetBSERecord (pictureIndex);  					bse.Ref = bse.Ref + 1;  				}  			}  		}  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CloneDrawings,The following statement contains a magic number: dg.Options = ((short)(dgId << 4));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetName,The following statement contains a magic number: if (sheetname.Length > 31)  	sheetname = sheetname.Substring (0' 31);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetName,The following statement contains a magic number: if (sheetname.Length > 31)  	sheetname = sheetname.Substring (0' 31);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetName,The following statement contains a magic number: sheetname = sheetname.Substring (0' 31);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetHidden,The following statement contains a magic number: if (hidden == 0) {  }  else if (hidden == 1) {  	h = true;  }  else if (hidden == 2) {  	vh = true;  }  else {  	throw new ArgumentException ("Invalid hidden flag " + hidden + " given' must be 0' 1 or 2");  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetHidden,The following statement contains a magic number: if (hidden == 1) {  	h = true;  }  else if (hidden == 2) {  	vh = true;  }  else {  	throw new ArgumentException ("Invalid hidden flag " + hidden + " given' must be 0' 1 or 2");  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,SetSheetHidden,The following statement contains a magic number: if (hidden == 2) {  	vh = true;  }  else {  	throw new ArgumentException ("Invalid hidden flag " + hidden + " given' must be 0' 1 or 2");  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,GetFontIndex,The following statement contains a magic number: for (int i = 0; i <= numfonts; i++) {  	FontRecord thisFont = (FontRecord)records [(records.Fontpos - (numfonts - 1)) + i];  	if (thisFont == font) {  		// There is no 4!  		if (i > 3) {  			return (i + 1);  		}  		return i;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,GetFontIndex,The following statement contains a magic number: if (thisFont == font) {  	// There is no 4!  	if (i > 3) {  		return (i + 1);  	}  	return i;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,GetFontIndex,The following statement contains a magic number: if (i > 3) {  	return (i + 1);  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,InsertSST,The following statement contains a magic number: records.Add (records.Count - 2' sst);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateBOF,The following statement contains a magic number: retval.Type = (short)5;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateBOF,The following statement contains a magic number: retval.BuildYear = (short)1996;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFnGroupCount,The following statement contains a magic number: retval.Count = (short)14;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: retval.FontIndex = (short)2;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: retval.FontIndex = (short)2;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: retval.FontIndex = (short)5;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: retval.FontIndex = (short)6;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following statement contains a magic number: retval.FontIndex = (short)6;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: retval.SetBuiltinStyle (3);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: retval.SetBuiltinStyle (6);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: retval.SetBuiltinStyle (4);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: retval.SetBuiltinStyle (7);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following statement contains a magic number: retval.SetBuiltinStyle (5);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateCountry,The following statement contains a magic number: if (System.Threading.Thread.CurrentThread.CurrentCulture.Name.Equals ("ru_RU")) {  	retval.CurrentCountry = ((short)7);  }  else {  	retval.CurrentCountry = ((short)1);  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateCountry,The following statement contains a magic number: retval.CurrentCountry = ((short)7);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following statement contains a magic number: return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: if (drawingManager == null) {  	EscherContainerRecord dggContainer = new EscherContainerRecord ();  	EscherDggRecord dgg = new EscherDggRecord ();  	EscherOptRecord opt = new EscherOptRecord ();  	EscherSplitMenuColorsRecord splitMenuColors = new EscherSplitMenuColorsRecord ();  	dggContainer.RecordId = unchecked((short)0xF000);  	dggContainer.Options = (short)0x000F;  	dgg.RecordId = EscherDggRecord.RECORD_ID;  	dgg.Options = (short)0x0000;  	dgg.ShapeIdMax = 1024;  	dgg.NumShapesSaved = 0;  	dgg.DrawingsSaved = 0;  	dgg.FileIdClusters = new EscherDggRecord.FileIdCluster[] {    	};  	drawingManager = new DrawingManager2 (dgg);  	EscherContainerRecord bstoreContainer = null;  	if (escherBSERecords.Count > 0) {  		bstoreContainer = new EscherContainerRecord ();  		bstoreContainer.RecordId = EscherContainerRecord.BSTORE_CONTAINER;  		bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  		for (IEnumerator iterator = escherBSERecords.GetEnumerator (); iterator.MoveNext ();) {  			EscherRecord escherRecord = (EscherRecord)iterator.Current;  			bstoreContainer.AddChildRecord (escherRecord);  		}  	}  	opt.RecordId = unchecked((short)0xF00B);  	opt.Options = (short)0x0033;  	opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE' 524296));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.FILL__FILLCOLOR' 0x08000041));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.LINESTYLE__COLOR' 134217792));  	splitMenuColors.RecordId = unchecked((short)0xF11E);  	splitMenuColors.Options = (short)0x0040;  	splitMenuColors.Color1 = 0x0800000D;  	splitMenuColors.Color2 = 0x0800000C;  	splitMenuColors.Color3 = 0x08000017;  	splitMenuColors.Color4 = 0x100000F7;  	dggContainer.AddChildRecord (dgg);  	if (bstoreContainer != null)  		dggContainer.AddChildRecord (bstoreContainer);  	dggContainer.AddChildRecord (opt);  	dggContainer.AddChildRecord (splitMenuColors);  	int dgLoc = FindFirstRecordLocBySid (DrawingGroupRecord.sid);  	if (dgLoc == -1) {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		int loc = FindFirstRecordLocBySid (CountryRecord.sid);  		Records.Insert (loc + 1' drawingGroup);  	}  	else {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		Records [dgLoc] = drawingGroup;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: if (drawingManager == null) {  	EscherContainerRecord dggContainer = new EscherContainerRecord ();  	EscherDggRecord dgg = new EscherDggRecord ();  	EscherOptRecord opt = new EscherOptRecord ();  	EscherSplitMenuColorsRecord splitMenuColors = new EscherSplitMenuColorsRecord ();  	dggContainer.RecordId = unchecked((short)0xF000);  	dggContainer.Options = (short)0x000F;  	dgg.RecordId = EscherDggRecord.RECORD_ID;  	dgg.Options = (short)0x0000;  	dgg.ShapeIdMax = 1024;  	dgg.NumShapesSaved = 0;  	dgg.DrawingsSaved = 0;  	dgg.FileIdClusters = new EscherDggRecord.FileIdCluster[] {    	};  	drawingManager = new DrawingManager2 (dgg);  	EscherContainerRecord bstoreContainer = null;  	if (escherBSERecords.Count > 0) {  		bstoreContainer = new EscherContainerRecord ();  		bstoreContainer.RecordId = EscherContainerRecord.BSTORE_CONTAINER;  		bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  		for (IEnumerator iterator = escherBSERecords.GetEnumerator (); iterator.MoveNext ();) {  			EscherRecord escherRecord = (EscherRecord)iterator.Current;  			bstoreContainer.AddChildRecord (escherRecord);  		}  	}  	opt.RecordId = unchecked((short)0xF00B);  	opt.Options = (short)0x0033;  	opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE' 524296));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.FILL__FILLCOLOR' 0x08000041));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.LINESTYLE__COLOR' 134217792));  	splitMenuColors.RecordId = unchecked((short)0xF11E);  	splitMenuColors.Options = (short)0x0040;  	splitMenuColors.Color1 = 0x0800000D;  	splitMenuColors.Color2 = 0x0800000C;  	splitMenuColors.Color3 = 0x08000017;  	splitMenuColors.Color4 = 0x100000F7;  	dggContainer.AddChildRecord (dgg);  	if (bstoreContainer != null)  		dggContainer.AddChildRecord (bstoreContainer);  	dggContainer.AddChildRecord (opt);  	dggContainer.AddChildRecord (splitMenuColors);  	int dgLoc = FindFirstRecordLocBySid (DrawingGroupRecord.sid);  	if (dgLoc == -1) {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		int loc = FindFirstRecordLocBySid (CountryRecord.sid);  		Records.Insert (loc + 1' drawingGroup);  	}  	else {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		Records [dgLoc] = drawingGroup;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: if (drawingManager == null) {  	EscherContainerRecord dggContainer = new EscherContainerRecord ();  	EscherDggRecord dgg = new EscherDggRecord ();  	EscherOptRecord opt = new EscherOptRecord ();  	EscherSplitMenuColorsRecord splitMenuColors = new EscherSplitMenuColorsRecord ();  	dggContainer.RecordId = unchecked((short)0xF000);  	dggContainer.Options = (short)0x000F;  	dgg.RecordId = EscherDggRecord.RECORD_ID;  	dgg.Options = (short)0x0000;  	dgg.ShapeIdMax = 1024;  	dgg.NumShapesSaved = 0;  	dgg.DrawingsSaved = 0;  	dgg.FileIdClusters = new EscherDggRecord.FileIdCluster[] {    	};  	drawingManager = new DrawingManager2 (dgg);  	EscherContainerRecord bstoreContainer = null;  	if (escherBSERecords.Count > 0) {  		bstoreContainer = new EscherContainerRecord ();  		bstoreContainer.RecordId = EscherContainerRecord.BSTORE_CONTAINER;  		bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  		for (IEnumerator iterator = escherBSERecords.GetEnumerator (); iterator.MoveNext ();) {  			EscherRecord escherRecord = (EscherRecord)iterator.Current;  			bstoreContainer.AddChildRecord (escherRecord);  		}  	}  	opt.RecordId = unchecked((short)0xF00B);  	opt.Options = (short)0x0033;  	opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE' 524296));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.FILL__FILLCOLOR' 0x08000041));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.LINESTYLE__COLOR' 134217792));  	splitMenuColors.RecordId = unchecked((short)0xF11E);  	splitMenuColors.Options = (short)0x0040;  	splitMenuColors.Color1 = 0x0800000D;  	splitMenuColors.Color2 = 0x0800000C;  	splitMenuColors.Color3 = 0x08000017;  	splitMenuColors.Color4 = 0x100000F7;  	dggContainer.AddChildRecord (dgg);  	if (bstoreContainer != null)  		dggContainer.AddChildRecord (bstoreContainer);  	dggContainer.AddChildRecord (opt);  	dggContainer.AddChildRecord (splitMenuColors);  	int dgLoc = FindFirstRecordLocBySid (DrawingGroupRecord.sid);  	if (dgLoc == -1) {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		int loc = FindFirstRecordLocBySid (CountryRecord.sid);  		Records.Insert (loc + 1' drawingGroup);  	}  	else {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		Records [dgLoc] = drawingGroup;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: if (drawingManager == null) {  	EscherContainerRecord dggContainer = new EscherContainerRecord ();  	EscherDggRecord dgg = new EscherDggRecord ();  	EscherOptRecord opt = new EscherOptRecord ();  	EscherSplitMenuColorsRecord splitMenuColors = new EscherSplitMenuColorsRecord ();  	dggContainer.RecordId = unchecked((short)0xF000);  	dggContainer.Options = (short)0x000F;  	dgg.RecordId = EscherDggRecord.RECORD_ID;  	dgg.Options = (short)0x0000;  	dgg.ShapeIdMax = 1024;  	dgg.NumShapesSaved = 0;  	dgg.DrawingsSaved = 0;  	dgg.FileIdClusters = new EscherDggRecord.FileIdCluster[] {    	};  	drawingManager = new DrawingManager2 (dgg);  	EscherContainerRecord bstoreContainer = null;  	if (escherBSERecords.Count > 0) {  		bstoreContainer = new EscherContainerRecord ();  		bstoreContainer.RecordId = EscherContainerRecord.BSTORE_CONTAINER;  		bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  		for (IEnumerator iterator = escherBSERecords.GetEnumerator (); iterator.MoveNext ();) {  			EscherRecord escherRecord = (EscherRecord)iterator.Current;  			bstoreContainer.AddChildRecord (escherRecord);  		}  	}  	opt.RecordId = unchecked((short)0xF00B);  	opt.Options = (short)0x0033;  	opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE' 524296));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.FILL__FILLCOLOR' 0x08000041));  	opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.LINESTYLE__COLOR' 134217792));  	splitMenuColors.RecordId = unchecked((short)0xF11E);  	splitMenuColors.Options = (short)0x0040;  	splitMenuColors.Color1 = 0x0800000D;  	splitMenuColors.Color2 = 0x0800000C;  	splitMenuColors.Color3 = 0x08000017;  	splitMenuColors.Color4 = 0x100000F7;  	dggContainer.AddChildRecord (dgg);  	if (bstoreContainer != null)  		dggContainer.AddChildRecord (bstoreContainer);  	dggContainer.AddChildRecord (opt);  	dggContainer.AddChildRecord (splitMenuColors);  	int dgLoc = FindFirstRecordLocBySid (DrawingGroupRecord.sid);  	if (dgLoc == -1) {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		int loc = FindFirstRecordLocBySid (CountryRecord.sid);  		Records.Insert (loc + 1' drawingGroup);  	}  	else {  		DrawingGroupRecord drawingGroup = new DrawingGroupRecord ();  		drawingGroup.AddEscherRecord (dggContainer);  		Records [dgLoc] = drawingGroup;  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: dgg.ShapeIdMax = 1024;  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: if (escherBSERecords.Count > 0) {  	bstoreContainer = new EscherContainerRecord ();  	bstoreContainer.RecordId = EscherContainerRecord.BSTORE_CONTAINER;  	bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  	for (IEnumerator iterator = escherBSERecords.GetEnumerator (); iterator.MoveNext ();) {  		EscherRecord escherRecord = (EscherRecord)iterator.Current;  		bstoreContainer.AddChildRecord (escherRecord);  	}  }  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: opt.AddEscherProperty (new EscherBoolProperty (EscherProperties.TEXT__SIZE_TEXT_TO_FIT_SHAPE' 524296));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateDrawingGroup,The following statement contains a magic number: opt.AddEscherProperty (new EscherRGBProperty (EscherProperties.LINESTYLE__COLOR' 134217792));  
Magic Number,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,AddBSERecord,The following statement contains a magic number: bstoreContainer.Options = (short)((escherBSERecords.Count << 4) | 0xF);  
Magic Number,NPOI.HSSF.Record.CF,BorderFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\BorderFormatting.cs,Serialize,The following statement contains a magic number: offset += 4;  
Magic Number,NPOI.HSSF.Record.CF,BorderFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\BorderFormatting.cs,Serialize,The following statement contains a magic number: offset += 4;  
Magic Number,NPOI.HSSF.Record.CF,BorderFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\BorderFormatting.cs,Serialize,The following statement contains a magic number: return 8;  
Magic Number,NPOI.HSSF.Record.CF,PatternFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\PatternFormatting.cs,Serialize,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HSSF.Record.CF,PatternFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\PatternFormatting.cs,Serialize,The following statement contains a magic number: offset += 2;  
Magic Number,NPOI.HSSF.Record.CF,PatternFormatting,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\PatternFormatting.cs,Serialize,The following statement contains a magic number: return 4;  
Magic Number,NPOI.HSSF.Record.Chart,ChartEndBlockRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartEndBlockRecord.cs,ChartEndBlockRecord,The following statement contains a magic number: if (in1.Available () == 0) {  	unused = new byte[0];  }  else {  	unused = new byte[6];  	in1.ReadFully (unused);  }  
Magic Number,NPOI.HSSF.Record.Chart,ChartEndBlockRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartEndBlockRecord.cs,ChartEndBlockRecord,The following statement contains a magic number: unused = new byte[6];  
Magic Number,NPOI.HSSF.Record.Chart,ChartEndObjectRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Chart\ChartEndObjectRecord.cs,ChartEndObjectRecord,The following statement contains a magic number: reserved = new byte[6];  
Magic Number,NPOI.POIFS.Crypt,AgileDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\AgileDecryptor.cs,VerifyPassword,The following statement contains a magic number: if (Arrays.Equals (trimmed' hashedVerifier)) {  	skey = GenerateKey (pwHash' kCryptoKeyBlock);  	iv = GenerateIv (algorithm' verifier.Salt' null);  	cipher = GetCipher (algorithm' mode' skey' iv);  	byte[] inter = Decrypt (cipher' verifier.EncryptedKey);  	byte[] keySpec = new byte[_info.Header.KeySize / 8];  	Array.Copy (inter' 0' keySpec' 0' keySpec.Length);  	_secretKey = keySpec;  	return true;  }  else  	return false;  
Magic Number,NPOI.POIFS.Crypt,ChunkedCipherInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\AgileDecryptor.cs,NextChunk,The following statement contains a magic number: if (_lastIndex != index)  	_stream.Skip ((index - _lastIndex) << 12);  
Magic Number,NPOI.POIFS.Crypt,ChunkedCipherInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\AgileDecryptor.cs,NextChunk,The following statement contains a magic number: _stream.Skip ((index - _lastIndex) << 12);  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (major == 4 && minor == 4)  	return new AgileDecryptor (info);  else if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (major == 4 && minor == 4)  	return new AgileDecryptor (info);  else if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (major == 4 && minor == 4)  	return new AgileDecryptor (info);  else if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (major == 4 && minor == 4)  	return new AgileDecryptor (info);  else if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (major == 4 && minor == 4)  	return new AgileDecryptor (info);  else if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetInstance,The following statement contains a magic number: if (minor == 2 && (major == 3 || major == 4))  	return new EcmaDecryptor (info);  else  	throw new EncryptedDocumentException ("Unsupported version");  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {  case EncryptionHeader.ALGORITHM_AES_128:  	return 16;  case EncryptionHeader.ALGORITHM_AES_192:  	return 24;  case EncryptionHeader.ALGORITHM_AES_256:  	return 32;  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {  case EncryptionHeader.ALGORITHM_AES_128:  	return 16;  case EncryptionHeader.ALGORITHM_AES_192:  	return 24;  case EncryptionHeader.ALGORITHM_AES_256:  	return 32;  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: switch (algorithm) {  case EncryptionHeader.ALGORITHM_AES_128:  	return 16;  case EncryptionHeader.ALGORITHM_AES_192:  	return 24;  case EncryptionHeader.ALGORITHM_AES_256:  	return 32;  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: return 16;  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: return 24;  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following statement contains a magic number: return 32;  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,HashPassword,The following statement contains a magic number: temp = new byte[24];  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (MemoryStream fStream = new MemoryStream (encryptBytes)) {  	using (CryptoStream cStream = new CryptoStream (fStream' cipher.CreateDecryptor (cipher.Key' cipher.IV)' CryptoStreamMode.Read)) {  		using (MemoryStream destMs = new MemoryStream ()) {  			byte[] buffer = new byte[100];  			int readLen;  			while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  				destMs.Write (buffer' 0' readLen);  			decryptBytes = destMs.ToArray ();  		}  	}  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (MemoryStream fStream = new MemoryStream (encryptBytes)) {  	using (CryptoStream cStream = new CryptoStream (fStream' cipher.CreateDecryptor (cipher.Key' cipher.IV)' CryptoStreamMode.Read)) {  		using (MemoryStream destMs = new MemoryStream ()) {  			byte[] buffer = new byte[100];  			int readLen;  			while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  				destMs.Write (buffer' 0' readLen);  			decryptBytes = destMs.ToArray ();  		}  	}  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (CryptoStream cStream = new CryptoStream (fStream' cipher.CreateDecryptor (cipher.Key' cipher.IV)' CryptoStreamMode.Read)) {  	using (MemoryStream destMs = new MemoryStream ()) {  		byte[] buffer = new byte[100];  		int readLen;  		while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  			destMs.Write (buffer' 0' readLen);  		decryptBytes = destMs.ToArray ();  	}  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (CryptoStream cStream = new CryptoStream (fStream' cipher.CreateDecryptor (cipher.Key' cipher.IV)' CryptoStreamMode.Read)) {  	using (MemoryStream destMs = new MemoryStream ()) {  		byte[] buffer = new byte[100];  		int readLen;  		while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  			destMs.Write (buffer' 0' readLen);  		decryptBytes = destMs.ToArray ();  	}  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (MemoryStream destMs = new MemoryStream ()) {  	byte[] buffer = new byte[100];  	int readLen;  	while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  		destMs.Write (buffer' 0' readLen);  	decryptBytes = destMs.ToArray ();  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: using (MemoryStream destMs = new MemoryStream ()) {  	byte[] buffer = new byte[100];  	int readLen;  	while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  		destMs.Write (buffer' 0' readLen);  	decryptBytes = destMs.ToArray ();  }  
Magic Number,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,Decrypt,The following statement contains a magic number: while ((readLen = cStream.Read (buffer' 0' 100)) > 0)  	destMs.Write (buffer' 0' readLen);  
Magic Number,NPOI.POIFS.Crypt,EcmaDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EcmaDecryptor.cs,GenerateKey,The following statement contains a magic number: try {  	HashAlgorithm sha1 = HashAlgorithm.Create ("SHA1");  	//sha1.update(passwordHash);  	byte[] blockValue = new byte[4];  	LittleEndian.PutInt (blockValue' block);  	byte[] temp = new byte[blockValue.Length + passwordHash.Length];  	Array.Copy (passwordHash' temp' passwordHash.Length);  	Array.Copy (blockValue' 0' temp' passwordHash.Length' blockValue.Length);  	byte[] finalHash = sha1.ComputeHash (temp);  	//sha1.digest(blockValue);  	int reqiredKeyLength = (info.Header.KeySize) / 8;  	byte[] buff = new byte[64];  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x36;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x1 = sha1.ComputeHash (buff);  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x5c;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x2 = sha1.ComputeHash (buff);  	byte[] x3 = new byte[x1.Length + x2.Length];  	System.Array.Copy (x1' 0' x3' 0' x1.Length);  	System.Array.Copy (x2' 0' x3' x1.Length' x2.Length);  	return TruncateOrPad (x3' reqiredKeyLength);  }  catch (System.Security.Cryptography.CryptographicException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EcmaDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EcmaDecryptor.cs,GenerateKey,The following statement contains a magic number: try {  	HashAlgorithm sha1 = HashAlgorithm.Create ("SHA1");  	//sha1.update(passwordHash);  	byte[] blockValue = new byte[4];  	LittleEndian.PutInt (blockValue' block);  	byte[] temp = new byte[blockValue.Length + passwordHash.Length];  	Array.Copy (passwordHash' temp' passwordHash.Length);  	Array.Copy (blockValue' 0' temp' passwordHash.Length' blockValue.Length);  	byte[] finalHash = sha1.ComputeHash (temp);  	//sha1.digest(blockValue);  	int reqiredKeyLength = (info.Header.KeySize) / 8;  	byte[] buff = new byte[64];  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x36;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x1 = sha1.ComputeHash (buff);  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x5c;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x2 = sha1.ComputeHash (buff);  	byte[] x3 = new byte[x1.Length + x2.Length];  	System.Array.Copy (x1' 0' x3' 0' x1.Length);  	System.Array.Copy (x2' 0' x3' x1.Length' x2.Length);  	return TruncateOrPad (x3' reqiredKeyLength);  }  catch (System.Security.Cryptography.CryptographicException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EcmaDecryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EcmaDecryptor.cs,GenerateKey,The following statement contains a magic number: try {  	HashAlgorithm sha1 = HashAlgorithm.Create ("SHA1");  	//sha1.update(passwordHash);  	byte[] blockValue = new byte[4];  	LittleEndian.PutInt (blockValue' block);  	byte[] temp = new byte[blockValue.Length + passwordHash.Length];  	Array.Copy (passwordHash' temp' passwordHash.Length);  	Array.Copy (blockValue' 0' temp' passwordHash.Length' blockValue.Length);  	byte[] finalHash = sha1.ComputeHash (temp);  	//sha1.digest(blockValue);  	int reqiredKeyLength = (info.Header.KeySize) / 8;  	byte[] buff = new byte[64];  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x36;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x1 = sha1.ComputeHash (buff);  	for (int i = 0; i < buff.Length; i++)  		buff [i] = (byte)0x5c;  	for (int i = 0; i < finalHash.Length; i++)  		buff [i] = (byte)(buff [i] ^ finalHash [i]);  	//sha1.Clear();  	byte[] x2 = sha1.ComputeHash (buff);  	byte[] x3 = new byte[x1.Length + x2.Length];  	System.Array.Copy (x1' 0' x3' 0' x1.Length);  	System.Array.Copy (x2' 0' x3' x1.Length' x2.Length);  	return TruncateOrPad (x3' reqiredKeyLength);  }  catch (System.Security.Cryptography.CryptographicException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: try {  	XmlAttributeCollection keyData;  	try {  		MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  		XmlDocument xml = new XmlDocument ();  		xml.Load (ms);  		XmlNodeList node = xml.GetElementsByTagName ("keyData");  		keyData = node [0].Attributes;  	}  	catch (Exception) {  		throw new EncryptedDocumentException ("Unable to parse keyData");  	}  	keySize = Int32.Parse (keyData.GetNamedItem ("keyBits").Value);  	flags = 0;  	sizeExtra = 0;  	cspName = null;  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string cipher = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (cipher)) {  		providerType = PROVIDER_AES;  		if (blockSize == 16)  			algorithm = ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported key length");  	}  	else {  		throw new EncryptedDocumentException ("Unsupported cipher");  	}  	string chaining = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chaining))  		cipherMode = MODE_CBC;  	else if ("ChainingModeCFB".Equals (chaining))  		cipherMode = MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	string hasAlg = keyData.GetNamedItem ("hashAlgorithm").Value;  	int hashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  	if ("SHA1".Equals (hasAlg) && hashSize == 20)  		hashAlgorithm = HASH_SHA1;  	else  		throw new EncryptedDocumentException ("Unsupported hash algorithm");  	string salt = keyData.GetNamedItem ("saltValue").Value;  	int saltLength = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	//keySalt = Base64.DecodeBase64(Encoding.Default.GetBytes(salt));  	//keySalt = Base64.DecodeBase64(salt);  	keySalt = Convert.FromBase64String (salt);  	if (keySalt.Length != saltLength)  		throw new EncryptedDocumentException ("Invalid salt length");  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: try {  	XmlAttributeCollection keyData;  	try {  		MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  		XmlDocument xml = new XmlDocument ();  		xml.Load (ms);  		XmlNodeList node = xml.GetElementsByTagName ("keyData");  		keyData = node [0].Attributes;  	}  	catch (Exception) {  		throw new EncryptedDocumentException ("Unable to parse keyData");  	}  	keySize = Int32.Parse (keyData.GetNamedItem ("keyBits").Value);  	flags = 0;  	sizeExtra = 0;  	cspName = null;  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string cipher = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (cipher)) {  		providerType = PROVIDER_AES;  		if (blockSize == 16)  			algorithm = ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported key length");  	}  	else {  		throw new EncryptedDocumentException ("Unsupported cipher");  	}  	string chaining = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chaining))  		cipherMode = MODE_CBC;  	else if ("ChainingModeCFB".Equals (chaining))  		cipherMode = MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	string hasAlg = keyData.GetNamedItem ("hashAlgorithm").Value;  	int hashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  	if ("SHA1".Equals (hasAlg) && hashSize == 20)  		hashAlgorithm = HASH_SHA1;  	else  		throw new EncryptedDocumentException ("Unsupported hash algorithm");  	string salt = keyData.GetNamedItem ("saltValue").Value;  	int saltLength = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	//keySalt = Base64.DecodeBase64(Encoding.Default.GetBytes(salt));  	//keySalt = Base64.DecodeBase64(salt);  	keySalt = Convert.FromBase64String (salt);  	if (keySalt.Length != saltLength)  		throw new EncryptedDocumentException ("Invalid salt length");  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: try {  	XmlAttributeCollection keyData;  	try {  		MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  		XmlDocument xml = new XmlDocument ();  		xml.Load (ms);  		XmlNodeList node = xml.GetElementsByTagName ("keyData");  		keyData = node [0].Attributes;  	}  	catch (Exception) {  		throw new EncryptedDocumentException ("Unable to parse keyData");  	}  	keySize = Int32.Parse (keyData.GetNamedItem ("keyBits").Value);  	flags = 0;  	sizeExtra = 0;  	cspName = null;  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string cipher = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (cipher)) {  		providerType = PROVIDER_AES;  		if (blockSize == 16)  			algorithm = ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported key length");  	}  	else {  		throw new EncryptedDocumentException ("Unsupported cipher");  	}  	string chaining = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chaining))  		cipherMode = MODE_CBC;  	else if ("ChainingModeCFB".Equals (chaining))  		cipherMode = MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	string hasAlg = keyData.GetNamedItem ("hashAlgorithm").Value;  	int hashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  	if ("SHA1".Equals (hasAlg) && hashSize == 20)  		hashAlgorithm = HASH_SHA1;  	else  		throw new EncryptedDocumentException ("Unsupported hash algorithm");  	string salt = keyData.GetNamedItem ("saltValue").Value;  	int saltLength = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	//keySalt = Base64.DecodeBase64(Encoding.Default.GetBytes(salt));  	//keySalt = Base64.DecodeBase64(salt);  	keySalt = Convert.FromBase64String (salt);  	if (keySalt.Length != saltLength)  		throw new EncryptedDocumentException ("Invalid salt length");  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: try {  	XmlAttributeCollection keyData;  	try {  		MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  		XmlDocument xml = new XmlDocument ();  		xml.Load (ms);  		XmlNodeList node = xml.GetElementsByTagName ("keyData");  		keyData = node [0].Attributes;  	}  	catch (Exception) {  		throw new EncryptedDocumentException ("Unable to parse keyData");  	}  	keySize = Int32.Parse (keyData.GetNamedItem ("keyBits").Value);  	flags = 0;  	sizeExtra = 0;  	cspName = null;  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string cipher = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (cipher)) {  		providerType = PROVIDER_AES;  		if (blockSize == 16)  			algorithm = ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported key length");  	}  	else {  		throw new EncryptedDocumentException ("Unsupported cipher");  	}  	string chaining = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chaining))  		cipherMode = MODE_CBC;  	else if ("ChainingModeCFB".Equals (chaining))  		cipherMode = MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	string hasAlg = keyData.GetNamedItem ("hashAlgorithm").Value;  	int hashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  	if ("SHA1".Equals (hasAlg) && hashSize == 20)  		hashAlgorithm = HASH_SHA1;  	else  		throw new EncryptedDocumentException ("Unsupported hash algorithm");  	string salt = keyData.GetNamedItem ("saltValue").Value;  	int saltLength = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	//keySalt = Base64.DecodeBase64(Encoding.Default.GetBytes(salt));  	//keySalt = Base64.DecodeBase64(salt);  	keySalt = Convert.FromBase64String (salt);  	if (keySalt.Length != saltLength)  		throw new EncryptedDocumentException ("Invalid salt length");  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if ("AES".Equals (cipher)) {  	providerType = PROVIDER_AES;  	if (blockSize == 16)  		algorithm = ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported key length");  }  else {  	throw new EncryptedDocumentException ("Unsupported cipher");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if ("AES".Equals (cipher)) {  	providerType = PROVIDER_AES;  	if (blockSize == 16)  		algorithm = ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported key length");  }  else {  	throw new EncryptedDocumentException ("Unsupported cipher");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if ("AES".Equals (cipher)) {  	providerType = PROVIDER_AES;  	if (blockSize == 16)  		algorithm = ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported key length");  }  else {  	throw new EncryptedDocumentException ("Unsupported cipher");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 16)  	algorithm = ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 16)  	algorithm = ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 16)  	algorithm = ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 24)  	algorithm = ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 24)  	algorithm = ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if (blockSize == 32)  	algorithm = ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported key length");  
Magic Number,NPOI.POIFS.Crypt,EncryptionHeader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionHeader.cs,EncryptionHeader,The following statement contains a magic number: if ("SHA1".Equals (hasAlg) && hashSize == 20)  	hashAlgorithm = HASH_SHA1;  else  	throw new EncryptedDocumentException ("Unsupported hash algorithm");  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (versionMajor == 4 && versionMinor == 4 && encryptionFlags == 0x40) {  	StringBuilder builder = new StringBuilder ();  	byte[] xmlDescriptor = new byte[dis.Available ()];  	dis.Read (xmlDescriptor);  	foreach (byte b in xmlDescriptor)  		builder.Append ((char)b);  	string descriptor = builder.ToString ();  	header = new EncryptionHeader (descriptor);  	verifier = new EncryptionVerifier (descriptor);  }  else {  	int hSize = dis.ReadInt ();  	header = new EncryptionHeader (dis);  	if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  		verifier = new EncryptionVerifier (dis' 20);  	}  	else {  		verifier = new EncryptionVerifier (dis' 32);  	}  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (versionMajor == 4 && versionMinor == 4 && encryptionFlags == 0x40) {  	StringBuilder builder = new StringBuilder ();  	byte[] xmlDescriptor = new byte[dis.Available ()];  	dis.Read (xmlDescriptor);  	foreach (byte b in xmlDescriptor)  		builder.Append ((char)b);  	string descriptor = builder.ToString ();  	header = new EncryptionHeader (descriptor);  	verifier = new EncryptionVerifier (descriptor);  }  else {  	int hSize = dis.ReadInt ();  	header = new EncryptionHeader (dis);  	if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  		verifier = new EncryptionVerifier (dis' 20);  	}  	else {  		verifier = new EncryptionVerifier (dis' 32);  	}  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (versionMajor == 4 && versionMinor == 4 && encryptionFlags == 0x40) {  	StringBuilder builder = new StringBuilder ();  	byte[] xmlDescriptor = new byte[dis.Available ()];  	dis.Read (xmlDescriptor);  	foreach (byte b in xmlDescriptor)  		builder.Append ((char)b);  	string descriptor = builder.ToString ();  	header = new EncryptionHeader (descriptor);  	verifier = new EncryptionVerifier (descriptor);  }  else {  	int hSize = dis.ReadInt ();  	header = new EncryptionHeader (dis);  	if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  		verifier = new EncryptionVerifier (dis' 20);  	}  	else {  		verifier = new EncryptionVerifier (dis' 32);  	}  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (versionMajor == 4 && versionMinor == 4 && encryptionFlags == 0x40) {  	StringBuilder builder = new StringBuilder ();  	byte[] xmlDescriptor = new byte[dis.Available ()];  	dis.Read (xmlDescriptor);  	foreach (byte b in xmlDescriptor)  		builder.Append ((char)b);  	string descriptor = builder.ToString ();  	header = new EncryptionHeader (descriptor);  	verifier = new EncryptionVerifier (descriptor);  }  else {  	int hSize = dis.ReadInt ();  	header = new EncryptionHeader (dis);  	if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  		verifier = new EncryptionVerifier (dis' 20);  	}  	else {  		verifier = new EncryptionVerifier (dis' 32);  	}  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  	verifier = new EncryptionVerifier (dis' 20);  }  else {  	verifier = new EncryptionVerifier (dis' 32);  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: if (header.Algorithm == EncryptionHeader.ALGORITHM_RC4) {  	verifier = new EncryptionVerifier (dis' 20);  }  else {  	verifier = new EncryptionVerifier (dis' 32);  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: verifier = new EncryptionVerifier (dis' 20);  
Magic Number,NPOI.POIFS.Crypt,EncryptionInfo,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionInfo.cs,EncryptionInfo,The following statement contains a magic number: verifier = new EncryptionVerifier (dis' 32);  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: try {  	MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  	XmlDocument xml = new XmlDocument ();  	xml.Load (ms);  	XmlNodeList nodes = xml.GetElementsByTagName ("keyEncryptor");  	XmlNodeList keyEncryptor = nodes [0].ChildNodes;  	for (int i = 0; i < keyEncryptor.Count; i++) {  		XmlNode node = keyEncryptor [i];  		if (node.Name.Equals ("p:encryptedKey")) {  			keyData = node.Attributes;  			break;  		}  	}  	if (keyData == null)  		throw new EncryptedDocumentException ("");  	spinCount = Int32.Parse (keyData.GetNamedItem ("spinCount").Value);  	verifier = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashInput").Value);  	salt = Convert.FromBase64String (keyData.GetNamedItem ("saltValue").Value);  	encryptedKey = Convert.FromBase64String (keyData.GetNamedItem ("encryptedKeyValue").Value);  	int saltSize = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	if (saltSize != salt.Length)  		throw new EncryptedDocumentException ("Invalid salt size");  	verifierHash = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashValue").Value);  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string alg = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (alg)) {  		if (blockSize == 16)  			algorithm = EncryptionHeader.ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = EncryptionHeader.ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = EncryptionHeader.ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported block size");  	}  	else  		throw new EncryptedDocumentException ("Unsupported cipher");  	string chain = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CBC;  	else if ("ChainingModeCFB".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	verifierHashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  }  catch {  	throw new EncryptedDocumentException ("Unable to parse keyEncryptor");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: try {  	MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  	XmlDocument xml = new XmlDocument ();  	xml.Load (ms);  	XmlNodeList nodes = xml.GetElementsByTagName ("keyEncryptor");  	XmlNodeList keyEncryptor = nodes [0].ChildNodes;  	for (int i = 0; i < keyEncryptor.Count; i++) {  		XmlNode node = keyEncryptor [i];  		if (node.Name.Equals ("p:encryptedKey")) {  			keyData = node.Attributes;  			break;  		}  	}  	if (keyData == null)  		throw new EncryptedDocumentException ("");  	spinCount = Int32.Parse (keyData.GetNamedItem ("spinCount").Value);  	verifier = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashInput").Value);  	salt = Convert.FromBase64String (keyData.GetNamedItem ("saltValue").Value);  	encryptedKey = Convert.FromBase64String (keyData.GetNamedItem ("encryptedKeyValue").Value);  	int saltSize = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	if (saltSize != salt.Length)  		throw new EncryptedDocumentException ("Invalid salt size");  	verifierHash = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashValue").Value);  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string alg = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (alg)) {  		if (blockSize == 16)  			algorithm = EncryptionHeader.ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = EncryptionHeader.ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = EncryptionHeader.ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported block size");  	}  	else  		throw new EncryptedDocumentException ("Unsupported cipher");  	string chain = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CBC;  	else if ("ChainingModeCFB".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	verifierHashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  }  catch {  	throw new EncryptedDocumentException ("Unable to parse keyEncryptor");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: try {  	MemoryStream ms = new MemoryStream (Encoding.Default.GetBytes (descriptor));  	XmlDocument xml = new XmlDocument ();  	xml.Load (ms);  	XmlNodeList nodes = xml.GetElementsByTagName ("keyEncryptor");  	XmlNodeList keyEncryptor = nodes [0].ChildNodes;  	for (int i = 0; i < keyEncryptor.Count; i++) {  		XmlNode node = keyEncryptor [i];  		if (node.Name.Equals ("p:encryptedKey")) {  			keyData = node.Attributes;  			break;  		}  	}  	if (keyData == null)  		throw new EncryptedDocumentException ("");  	spinCount = Int32.Parse (keyData.GetNamedItem ("spinCount").Value);  	verifier = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashInput").Value);  	salt = Convert.FromBase64String (keyData.GetNamedItem ("saltValue").Value);  	encryptedKey = Convert.FromBase64String (keyData.GetNamedItem ("encryptedKeyValue").Value);  	int saltSize = Int32.Parse (keyData.GetNamedItem ("saltSize").Value);  	if (saltSize != salt.Length)  		throw new EncryptedDocumentException ("Invalid salt size");  	verifierHash = Convert.FromBase64String (keyData.GetNamedItem ("encryptedVerifierHashValue").Value);  	int blockSize = Int32.Parse (keyData.GetNamedItem ("blockSize").Value);  	string alg = keyData.GetNamedItem ("cipherAlgorithm").Value;  	if ("AES".Equals (alg)) {  		if (blockSize == 16)  			algorithm = EncryptionHeader.ALGORITHM_AES_128;  		else if (blockSize == 24)  			algorithm = EncryptionHeader.ALGORITHM_AES_192;  		else if (blockSize == 32)  			algorithm = EncryptionHeader.ALGORITHM_AES_256;  		else  			throw new EncryptedDocumentException ("Unsupported block size");  	}  	else  		throw new EncryptedDocumentException ("Unsupported cipher");  	string chain = keyData.GetNamedItem ("cipherChaining").Value;  	if ("ChainingModeCBC".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CBC;  	else if ("ChainingModeCFB".Equals (chain))  		cipherMode = EncryptionHeader.MODE_CFB;  	else  		throw new EncryptedDocumentException ("Unsupported chaining mode");  	verifierHashSize = Int32.Parse (keyData.GetNamedItem ("hashSize").Value);  }  catch {  	throw new EncryptedDocumentException ("Unable to parse keyEncryptor");  }  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if ("AES".Equals (alg)) {  	if (blockSize == 16)  		algorithm = EncryptionHeader.ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = EncryptionHeader.ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = EncryptionHeader.ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported block size");  }  else  	throw new EncryptedDocumentException ("Unsupported cipher");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if ("AES".Equals (alg)) {  	if (blockSize == 16)  		algorithm = EncryptionHeader.ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = EncryptionHeader.ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = EncryptionHeader.ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported block size");  }  else  	throw new EncryptedDocumentException ("Unsupported cipher");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if ("AES".Equals (alg)) {  	if (blockSize == 16)  		algorithm = EncryptionHeader.ALGORITHM_AES_128;  	else if (blockSize == 24)  		algorithm = EncryptionHeader.ALGORITHM_AES_192;  	else if (blockSize == 32)  		algorithm = EncryptionHeader.ALGORITHM_AES_256;  	else  		throw new EncryptedDocumentException ("Unsupported block size");  }  else  	throw new EncryptedDocumentException ("Unsupported cipher");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 16)  	algorithm = EncryptionHeader.ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = EncryptionHeader.ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 16)  	algorithm = EncryptionHeader.ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = EncryptionHeader.ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 16)  	algorithm = EncryptionHeader.ALGORITHM_AES_128;  else if (blockSize == 24)  	algorithm = EncryptionHeader.ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 24)  	algorithm = EncryptionHeader.ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 24)  	algorithm = EncryptionHeader.ALGORITHM_AES_192;  else if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (blockSize == 32)  	algorithm = EncryptionHeader.ALGORITHM_AES_256;  else  	throw new EncryptedDocumentException ("Unsupported block size");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: if (saltSize != 16)  	throw new Exception ("Salt size != 16 !?");  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: salt = new byte[16];  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: verifier = new byte[16];  
Magic Number,NPOI.POIFS.Crypt,EncryptionVerifier,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\EncryptionVerifier.cs,EncryptionVerifier,The following statement contains a magic number: spinCount = 50000;  
Magic Number,NPOI.POIFS.FileSystem,NDocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NDocumentInputStream.cs,Read,The following statement contains a magic number: if (result >= 0) {  	if (b [0] < 0) {  		return b [0] + 256;  	}  	return b [0];  }  
Magic Number,NPOI.POIFS.FileSystem,NDocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NDocumentInputStream.cs,Read,The following statement contains a magic number: if (b [0] < 0) {  	return b [0] + 256;  }  
Magic Number,NPOI.POIFS.FileSystem,NDocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NDocumentInputStream.cs,Read,The following statement contains a magic number: return b [0] + 256;  
Magic Number,NPOI.POIFS.FileSystem,NDocumentInputStream,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NDocumentInputStream.cs,ReadUByte,The following statement contains a magic number: return data [0] + 256;  
Magic Number,NPOI.POIFS.FileSystem,NPOIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSFileSystem.cs,NPOIFSFileSystem,The following statement contains a magic number: if (newFS) {  	// Data needs to Initially hold just the header block'  	//  a single bat block' and an empty properties section  	_data = new ByteArrayBackedDataSource (new byte[bigBlockSize.GetBigBlockSize () * 3]);  }  
Magic Number,NPOI.POIFS.FileSystem,NPOIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSFileSystem.cs,NPOIFSFileSystem,The following statement contains a magic number: _data = new ByteArrayBackedDataSource (new byte[bigBlockSize.GetBigBlockSize () * 3]);  
Magic Number,NPOI.POIFS.FileSystem,NPOIFSFileSystem,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\NPOIFSFileSystem.cs,GetFreeBlock,The following statement contains a magic number: if (_header.BATCount >= 109) {  	// Needs to come from an XBAT  	BATBlock xbat = null;  	foreach (BATBlock x in _xbat_blocks) {  		if (x.HasFreeSectors) {  			xbat = x;  			break;  		}  	}  	if (xbat == null) {  		// Oh joy' we need a new XBAT too...  		xbat = CreateBAT (offset + 1' false);  		xbat.SetValueAt (0' offset);  		bat.SetValueAt (1' POIFSConstants.DIFAT_SECTOR_BLOCK);  		// Will go one place higher as XBAT Added in  		offset++;  		// Chain it  		if (_xbat_blocks.Count == 0) {  			_header.XBATStart = offset;  		}  		else {  			_xbat_blocks [_xbat_blocks.Count - 1].SetValueAt (bigBlockSize.GetXBATEntriesPerBlock ()' offset);  		}  		_xbat_blocks.Add (xbat);  		_header.XBATCount = _xbat_blocks.Count;  	}  	// Allocate us in the XBAT  	for (int i = 0; i < bigBlockSize.GetXBATEntriesPerBlock (); i++) {  		if (xbat.GetValueAt (i) == POIFSConstants.UNUSED_BLOCK) {  			xbat.SetValueAt (i' offset);  		}  	}  }  else {  	// Store us in the header  	int[] newBATs = new int[_header.BATCount + 1];  	Array.Copy (_header.BATArray' 0' newBATs' 0' newBATs.Length - 1);  	newBATs [newBATs.Length - 1] = offset;  	_header.BATArray = newBATs;  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (data.Length < offset + 2) {  	throw new Ole10NativeException ("data is too small");  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: if (plain) {  	dataBuffer = new byte[totalSize - 4];  	Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  	dataSize = totalSize - 4;  	byte[] oleLabel = new byte[8];  	Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  	label = "ole-" + HexDump.ToHex (oleLabel);  	fileName = label;  	command = label;  }  else {  	flags1 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	int len = GetStringLength (data' ofs);  	label = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	len = GetStringLength (data' ofs);  	fileName = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	flags2 = LittleEndian.GetShort (data' ofs);  	ofs += LittleEndianConsts.SHORT_SIZE;  	len = LittleEndian.GetUnsignedByte (data' ofs);  	unknown1 = new byte[len];  	ofs += len;  	len = 3;  	unknown2 = new byte[len];  	ofs += len;  	len = GetStringLength (data' ofs);  	command = StringUtil.GetFromCompressedUnicode (data' ofs' len - 1);  	ofs += len;  	if (totalSize + LittleEndianConsts.INT_SIZE - ofs > LittleEndianConsts.INT_SIZE) {  		dataSize = LittleEndian.GetInt (data' ofs);  		ofs += LittleEndianConsts.INT_SIZE;  		if (dataSize > totalSize || dataSize < 0) {  			throw new Ole10NativeException ("Invalid Ole10Native");  		}  		dataBuffer = new byte[dataSize];  		Array.Copy (data' ofs' dataBuffer' 0' dataSize);  		ofs += dataSize;  		if (unknown1.Length > 0) {  			flags3 = LittleEndian.GetShort (data' ofs);  			ofs += LittleEndianConsts.SHORT_SIZE;  		}  		else {  			flags3 = 0;  		}  	}  	else {  		throw new Ole10NativeException ("Invalid Ole10Native");  	}  }  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: dataBuffer = new byte[totalSize - 4];  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: Array.Copy (data' 4' dataBuffer' 0' dataBuffer.Length);  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: dataSize = totalSize - 4;  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: Array.Copy (dataBuffer' 0' oleLabel' 0' Math.Min (dataBuffer.Length' 8));  
Magic Number,NPOI.POIFS.FileSystem,Ole10Native,C:\repos\xoposhiy_npoi\trunk\main\POIFS\FileSystem\Ole10Native.cs,Ole10Native,The following statement contains a magic number: len = 3;  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: if (difference < buffer.Length * 0.25) {  	difference = (long)(buffer.Length * 0.25);  }  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: if (difference < buffer.Length * 0.25) {  	difference = (long)(buffer.Length * 0.25);  }  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: difference = (long)(buffer.Length * 0.25);  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: if (difference < 4096) {  	difference = 4096;  }  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: if (difference < 4096) {  	difference = 4096;  }  
Magic Number,NPOI.POIFS.NIO,ByteArrayBackedDataSource,C:\repos\xoposhiy_npoi\trunk\main\POIFS\NIO\ByteArrayBackedDataSource.cs,Extend,The following statement contains a magic number: difference = 4096;  
Magic Number,NPOI.SS.Formula.Atp,EDate,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\EDate.cs,Evaluate,The following statement contains a magic number: if (args.Length != 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,MRound,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\MRound.cs,Evaluate,The following statement contains a magic number: if (args.Length != 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,RandBetween,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\RandBetween.cs,Evaluate,The following statement contains a magic number: if (args.Length != 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: try {  	int basis = 0;  	// default  	switch (args.Length) {  	case 3:  		basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  		break;  	case 2:  		//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  		break;  	default:  		return ErrorEval.VALUE_INVALID;  	}  	double startDateVal = EvaluateDateArg (args [0]' srcCellRow' srcCellCol);  	double endDateVal = EvaluateDateArg (args [1]' srcCellRow' srcCellCol);  	result = YearFracCalculator.Calculate (startDateVal' endDateVal' basis);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: try {  	int basis = 0;  	// default  	switch (args.Length) {  	case 3:  		basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  		break;  	case 2:  		//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  		break;  	default:  		return ErrorEval.VALUE_INVALID;  	}  	double startDateVal = EvaluateDateArg (args [0]' srcCellRow' srcCellCol);  	double endDateVal = EvaluateDateArg (args [1]' srcCellRow' srcCellCol);  	result = YearFracCalculator.Calculate (startDateVal' endDateVal' basis);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: try {  	int basis = 0;  	// default  	switch (args.Length) {  	case 3:  		basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  		break;  	case 2:  		//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  		break;  	default:  		return ErrorEval.VALUE_INVALID;  	}  	double startDateVal = EvaluateDateArg (args [0]' srcCellRow' srcCellCol);  	double endDateVal = EvaluateDateArg (args [1]' srcCellRow' srcCellCol);  	result = YearFracCalculator.Calculate (startDateVal' endDateVal' basis);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	break;  case 2:  	//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	break;  case 2:  	//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	break;  case 2:  	//basis = EvaluateIntArg(args[2]' srcCellRow' srcCellCol);  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,Evaluate,The following statement contains a magic number: basis = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (parts.Length != 3) {  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {  	// easy to see this cannot be a valid date  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {  	// easy to see this cannot be a valid date  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (f0 < 0 || f1 < 0 || f2 < 0 || (f0 > 12 && f1 > 12 && f2 > 12)) {  	// easy to see this cannot be a valid date  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (f0 >= 1900 && f0 < 9999) {  	// when 4 digit value appears first' the format is YYYY/MM/DD' regardless of OS settings  	return MakeDate (f0' f1' f2);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFrac,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFrac.cs,ParseDate,The following statement contains a magic number: if (f0 >= 1900 && f0 < 9999) {  	// when 4 digit value appears first' the format is YYYY/MM/DD' regardless of OS settings  	return MakeDate (f0' f1' f2);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,The following statement contains a magic number: if (basis < 0 || basis >= 5) {  	// if basis is invalid the result is #NUM!  	throw new EvaluationException (ErrorEval.NUM_ERROR);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,The following statement contains a magic number: switch (basis) {  case 0:  	return Basis0 (startDateVal' endDateVal);  case 1:  	return Basis1 (startDateVal' endDateVal);  case 2:  	return Basis2 (startDateVal' endDateVal);  case 3:  	return Basis3 (startDateVal' endDateVal);  case 4:  	return Basis4 (startDateVal' endDateVal);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,The following statement contains a magic number: switch (basis) {  case 0:  	return Basis0 (startDateVal' endDateVal);  case 1:  	return Basis1 (startDateVal' endDateVal);  case 2:  	return Basis2 (startDateVal' endDateVal);  case 3:  	return Basis3 (startDateVal' endDateVal);  case 4:  	return Basis4 (startDateVal' endDateVal);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,The following statement contains a magic number: switch (basis) {  case 0:  	return Basis0 (startDateVal' endDateVal);  case 1:  	return Basis1 (startDateVal' endDateVal);  case 2:  	return Basis2 (startDateVal' endDateVal);  case 3:  	return Basis3 (startDateVal' endDateVal);  case 4:  	return Basis4 (startDateVal' endDateVal);  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == LONG_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  	date2day = SHORT_MONTH_LEN;  }  else if (date1day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  }  else if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == LONG_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  	date2day = SHORT_MONTH_LEN;  }  else if (date1day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  }  else if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  }  else if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == LONG_MONTH_LEN) {  	date1day = SHORT_MONTH_LEN;  }  else if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (date1day == SHORT_MONTH_LEN && date2day == LONG_MONTH_LEN) {  	date2day = SHORT_MONTH_LEN;  	// Note: If date2day==31' it STAYS 31 if date1day < 30.  	// Special fixes for February:  }  else if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (startDate.month == 2 && IsLastDayOfMonth (startDate)) {  	// Note - these assignments deliberately set Feb 30 date.  	date1day = SHORT_MONTH_LEN;  	if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  		// only adjusted when first date is last day in Feb  		date2day = SHORT_MONTH_LEN;  	}  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis0,The following statement contains a magic number: if (endDate.month == 2 && IsLastDayOfMonth (endDate)) {  	// only adjusted when first date is last day in Feb  	date2day = SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis2,The following statement contains a magic number: return (endDateVal - startDateVal) / 360.0;  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Basis3,The following statement contains a magic number: return (endDateVal - startDateVal) / 365.0;  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,CalculateAdjusted,The following statement contains a magic number: return dayCount / 360;  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following statement contains a magic number: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,IsLeapYear,The following statement contains a magic number: if (i % 4 != 0) {  	return false;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,IsLeapYear,The following statement contains a magic number: if (i % 400 == 0) {  	return true;  }  
Magic Number,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,IsLeapYear,The following statement contains a magic number: if (i % 100 == 0) {  	return false;  }  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 2' "0.00");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 3' "#'##0");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 4' "#'##0.00");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 5' "\"$\"#'##0_);(\"$\"#'##0)");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 6' "\"$\"#'##0_);[Red](\"$\"#'##0)");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 7' "\"$\"#'##0.00_);(\"$\"#'##0.00)");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 8' "\"$\"#'##0.00_);[Red](\"$\"#'##0.00)");  
Magic Number,NPOI.SS.UserModel,BuiltinFormats,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\BuiltinFormats.cs,BuiltinFormats,The following statement contains a magic number: PutFormat (m' 9' "0%");  
Magic Number,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,DataFormatter,The following statement contains a magic number: for (int i = 0; i < 255; i++)  	buf.Append ('#');  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,AbsoluteDay,The following statement contains a magic number: if (cal > new DateTime (1900' 3' 1) && use1904windowing) {  	daynum++;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,AbsoluteDay,The following statement contains a magic number: if (cal > new DateTime (1900' 3' 1) && use1904windowing) {  	daynum++;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((!use1904windowing && year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && year < 1904))//1904 date system must bigger than 1904   {  	return BAD_DATE;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((!use1904windowing && year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && year < 1904))//1904 date system must bigger than 1904   {  	return BAD_DATE;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (use1904windowing) {  	startdate = new DateTime (1904' 1' 1);  }  else {  	startdate = new DateTime (1900' 1' 1);  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (use1904windowing) {  	startdate = new DateTime (1904' 1' 1);  }  else {  	startdate = new DateTime (1900' 1' 1);  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: startdate = new DateTime (1904' 1' 1);  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: startdate = new DateTime (1900' 1' 1);  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (month > 12) {  	nextyearmonth = month - 12;  	month = 12;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (month > 12) {  	nextyearmonth = month - 12;  	month = 12;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (month > 12) {  	nextyearmonth = month - 12;  	month = 12;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: nextyearmonth = month - 12;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: month = 12;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12)) {  	//big month  	if (day > 31) {  		nextmonthday = day - 31;  		day = 31;  	}  }  else if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 31) {  	nextmonthday = day - 31;  	day = 31;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 31) {  	nextmonthday = day - 31;  	day = 31;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 31) {  	nextmonthday = day - 31;  	day = 31;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: nextmonthday = day - 31;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: day = 31;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((month == 4 || month == 6 || month == 9 || month == 11)) {  	//small month  	if (day > 30) {  		nextmonthday = day - 30;  		day = 30;  	}  }  else if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 30) {  	nextmonthday = day - 30;  	day = 30;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 30) {  	nextmonthday = day - 30;  	day = 30;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 30) {  	nextmonthday = day - 30;  	day = 30;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: nextmonthday = day - 30;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: day = 30;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (DateTime.IsLeapYear (year)) {  	//Feb. with leap year  	if (day > 29) {  		nextmonthday = day - 29;  		day = 29;  	}  }  else {  	//Feb without leap year  	if (day > 28) {  		nextmonthday = day - 28;  		day = 28;  	}  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 29) {  	nextmonthday = day - 29;  	day = 29;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 29) {  	nextmonthday = day - 29;  	day = 29;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 29) {  	nextmonthday = day - 29;  	day = 29;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: nextmonthday = day - 29;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: day = 29;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 28) {  	nextmonthday = day - 28;  	day = 28;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 28) {  	nextmonthday = day - 28;  	day = 28;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (day > 28) {  	nextmonthday = day - 28;  	day = 28;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: nextmonthday = day - 28;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: day = 28;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (!use1904windowing && value >= 60) {  	value++;  }  else if (use1904windowing) {  	value--;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((!use1904windowing && date.Year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && date.Year < 1904))//1904 date system must bigger than 1904   {  	return BAD_DATE;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if ((!use1904windowing && date.Year < 1900) //1900 date system must bigger than 1900  || (use1904windowing && date.Year < 1904))//1904 date system must bigger than 1904   {  	return BAD_DATE;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (use1904windowing) {  	startdate = new DateTime (1904' 1' 1);  }  else {  	startdate = new DateTime (1900' 1' 1);  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (use1904windowing) {  	startdate = new DateTime (1904' 1' 1);  }  else {  	startdate = new DateTime (1900' 1' 1);  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: startdate = new DateTime (1904' 1' 1);  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: startdate = new DateTime (1900' 1' 1);  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetExcelDate,The following statement contains a magic number: if (!use1904windowing && value >= 60) {  	value++;  }  else if (use1904windowing) {  	value--;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetJavaDate,The following statement contains a magic number: if (use1904windowing) {  	startYear = 1904;  	dayAdjust = 1;  	// 1904 date windowing uses 1/2/1904 as the first day  }  else if (wholeDays < 61) {  	// Date Is prior to 3/1/1900' so adjust because Excel thinks 2/29/1900 exists  	// If Excel date == 2/29/1900' will become 3/1/1900 in Java representation  	dayAdjust = 0;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetJavaDate,The following statement contains a magic number: if (use1904windowing) {  	startYear = 1904;  	dayAdjust = 1;  	// 1904 date windowing uses 1/2/1904 as the first day  }  else if (wholeDays < 61) {  	// Date Is prior to 3/1/1900' so adjust because Excel thinks 2/29/1900 exists  	// If Excel date == 2/29/1900' will become 3/1/1900 in Java representation  	dayAdjust = 0;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetJavaDate,The following statement contains a magic number: startYear = 1904;  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,GetJavaDate,The following statement contains a magic number: if (wholeDays < 61) {  	// Date Is prior to 3/1/1900' so adjust because Excel thinks 2/29/1900 exists  	// If Excel date == 2/29/1900' will become 3/1/1900 in Java representation  	dayAdjust = 0;  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: if (len < 4 || len > 8) {  	throw new FormatException ("Bad length");  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: if (len < 4 || len > 8) {  	throw new FormatException ("Bad length");  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: switch (parts.Length) {  case 2:  	secStr = "00";  	break;  case 3:  	secStr = parts [2];  	break;  default:  	throw new FormatException ("Expected 2 or 3 fields but got (" + parts.Length + ")");  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: switch (parts.Length) {  case 2:  	secStr = "00";  	break;  case 3:  	secStr = parts [2];  	break;  default:  	throw new FormatException ("Expected 2 or 3 fields but got (" + parts.Length + ")");  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: switch (parts.Length) {  case 2:  	secStr = "00";  	break;  case 3:  	secStr = parts [2];  	break;  default:  	throw new FormatException ("Expected 2 or 3 fields but got (" + parts.Length + ")");  }  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ConvertTimeInternal,The following statement contains a magic number: secStr = parts [2];  
Magic Number,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,ParseYYYYMMDDDateInternal,The following statement contains a magic number: if (timeStr.Length != 10) {  	throw new FormatException ("Bad length");  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (H_BRACKET_SYMBOL) != -1 || s.IndexOf (HH_BRACKET_SYMBOL) != -1) {  	double hours = dateToBeFormatted * 24 + 0.01;  	//get the hour part of the time  	hours = Math.Floor (hours);  	s = s.Replace ((H_BRACKET_SYMBOL).ToString ()' format1digit.Format (hours));  	s = s.Replace ((HH_BRACKET_SYMBOL).ToString ()' format2digits.Format (hours));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (H_BRACKET_SYMBOL) != -1 || s.IndexOf (HH_BRACKET_SYMBOL) != -1) {  	double hours = dateToBeFormatted * 24 + 0.01;  	//get the hour part of the time  	hours = Math.Floor (hours);  	s = s.Replace ((H_BRACKET_SYMBOL).ToString ()' format1digit.Format (hours));  	s = s.Replace ((HH_BRACKET_SYMBOL).ToString ()' format2digits.Format (hours));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (M_BRACKET_SYMBOL) != -1 || s.IndexOf (MM_BRACKET_SYMBOL) != -1) {  	double minutes = dateToBeFormatted * 24 * 60 + 0.01;  	minutes = Math.Floor (minutes);  	s = s.Replace ((M_BRACKET_SYMBOL).ToString ()' format1digit.Format (minutes));  	s = s.Replace ((MM_BRACKET_SYMBOL).ToString ()' format2digits.Format (minutes));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (M_BRACKET_SYMBOL) != -1 || s.IndexOf (MM_BRACKET_SYMBOL) != -1) {  	double minutes = dateToBeFormatted * 24 * 60 + 0.01;  	minutes = Math.Floor (minutes);  	s = s.Replace ((M_BRACKET_SYMBOL).ToString ()' format1digit.Format (minutes));  	s = s.Replace ((MM_BRACKET_SYMBOL).ToString ()' format2digits.Format (minutes));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (M_BRACKET_SYMBOL) != -1 || s.IndexOf (MM_BRACKET_SYMBOL) != -1) {  	double minutes = dateToBeFormatted * 24 * 60 + 0.01;  	minutes = Math.Floor (minutes);  	s = s.Replace ((M_BRACKET_SYMBOL).ToString ()' format1digit.Format (minutes));  	s = s.Replace ((MM_BRACKET_SYMBOL).ToString ()' format2digits.Format (minutes));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (S_BRACKET_SYMBOL) != -1 || s.IndexOf (SS_BRACKET_SYMBOL) != -1) {  	double seconds = (dateToBeFormatted * 24.0 * 60.0 * 60.0) + 0.01;  	s = s.Replace ((S_BRACKET_SYMBOL).ToString ()' format1digit.Format (seconds));  	s = s.Replace ((SS_BRACKET_SYMBOL).ToString ()' format2digits.Format (seconds));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (S_BRACKET_SYMBOL) != -1 || s.IndexOf (SS_BRACKET_SYMBOL) != -1) {  	double seconds = (dateToBeFormatted * 24.0 * 60.0 * 60.0) + 0.01;  	s = s.Replace ((S_BRACKET_SYMBOL).ToString ()' format1digit.Format (seconds));  	s = s.Replace ((SS_BRACKET_SYMBOL).ToString ()' format2digits.Format (seconds));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (S_BRACKET_SYMBOL) != -1 || s.IndexOf (SS_BRACKET_SYMBOL) != -1) {  	double seconds = (dateToBeFormatted * 24.0 * 60.0 * 60.0) + 0.01;  	s = s.Replace ((S_BRACKET_SYMBOL).ToString ()' format1digit.Format (seconds));  	s = s.Replace ((SS_BRACKET_SYMBOL).ToString ()' format2digits.Format (seconds));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (S_BRACKET_SYMBOL) != -1 || s.IndexOf (SS_BRACKET_SYMBOL) != -1) {  	double seconds = (dateToBeFormatted * 24.0 * 60.0 * 60.0) + 0.01;  	s = s.Replace ((S_BRACKET_SYMBOL).ToString ()' format1digit.Format (seconds));  	s = s.Replace ((SS_BRACKET_SYMBOL).ToString ()' format2digits.Format (seconds));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (L_BRACKET_SYMBOL) != -1 || s.IndexOf (LL_BRACKET_SYMBOL) != -1) {  	float millisTemp = (float)((dateToBeFormatted - Math.Floor (dateToBeFormatted)) * 24.0 * 60.0 * 60.0);  	float millis = (millisTemp - (int)millisTemp);  	s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  	s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (L_BRACKET_SYMBOL) != -1 || s.IndexOf (LL_BRACKET_SYMBOL) != -1) {  	float millisTemp = (float)((dateToBeFormatted - Math.Floor (dateToBeFormatted)) * 24.0 * 60.0 * 60.0);  	float millis = (millisTemp - (int)millisTemp);  	s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  	s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (L_BRACKET_SYMBOL) != -1 || s.IndexOf (LL_BRACKET_SYMBOL) != -1) {  	float millisTemp = (float)((dateToBeFormatted - Math.Floor (dateToBeFormatted)) * 24.0 * 60.0 * 60.0);  	float millis = (millisTemp - (int)millisTemp);  	s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  	s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (L_BRACKET_SYMBOL) != -1 || s.IndexOf (LL_BRACKET_SYMBOL) != -1) {  	float millisTemp = (float)((dateToBeFormatted - Math.Floor (dateToBeFormatted)) * 24.0 * 60.0 * 60.0);  	float millis = (millisTemp - (int)millisTemp);  	s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  	s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: if (s.IndexOf (L_BRACKET_SYMBOL) != -1 || s.IndexOf (LL_BRACKET_SYMBOL) != -1) {  	float millisTemp = (float)((dateToBeFormatted - Math.Floor (dateToBeFormatted)) * 24.0 * 60.0 * 60.0);  	float millis = (millisTemp - (int)millisTemp);  	s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  	s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  }  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: s = s.Replace ((L_BRACKET_SYMBOL).ToString ()' format3digit.Format (millis * 10));  
Magic Number,NPOI.SS.UserModel,ExcelStyleDateFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ExcelStyleDateFormatter.cs,Format,The following statement contains a magic number: s = s.Replace ((LL_BRACKET_SYMBOL).ToString ()' format4digits.Format (millis * 100));  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: if (_table == null) {  	_table = new FontCharset[256];  	_table [0] = FontCharset.ANSI;  	_table [1] = FontCharset.DEFAULT;  	_table [2] = FontCharset.SYMBOL;  	_table [77] = FontCharset.MAC;  	_table [128] = FontCharset.SHIFTJIS;  	_table [129] = FontCharset.HANGEUL;  	_table [130] = FontCharset.JOHAB;  	_table [134] = FontCharset.GB2312;  	_table [136] = FontCharset.CHINESEBIG5;  	_table [161] = FontCharset.GREEK;  	_table [162] = FontCharset.TURKISH;  	_table [163] = FontCharset.VIETNAMESE;  	_table [177] = FontCharset.HEBREW;  	_table [178] = FontCharset.ARABIC;  	_table [186] = FontCharset.BALTIC;  	_table [204] = FontCharset.RUSSIAN;  	_table [222] = FontCharset.THAI;  	_table [238] = FontCharset.EASTEUROPE;  	_table [255] = FontCharset.OEM;  }  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table = new FontCharset[256];  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [2] = FontCharset.SYMBOL;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [77] = FontCharset.MAC;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [128] = FontCharset.SHIFTJIS;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [129] = FontCharset.HANGEUL;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [130] = FontCharset.JOHAB;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [134] = FontCharset.GB2312;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [136] = FontCharset.CHINESEBIG5;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [161] = FontCharset.GREEK;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [162] = FontCharset.TURKISH;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [163] = FontCharset.VIETNAMESE;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [177] = FontCharset.HEBREW;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [178] = FontCharset.ARABIC;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [186] = FontCharset.BALTIC;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [204] = FontCharset.RUSSIAN;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [222] = FontCharset.THAI;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [238] = FontCharset.EASTEUROPE;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,FontCharset,The following statement contains a magic number: _table [255] = FontCharset.OEM;  
Magic Number,NPOI.SS.UserModel,FontCharset,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontCharset.cs,ValueOf,The following statement contains a magic number: if (value >= 0 && value <= 255)  	return _table [value];  
Magic Number,NPOI.SS.UserModel,FontFamily,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontFamily.cs,ValueOf,The following statement contains a magic number: switch (family) {  case 0:  	return NOT_APPLICABLE;  case 1:  	return ROMAN;  case 2:  	return SWISS;  case 3:  	return MODERN;  case 4:  	return SCRIPT;  case 5:  	return DECORATIVE;  }  
Magic Number,NPOI.SS.UserModel,FontFamily,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontFamily.cs,ValueOf,The following statement contains a magic number: switch (family) {  case 0:  	return NOT_APPLICABLE;  case 1:  	return ROMAN;  case 2:  	return SWISS;  case 3:  	return MODERN;  case 4:  	return SCRIPT;  case 5:  	return DECORATIVE;  }  
Magic Number,NPOI.SS.UserModel,FontFamily,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontFamily.cs,ValueOf,The following statement contains a magic number: switch (family) {  case 0:  	return NOT_APPLICABLE;  case 1:  	return ROMAN;  case 2:  	return SWISS;  case 3:  	return MODERN;  case 4:  	return SCRIPT;  case 5:  	return DECORATIVE;  }  
Magic Number,NPOI.SS.UserModel,FontFamily,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontFamily.cs,ValueOf,The following statement contains a magic number: switch (family) {  case 0:  	return NOT_APPLICABLE;  case 1:  	return ROMAN;  case 2:  	return SWISS;  case 3:  	return MODERN;  case 4:  	return SCRIPT;  case 5:  	return DECORATIVE;  }  
Magic Number,NPOI.SS.UserModel,FontScheme,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontScheme.cs,ValueOf,The following statement contains a magic number: switch (value) {  case 1:  	return NONE;  case 2:  	return MAJOR;  case 3:  	return MINOR;  }  
Magic Number,NPOI.SS.UserModel,FontScheme,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontScheme.cs,ValueOf,The following statement contains a magic number: switch (value) {  case 1:  	return NONE;  case 2:  	return MAJOR;  case 3:  	return MINOR;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: if (_table == null) {  	_table = new FontUnderline[6];  	_table [1] = FontUnderline.SINGLE;  	_table [2] = FontUnderline.DOUBLE;  	_table [3] = FontUnderline.SINGLE_ACCOUNTING;  	_table [4] = FontUnderline.DOUBLE_ACCOUNTING;  	_table [5] = FontUnderline.NONE;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: if (_table == null) {  	_table = new FontUnderline[6];  	_table [1] = FontUnderline.SINGLE;  	_table [2] = FontUnderline.DOUBLE;  	_table [3] = FontUnderline.SINGLE_ACCOUNTING;  	_table [4] = FontUnderline.DOUBLE_ACCOUNTING;  	_table [5] = FontUnderline.NONE;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: if (_table == null) {  	_table = new FontUnderline[6];  	_table [1] = FontUnderline.SINGLE;  	_table [2] = FontUnderline.DOUBLE;  	_table [3] = FontUnderline.SINGLE_ACCOUNTING;  	_table [4] = FontUnderline.DOUBLE_ACCOUNTING;  	_table [5] = FontUnderline.NONE;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: if (_table == null) {  	_table = new FontUnderline[6];  	_table [1] = FontUnderline.SINGLE;  	_table [2] = FontUnderline.DOUBLE;  	_table [3] = FontUnderline.SINGLE_ACCOUNTING;  	_table [4] = FontUnderline.DOUBLE_ACCOUNTING;  	_table [5] = FontUnderline.NONE;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: if (_table == null) {  	_table = new FontUnderline[6];  	_table [1] = FontUnderline.SINGLE;  	_table [2] = FontUnderline.DOUBLE;  	_table [3] = FontUnderline.SINGLE_ACCOUNTING;  	_table [4] = FontUnderline.DOUBLE_ACCOUNTING;  	_table [5] = FontUnderline.NONE;  }  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: _table = new FontUnderline[6];  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: _table [2] = FontUnderline.DOUBLE;  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: _table [3] = FontUnderline.SINGLE_ACCOUNTING;  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: _table [4] = FontUnderline.DOUBLE_ACCOUNTING;  
Magic Number,NPOI.SS.UserModel,FontUnderline,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontUnderline.cs,FontUnderline,The following statement contains a magic number: _table [5] = FontUnderline.NONE;  
Magic Number,NPOI.SS.UserModel,PageOrder,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PageOrder.cs,PageOrder,The following statement contains a magic number: _table = new PageOrder[3];  
Magic Number,NPOI.SS.UserModel,PageOrder,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PageOrder.cs,PageOrder,The following statement contains a magic number: OVER_THEN_DOWN = new PageOrder (2);  
Magic Number,NPOI.SS.UserModel,PrintCellComments,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintCellComments.cs,PrintCellComments,The following statement contains a magic number: _table = new PrintCellComments[4];  
Magic Number,NPOI.SS.UserModel,PrintCellComments,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintCellComments.cs,PrintCellComments,The following statement contains a magic number: AS_DISPLAYED = new PrintCellComments (2);  
Magic Number,NPOI.SS.UserModel,PrintCellComments,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintCellComments.cs,PrintCellComments,The following statement contains a magic number: AT_END = new PrintCellComments (3);  
Magic Number,NPOI.SS.UserModel,PrintOrientation,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintOrientation.cs,PrintOrientation,The following statement contains a magic number: _table = new PrintOrientation[4];  
Magic Number,NPOI.SS.UserModel,PrintOrientation,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintOrientation.cs,PrintOrientation,The following statement contains a magic number: PORTRAIT = new PrintOrientation (2);  
Magic Number,NPOI.SS.UserModel,PrintOrientation,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\PrintOrientation.cs,PrintOrientation,The following statement contains a magic number: LANDSCAPE = new PrintOrientation (3);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: zeros [63] = "000000000000000000000000000000000000000000000000000000000000000";  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < 63; i++)  	zeros [i] = zeros [63].Substring (0' i);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = 0; i < 63; i++)  	zeros [i] = zeros [63].Substring (0' i);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: zeros [i] = zeros [63].Substring (0' i);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: if (highWord == 0) {  	mag = new int[1];  	mag [0] = (int)val;  }  else {  	mag = new int[2];  	mag [0] = highWord;  	mag [1] = (int)val;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BigInteger,The following statement contains a magic number: mag = new int[2];  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: for (int i = len - 1; i >= 0; i--) {  	product = ylong * (x [i] & LONG_MASK) + carry;  	x [i] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: for (int i = len - 2; i >= 0; i--) {  	sum = (x [i] & LONG_MASK) + carry;  	x [i] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: for (int i = len - 2; i >= 0; i--) {  	sum = (x [i] & LONG_MASK) + carry;  	x [i] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,destructiveMulAdd,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < MIN_RADIX || radix > MAX_RADIX)  	radix = 10;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToString,The following statement contains a magic number: radix = 10;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToString,The following statement contains a magic number: if (radix != 10)  	throw new ArgumentException ("Only support 10 radix rendering");  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToString,The following statement contains a magic number: for (int i = numGroups - 2; i >= 0; i--) {  	// Prepend (any) leading zeros for this digit group  	int numLeadingZeros = digitsPerLong [radix] - digitGroup [i].Length;  	if (numLeadingZeros != 0)  		buf.Append (zeros [numLeadingZeros]);  	buf.Append (digitGroup [i]);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitLengthForInt,The following statement contains a magic number: return 32 - NumberOfLeadingZeros (n);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitLength,The following statement contains a magic number: if (n == -1) {  	// bitLength not initialized yet  	int[] m = mag;  	int len = m.Length;  	if (len == 0) {  		n = 0;  		// offset by one to initialize  	}  	else {  		// Calculate the bit length of the magnitude  		int magBitLength = ((len - 1) << 5) + BitLengthForInt (mag [0]);  		if (_signum < 0) {  			// Check if magnitude is a power of two  			bool pow2 = (BitCountForInt (mag [0]) == 1);  			for (int i = 1; i < len && pow2; i++)  				pow2 = (mag [i] == 0);  			n = (pow2 ? magBitLength - 1 : magBitLength);  		}  		else {  			n = magBitLength;  		}  	}  	bitLength = n + 1;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitLength,The following statement contains a magic number: if (len == 0) {  	n = 0;  	// offset by one to initialize  }  else {  	// Calculate the bit length of the magnitude  	int magBitLength = ((len - 1) << 5) + BitLengthForInt (mag [0]);  	if (_signum < 0) {  		// Check if magnitude is a power of two  		bool pow2 = (BitCountForInt (mag [0]) == 1);  		for (int i = 1; i < len && pow2; i++)  			pow2 = (mag [i] == 0);  		n = (pow2 ? magBitLength - 1 : magBitLength);  	}  	else {  		n = magBitLength;  	}  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCount,The following statement contains a magic number: if (bc == -1) {  	// bitCount not initialized yet  	bc = 0;  	// offset by one to initialize  	// Count the bits in the magnitude  	for (int i = 0; i < mag.Length; i++)  		bc += BitCountForInt (mag [i]);  	if (_signum < 0) {  		// Count the trailing zeros in the magnitude  		int magTrailingZeroCount = 0' j;  		for (j = mag.Length - 1; mag [j] == 0; j--)  			magTrailingZeroCount += 32;  		magTrailingZeroCount += NumberOfTrailingZeros (mag [j]);  		bc += magTrailingZeroCount - 1;  	}  	bitCount = bc + 1;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCount,The following statement contains a magic number: if (_signum < 0) {  	// Count the trailing zeros in the magnitude  	int magTrailingZeroCount = 0' j;  	for (j = mag.Length - 1; mag [j] == 0; j--)  		magTrailingZeroCount += 32;  	magTrailingZeroCount += NumberOfTrailingZeros (mag [j]);  	bc += magTrailingZeroCount - 1;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCount,The following statement contains a magic number: for (j = mag.Length - 1; mag [j] == 0; j--)  	magTrailingZeroCount += 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCount,The following statement contains a magic number: magTrailingZeroCount += 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The following statement contains a magic number: for (int j = ystart' k = ystart + 1 + xstart; j >= 0; j--' k--) {  	long product = (y [j] & LONG_MASK) * (x [xstart] & LONG_MASK) + carry;  	z [k] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The following statement contains a magic number: for (int i = xstart - 1; i >= 0; i--) {  	carry = 0;  	for (int j = ystart' k = ystart + 1 + i; j >= 0; j--' k--) {  		long product = (y [j] & LONG_MASK) * (x [i] & LONG_MASK) + (z [k] & LONG_MASK) + carry;  		z [k] = (int)product;  		carry = Operator.UnsignedRightShift (product' 32);  	}  	z [i] = (int)carry;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The following statement contains a magic number: for (int j = ystart' k = ystart + 1 + i; j >= 0; j--' k--) {  	long product = (y [j] & LONG_MASK) * (x [i] & LONG_MASK) + (z [k] & LONG_MASK) + carry;  	z [k] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiplyToLen,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulAdd,The following statement contains a magic number: for (int j = len - 1; j >= 0; j--) {  	long product = (input [j] & LONG_MASK) * kLong + (output [offset] & LONG_MASK) + carry;  	output [offset--] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulAdd,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: for (int j = 0' i = 0; j < len; j++) {  	long piece = (x [j] & LONG_MASK);  	long product = piece * piece;  	z [i++] = (lastProductLowWord << 31) | (int)Operator.UnsignedRightShift (product' 33);  	z [i++] = (int)Operator.UnsignedRightShift (product' 1);  	lastProductLowWord = (int)product;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: for (int j = 0' i = 0; j < len; j++) {  	long piece = (x [j] & LONG_MASK);  	long product = piece * piece;  	z [i++] = (lastProductLowWord << 31) | (int)Operator.UnsignedRightShift (product' 33);  	z [i++] = (int)Operator.UnsignedRightShift (product' 1);  	lastProductLowWord = (int)product;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: z [i++] = (lastProductLowWord << 31) | (int)Operator.UnsignedRightShift (product' 33);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: z [i++] = (lastProductLowWord << 31) | (int)Operator.UnsignedRightShift (product' 33);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: for (int i = len' offset = 1; i > 0; i--' offset += 2) {  	int t = x [i - 1];  	t = mulAdd (z' x' offset' i - 1' t);  	addOne (z' offset - 1' i' t);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,squareToLen,The following statement contains a magic number: offset += 2
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,addOne,The following statement contains a magic number: if ((t >> 32) == 0)  	return 0;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = byteLen - 1' bytesCopied = 4' nextInt = 0' intIndex = 0; i >= 0; i--) {  	if (bytesCopied == 4) {  		nextInt = getInt (intIndex++);  		bytesCopied = 1;  	}  	else {  		nextInt = Operator.UnsignedRightShift (nextInt' 8);  		bytesCopied++;  	}  	byteArray [i] = (byte)nextInt;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = byteLen - 1' bytesCopied = 4' nextInt = 0' intIndex = 0; i >= 0; i--) {  	if (bytesCopied == 4) {  		nextInt = getInt (intIndex++);  		bytesCopied = 1;  	}  	else {  		nextInt = Operator.UnsignedRightShift (nextInt' 8);  		bytesCopied++;  	}  	byteArray [i] = (byte)nextInt;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: for (int i = byteLen - 1' bytesCopied = 4' nextInt = 0' intIndex = 0; i >= 0; i--) {  	if (bytesCopied == 4) {  		nextInt = getInt (intIndex++);  		bytesCopied = 1;  	}  	else {  		nextInt = Operator.UnsignedRightShift (nextInt' 8);  		bytesCopied++;  	}  	byteArray [i] = (byte)nextInt;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (bytesCopied == 4) {  	nextInt = getInt (intIndex++);  	bytesCopied = 1;  }  else {  	nextInt = Operator.UnsignedRightShift (nextInt' 8);  	bytesCopied++;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (bytesCopied == 4) {  	nextInt = getInt (intIndex++);  	bytesCopied = 1;  }  else {  	nextInt = Operator.UnsignedRightShift (nextInt' 8);  	bytesCopied++;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ToByteArray,The following statement contains a magic number: nextInt = Operator.UnsignedRightShift (nextInt' 8);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,intLength,The following statement contains a magic number: return Operator.UnsignedRightShift (BitLength ()' 5) + 1;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,FirstNonzeroIntNum,The following statement contains a magic number: if (fn == -2) {  	// firstNonzeroIntNum not initialized yet  	fn = 0;  	// Search for the first nonzero int  	int i;  	int mlen = mag.Length;  	for (i = mlen - 1; i >= 0 && mag [i] == 0; i--)  		;  	fn = mlen - i - 1;  	firstNonzeroIntNum = fn + 2;  	// offset by two to initialize  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,FirstNonzeroIntNum,The following statement contains a magic number: if (fn == -2) {  	// firstNonzeroIntNum not initialized yet  	fn = 0;  	// Search for the first nonzero int  	int i;  	int mlen = mag.Length;  	for (i = mlen - 1; i >= 0 && mag [i] == 0; i--)  		;  	fn = mlen - i - 1;  	firstNonzeroIntNum = fn + 2;  	// offset by two to initialize  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,FirstNonzeroIntNum,The following statement contains a magic number: firstNonzeroIntNum = fn + 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int bytesRemaining = b - keep + 1;  	int bytesToTransfer = Math.Min (3' bytesRemaining);  	for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int bytesRemaining = b - keep + 1;  	int bytesToTransfer = Math.Min (3' bytesRemaining);  	for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int bytesRemaining = b - keep + 1;  	int bytesToTransfer = Math.Min (3' bytesRemaining);  	for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int bytesRemaining = b - keep + 1;  	int bytesToTransfer = Math.Min (3' bytesRemaining);  	for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: for (int j = 8; j <= (bytesToTransfer << 3); j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,stripLeadingZeroBytes,The following statement contains a magic number: j += 8
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int i = intLength - 1; i >= 0; i--) {  	result [i] = a [b--] & 0xff;  	int numBytesToTransfer = Math.Min (3' b - keep + 1);  	if (numBytesToTransfer < 0)  		numBytesToTransfer = 0;  	for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  		result [i] |= ((a [b--] & 0xff) << j);  	// Mask indicates which bits must be complemented  	int mask = Operator.UnsignedRightShift (-1' (8 * (3 - numBytesToTransfer)));  	result [i] = ~result [i] & mask;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: for (int j = 8; j <= 8 * numBytesToTransfer; j += 8)  	result [i] |= ((a [b--] & 0xff) << j);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,makePositive,The following statement contains a magic number: j += 8
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (i == 0)  	return 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: return 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 16) == 0) {  	n += 16;  	i <<= 16;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 16) == 0) {  	n += 16;  	i <<= 16;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 16) == 0) {  	n += 16;  	i <<= 16;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: n += 16;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: i <<= 16;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 24) == 0) {  	n += 8;  	i <<= 8;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 24) == 0) {  	n += 8;  	i <<= 8;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 24) == 0) {  	n += 8;  	i <<= 8;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: n += 8;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: i <<= 8;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 28) == 0) {  	n += 4;  	i <<= 4;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 28) == 0) {  	n += 4;  	i <<= 4;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 28) == 0) {  	n += 4;  	i <<= 4;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: n += 4;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: i <<= 4;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 30) == 0) {  	n += 2;  	i <<= 2;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 30) == 0) {  	n += 2;  	i <<= 2;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: if (Operator.UnsignedRightShift (i' 30) == 0) {  	n += 2;  	i <<= 2;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: n += 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: i <<= 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfLeadingZeros,The following statement contains a magic number: n -= Operator.UnsignedRightShift (i' 31);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: if (i == 0)  	return 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: return 32;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: y = i << 16;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: if (y != 0) {  	n = n - 16;  	i = y;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: n = n - 16;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: y = i << 8;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: if (y != 0) {  	n = n - 8;  	i = y;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: n = n - 8;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: y = i << 4;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: if (y != 0) {  	n = n - 4;  	i = y;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: n = n - 4;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: y = i << 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: if (y != 0) {  	n = n - 2;  	i = y;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: n = n - 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,NumberOfTrailingZeros,The following statement contains a magic number: return n - Operator.UnsignedRightShift ((i << 1)' 31);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCountForInt,The following statement contains a magic number: x = (x & 0x33333333) + ((x >> 2) & 0x33333333);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCountForInt,The following statement contains a magic number: x = (x + (x >> 4)) & 0x0f0f0f0f;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCountForInt,The following statement contains a magic number: x = x + (x >> 8);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,BitCountForInt,The following statement contains a magic number: x = x + (x >> 16);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < mag.Length; i++)  	hashCode = (int)(31 * hashCode + (mag [i] & LONG_MASK));  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,GetHashCode,The following statement contains a magic number: hashCode = (int)(31 * hashCode + (mag [i] & LONG_MASK));  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftLeft,The following statement contains a magic number: if (nBits == 0) {  	newMag = new int[magLen + nInts];  	for (int i = 0; i < magLen; i++)  		newMag [i] = mag [i];  }  else {  	int i = 0;  	int nBits2 = 32 - nBits;  	int highBits = Operator.UnsignedRightShift (mag [0]' nBits2);  	if (highBits != 0) {  		newMag = new int[magLen + nInts + 1];  		newMag [i++] = highBits;  	}  	else {  		newMag = new int[magLen + nInts];  	}  	int j = 0;  	while (j < magLen - 1)  		newMag [i++] = mag [j++] << nBits | Operator.UnsignedRightShift (mag [j]' nBits2);  	newMag [i] = mag [j] << nBits;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,LongValue,The following statement contains a magic number: for (int i = 1; i >= 0; i--)  	result = (result << 32) + (getInt (i) & LONG_MASK);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,LongValue,The following statement contains a magic number: result = (result << 32) + (getInt (i) & LONG_MASK);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftRight,The following statement contains a magic number: if (nBits == 0) {  	int newMagLen = magLen - nInts;  	newMag = new int[newMagLen];  	for (int i = 0; i < newMagLen; i++)  		newMag [i] = mag [i];  }  else {  	int i = 0;  	int highBits = Operator.UnsignedRightShift (mag [0]' nBits);  	if (highBits != 0) {  		newMag = new int[magLen - nInts];  		newMag [i++] = highBits;  	}  	else {  		newMag = new int[magLen - nInts - 1];  	}  	int nBits2 = 32 - nBits;  	int j = 0;  	while (j < magLen - nInts - 1)  		newMag [i++] = (mag [j++] << nBits2) | Operator.UnsignedRightShift (mag [j]' nBits);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftRight,The following statement contains a magic number: if (_signum < 0) {  	// Find out whether any one-bits were shifted off the end.  	bool onesLost = false;  	for (int i = magLen - 1' j = magLen - nInts; i >= j && !onesLost; i--)  		onesLost = (mag [i] != 0);  	if (!onesLost && nBits != 0)  		onesLost = (mag [magLen - nInts - 1] << (32 - nBits) != 0);  	if (onesLost)  		newMag = Increment (newMag);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftRight,The following statement contains a magic number: if (!onesLost && nBits != 0)  	onesLost = (mag [magLen - nInts - 1] << (32 - nBits) != 0);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,ShiftRight,The following statement contains a magic number: onesLost = (mag [magLen - nInts - 1] << (32 - nBits) != 0);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int i = xlen - 1; i >= 0; i--) {  	long product = (value [i] & LONG_MASK) * dl + carry;  	rmag [rstart--] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: if (dh != 0L) {  	carry = 0;  	rstart = rmag.Length - 2;  	for (int i = xlen - 1; i >= 0; i--) {  		long product = (value [i] & LONG_MASK) * dh + (rmag [rstart] & LONG_MASK) + carry;  		rmag [rstart--] = (int)product;  		carry = Operator.UnsignedRightShift (product' 32);  	}  	rmag [0] = (int)carry;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: if (dh != 0L) {  	carry = 0;  	rstart = rmag.Length - 2;  	for (int i = xlen - 1; i >= 0; i--) {  		long product = (value [i] & LONG_MASK) * dh + (rmag [rstart] & LONG_MASK) + carry;  		rmag [rstart--] = (int)product;  		carry = Operator.UnsignedRightShift (product' 32);  	}  	rmag [0] = (int)carry;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: rstart = rmag.Length - 2;  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int i = xlen - 1; i >= 0; i--) {  	long product = (value [i] & LONG_MASK) * dh + (rmag [rstart] & LONG_MASK) + carry;  	rmag [rstart--] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: while (yIndex > 0) {  	sum = (x [--xIndex] & LONG_MASK) + (y [--yIndex] & LONG_MASK) + Operator.UnsignedRightShift (sum' 32);  	result [xIndex] = (int)sum;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: sum = (x [--xIndex] & LONG_MASK) + (y [--yIndex] & LONG_MASK) + Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: while (littleIndex > 0) {  	difference = (big [--bigIndex] & LONG_MASK) - (little [--littleIndex] & LONG_MASK) + (difference >> 32);  	result [bigIndex] = (int)difference;  }  
Magic Number,NPOI.Util,BigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: difference = (big [--bigIndex] & LONG_MASK) - (little [--littleIndex] & LONG_MASK) + (difference >> 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,toLong,The following statement contains a magic number: Debug.Assert (intLen <= 2' "this MutableBigInteger exceeds the range of long");  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,toLong,The following statement contains a magic number: return (intLen == 2) ? d << 32 | (_value [offset + 1] & LONG_MASK) : d;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,toLong,The following statement contains a magic number: return (intLen == 2) ? d << 32 | (_value [offset + 1] & LONG_MASK) : d;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,compareHalf,The following statement contains a magic number: for (int i = offset' j = bstart; i < len + offset;) {  	int bv = bval [j++];  	long hb = (Operator.UnsignedRightShift (bv' 1) + carry) & LONG_MASK;  	long v = val [i++] & LONG_MASK;  	if (v != hb)  		return v < hb ? -1 : 1;  	carry = (bv & 1) << 31;  	// carray will be either 0x80000000 or 0  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,compareHalf,The following statement contains a magic number: carry = (bv & 1) << 31;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,getLowestSetBit,The following statement contains a magic number: return ((intLen - 1 - j) << 5) + BigInteger.NumberOfTrailingZeros (b);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,rightShift,The following statement contains a magic number: if (nBits >= bitsInHighWord) {  	this.primitiveLeftShift (32 - nBits);  	this.intLen--;  }  else {  	primitiveRightShift (nBits);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,rightShift,The following statement contains a magic number: this.primitiveLeftShift (32 - nBits);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,The following statement contains a magic number: if (n <= (32 - bitsInHighWord)) {  	primitiveLeftShift (nBits);  	return;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,The following statement contains a magic number: if (nBits <= (32 - bitsInHighWord))  	newLen--;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,The following statement contains a magic number: if (nBits <= (32 - bitsInHighWord))  	primitiveLeftShift (nBits);  else  	primitiveRightShift (32 - nBits);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,The following statement contains a magic number: if (nBits <= (32 - bitsInHighWord))  	primitiveLeftShift (nBits);  else  	primitiveRightShift (32 - nBits);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,leftShift,The following statement contains a magic number: primitiveRightShift (32 - nBits);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divadd,The following statement contains a magic number: for (int j = a.Length - 1; j >= 0; j--) {  	long sum = (a [j] & LONG_MASK) + (result [j + offset] & LONG_MASK) + carry;  	result [j + offset] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divadd,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulsub,The following statement contains a magic number: for (int j = len - 1; j >= 0; j--) {  	long product = (a [j] & LONG_MASK) * xLong + carry;  	long difference = q [offset] - product;  	q [offset--] = (int)difference;  	carry = Operator.UnsignedRightShift (product' 32) + (((difference & LONG_MASK) > (((~(int)product) & LONG_MASK))) ? 1 : 0);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mulsub,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32) + (((difference & LONG_MASK) > (((~(int)product) & LONG_MASK))) ? 1 : 0);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: while (x > 0 && y > 0) {  	x--;  	y--;  	sum = (_value [x + offset] & LONG_MASK) + (addend._value [y + addend.offset] & LONG_MASK) + carry;  	result [rstart--] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: while (x > 0) {  	x--;  	if (carry == 0 && result == _value && rstart == (x + offset))  		return;  	sum = (_value [x + offset] & LONG_MASK) + carry;  	result [rstart--] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: while (y > 0) {  	y--;  	sum = (addend._value [y + addend.offset] & LONG_MASK) + carry;  	result [rstart--] = (int)sum;  	carry = Operator.UnsignedRightShift (sum' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,add,The following statement contains a magic number: carry = Operator.UnsignedRightShift (sum' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: while (y > 0) {  	x--;  	y--;  	diff = (a._value [x + a.offset] & LONG_MASK) - (b._value [y + b.offset] & LONG_MASK) - ((int)-(diff >> 32));  	result [rstart--] = (int)diff;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: diff = (a._value [x + a.offset] & LONG_MASK) - (b._value [y + b.offset] & LONG_MASK) - ((int)-(diff >> 32));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: while (x > 0) {  	x--;  	diff = (a._value [x + a.offset] & LONG_MASK) - ((int)-(diff >> 32));  	result [rstart--] = (int)diff;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,subtract,The following statement contains a magic number: diff = (a._value [x + a.offset] & LONG_MASK) - ((int)-(diff >> 32));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,difference,The following statement contains a magic number: while (y > 0) {  	x--;  	y--;  	diff = (a._value [a.offset + x] & LONG_MASK) - (b._value [b.offset + y] & LONG_MASK) - ((int)-(diff >> 32));  	a._value [a.offset + x] = (int)diff;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,difference,The following statement contains a magic number: diff = (a._value [a.offset + x] & LONG_MASK) - (b._value [b.offset + y] & LONG_MASK) - ((int)-(diff >> 32));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,difference,The following statement contains a magic number: while (x > 0) {  	x--;  	diff = (a._value [a.offset + x] & LONG_MASK) - ((int)-(diff >> 32));  	a._value [a.offset + x] = (int)diff;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,difference,The following statement contains a magic number: diff = (a._value [a.offset + x] & LONG_MASK) - ((int)-(diff >> 32));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int j = yLen - 1' k = yLen + xLen - 1; j >= 0; j--' k--) {  	long product = (y._value [j + y.offset] & LONG_MASK) * (_value [xLen - 1 + offset] & LONG_MASK) + carry;  	z._value [k] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int i = xLen - 2; i >= 0; i--) {  	carry = 0;  	for (int j = yLen - 1' k = yLen + i; j >= 0; j--' k--) {  		long product = (y._value [j + y.offset] & LONG_MASK) * (_value [i + offset] & LONG_MASK) + (z._value [k] & LONG_MASK) + carry;  		z._value [k] = (int)product;  		carry = Operator.UnsignedRightShift (product' 32);  	}  	z._value [i] = (int)carry;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int i = xLen - 2; i >= 0; i--) {  	carry = 0;  	for (int j = yLen - 1' k = yLen + i; j >= 0; j--' k--) {  		long product = (y._value [j + y.offset] & LONG_MASK) * (_value [i + offset] & LONG_MASK) + (z._value [k] & LONG_MASK) + carry;  		z._value [k] = (int)product;  		carry = Operator.UnsignedRightShift (product' 32);  	}  	z._value [i] = (int)carry;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: for (int j = yLen - 1' k = yLen + i; j >= 0; j--' k--) {  	long product = (y._value [j + y.offset] & LONG_MASK) * (_value [i + offset] & LONG_MASK) + (z._value [k] & LONG_MASK) + carry;  	z._value [k] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,multiply,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mul,The following statement contains a magic number: for (int i = intLen - 1; i >= 0; i--) {  	long product = ylong * (_value [i + offset] & LONG_MASK) + carry;  	zval [i + 1] = (int)product;  	carry = Operator.UnsignedRightShift (product' 32);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,mul,The following statement contains a magic number: carry = Operator.UnsignedRightShift (product' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideOneWord,The following statement contains a magic number: while (--xlen > 0) {  	long dividendEstimate = (remLong << 32) | (_value [offset + intLen - xlen] & LONG_MASK);  	if (dividendEstimate >= 0) {  		qWord [0] = (int)(dividendEstimate / divisorLong);  		qWord [1] = (int)(dividendEstimate - qWord [0] * divisorLong);  	}  	else {  		divWord (qWord' dividendEstimate' divisor);  	}  	quotient._value [intLen - xlen] = qWord [0];  	rem = qWord [1];  	remLong = rem & LONG_MASK;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: for (int j = 0; j < limit; j++) {  	// D3 Calculate qhat  	// estimate qhat  	int qhat = 0;  	int qrem = 0;  	bool skipCorrection = false;  	int nh = rem._value [j + rem.offset];  	int nh2 = unchecked((int)(nh + 0x80000000));  	int nm = rem._value [j + 1 + rem.offset];  	if (nh == dh) {  		qhat = ~0;  		qrem = nh + nm;  		skipCorrection = qrem + 0x80000000 < nh2;  	}  	else {  		long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);  		if (nChunk >= 0) {  			qhat = (int)(nChunk / dhLong);  			qrem = (int)(nChunk - (qhat * dhLong));  		}  		else {  			divWord (qWord' nChunk' dh);  			qhat = qWord [0];  			qrem = qWord [1];  		}  	}  	if (qhat == 0)  		continue;  	if (!skipCorrection) {  		// Correct qhat  		long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  		long rs = ((qrem & LONG_MASK) << 32) | nl;  		long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  		if (unsignedLongCompare (estProduct' rs)) {  			qhat--;  			qrem = (int)((qrem & LONG_MASK) + dhLong);  			if ((qrem & LONG_MASK) >= dhLong) {  				estProduct -= (dl & LONG_MASK);  				rs = ((qrem & LONG_MASK) << 32) | nl;  				if (unsignedLongCompare (estProduct' rs))  					qhat--;  			}  		}  	}  	// D4 Multiply and subtract  	rem._value [j + rem.offset] = 0;  	int borrow = mulsub (rem._value' divisor' qhat' dlen' j + rem.offset);  	// D5 Test remainder  	if ((int)(borrow + 0x80000000) > nh2) {  		// D6 Add back  		divadd (divisor' rem._value' j + 1 + rem.offset);  		qhat--;  	}  	// Store the quotient digit  	q [j] = qhat;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: for (int j = 0; j < limit; j++) {  	// D3 Calculate qhat  	// estimate qhat  	int qhat = 0;  	int qrem = 0;  	bool skipCorrection = false;  	int nh = rem._value [j + rem.offset];  	int nh2 = unchecked((int)(nh + 0x80000000));  	int nm = rem._value [j + 1 + rem.offset];  	if (nh == dh) {  		qhat = ~0;  		qrem = nh + nm;  		skipCorrection = qrem + 0x80000000 < nh2;  	}  	else {  		long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);  		if (nChunk >= 0) {  			qhat = (int)(nChunk / dhLong);  			qrem = (int)(nChunk - (qhat * dhLong));  		}  		else {  			divWord (qWord' nChunk' dh);  			qhat = qWord [0];  			qrem = qWord [1];  		}  	}  	if (qhat == 0)  		continue;  	if (!skipCorrection) {  		// Correct qhat  		long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  		long rs = ((qrem & LONG_MASK) << 32) | nl;  		long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  		if (unsignedLongCompare (estProduct' rs)) {  			qhat--;  			qrem = (int)((qrem & LONG_MASK) + dhLong);  			if ((qrem & LONG_MASK) >= dhLong) {  				estProduct -= (dl & LONG_MASK);  				rs = ((qrem & LONG_MASK) << 32) | nl;  				if (unsignedLongCompare (estProduct' rs))  					qhat--;  			}  		}  	}  	// D4 Multiply and subtract  	rem._value [j + rem.offset] = 0;  	int borrow = mulsub (rem._value' divisor' qhat' dlen' j + rem.offset);  	// D5 Test remainder  	if ((int)(borrow + 0x80000000) > nh2) {  		// D6 Add back  		divadd (divisor' rem._value' j + 1 + rem.offset);  		qhat--;  	}  	// Store the quotient digit  	q [j] = qhat;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: for (int j = 0; j < limit; j++) {  	// D3 Calculate qhat  	// estimate qhat  	int qhat = 0;  	int qrem = 0;  	bool skipCorrection = false;  	int nh = rem._value [j + rem.offset];  	int nh2 = unchecked((int)(nh + 0x80000000));  	int nm = rem._value [j + 1 + rem.offset];  	if (nh == dh) {  		qhat = ~0;  		qrem = nh + nm;  		skipCorrection = qrem + 0x80000000 < nh2;  	}  	else {  		long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);  		if (nChunk >= 0) {  			qhat = (int)(nChunk / dhLong);  			qrem = (int)(nChunk - (qhat * dhLong));  		}  		else {  			divWord (qWord' nChunk' dh);  			qhat = qWord [0];  			qrem = qWord [1];  		}  	}  	if (qhat == 0)  		continue;  	if (!skipCorrection) {  		// Correct qhat  		long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  		long rs = ((qrem & LONG_MASK) << 32) | nl;  		long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  		if (unsignedLongCompare (estProduct' rs)) {  			qhat--;  			qrem = (int)((qrem & LONG_MASK) + dhLong);  			if ((qrem & LONG_MASK) >= dhLong) {  				estProduct -= (dl & LONG_MASK);  				rs = ((qrem & LONG_MASK) << 32) | nl;  				if (unsignedLongCompare (estProduct' rs))  					qhat--;  			}  		}  	}  	// D4 Multiply and subtract  	rem._value [j + rem.offset] = 0;  	int borrow = mulsub (rem._value' divisor' qhat' dlen' j + rem.offset);  	// D5 Test remainder  	if ((int)(borrow + 0x80000000) > nh2) {  		// D6 Add back  		divadd (divisor' rem._value' j + 1 + rem.offset);  		qhat--;  	}  	// Store the quotient digit  	q [j] = qhat;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: for (int j = 0; j < limit; j++) {  	// D3 Calculate qhat  	// estimate qhat  	int qhat = 0;  	int qrem = 0;  	bool skipCorrection = false;  	int nh = rem._value [j + rem.offset];  	int nh2 = unchecked((int)(nh + 0x80000000));  	int nm = rem._value [j + 1 + rem.offset];  	if (nh == dh) {  		qhat = ~0;  		qrem = nh + nm;  		skipCorrection = qrem + 0x80000000 < nh2;  	}  	else {  		long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);  		if (nChunk >= 0) {  			qhat = (int)(nChunk / dhLong);  			qrem = (int)(nChunk - (qhat * dhLong));  		}  		else {  			divWord (qWord' nChunk' dh);  			qhat = qWord [0];  			qrem = qWord [1];  		}  	}  	if (qhat == 0)  		continue;  	if (!skipCorrection) {  		// Correct qhat  		long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  		long rs = ((qrem & LONG_MASK) << 32) | nl;  		long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  		if (unsignedLongCompare (estProduct' rs)) {  			qhat--;  			qrem = (int)((qrem & LONG_MASK) + dhLong);  			if ((qrem & LONG_MASK) >= dhLong) {  				estProduct -= (dl & LONG_MASK);  				rs = ((qrem & LONG_MASK) << 32) | nl;  				if (unsignedLongCompare (estProduct' rs))  					qhat--;  			}  		}  	}  	// D4 Multiply and subtract  	rem._value [j + rem.offset] = 0;  	int borrow = mulsub (rem._value' divisor' qhat' dlen' j + rem.offset);  	// D5 Test remainder  	if ((int)(borrow + 0x80000000) > nh2) {  		// D6 Add back  		divadd (divisor' rem._value' j + 1 + rem.offset);  		qhat--;  	}  	// Store the quotient digit  	q [j] = qhat;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if (nh == dh) {  	qhat = ~0;  	qrem = nh + nm;  	skipCorrection = qrem + 0x80000000 < nh2;  }  else {  	long nChunk = (((long)nh) << 32) | (nm & LONG_MASK);  	if (nChunk >= 0) {  		qhat = (int)(nChunk / dhLong);  		qrem = (int)(nChunk - (qhat * dhLong));  	}  	else {  		divWord (qWord' nChunk' dh);  		qhat = qWord [0];  		qrem = qWord [1];  	}  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if (!skipCorrection) {  	// Correct qhat  	long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  	long rs = ((qrem & LONG_MASK) << 32) | nl;  	long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  	if (unsignedLongCompare (estProduct' rs)) {  		qhat--;  		qrem = (int)((qrem & LONG_MASK) + dhLong);  		if ((qrem & LONG_MASK) >= dhLong) {  			estProduct -= (dl & LONG_MASK);  			rs = ((qrem & LONG_MASK) << 32) | nl;  			if (unsignedLongCompare (estProduct' rs))  				qhat--;  		}  	}  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if (!skipCorrection) {  	// Correct qhat  	long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  	long rs = ((qrem & LONG_MASK) << 32) | nl;  	long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  	if (unsignedLongCompare (estProduct' rs)) {  		qhat--;  		qrem = (int)((qrem & LONG_MASK) + dhLong);  		if ((qrem & LONG_MASK) >= dhLong) {  			estProduct -= (dl & LONG_MASK);  			rs = ((qrem & LONG_MASK) << 32) | nl;  			if (unsignedLongCompare (estProduct' rs))  				qhat--;  		}  	}  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if (!skipCorrection) {  	// Correct qhat  	long nl = rem._value [j + 2 + rem.offset] & LONG_MASK;  	long rs = ((qrem & LONG_MASK) << 32) | nl;  	long estProduct = (dl & LONG_MASK) * (qhat & LONG_MASK);  	if (unsignedLongCompare (estProduct' rs)) {  		qhat--;  		qrem = (int)((qrem & LONG_MASK) + dhLong);  		if ((qrem & LONG_MASK) >= dhLong) {  			estProduct -= (dl & LONG_MASK);  			rs = ((qrem & LONG_MASK) << 32) | nl;  			if (unsignedLongCompare (estProduct' rs))  				qhat--;  		}  	}  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if (unsignedLongCompare (estProduct' rs)) {  	qhat--;  	qrem = (int)((qrem & LONG_MASK) + dhLong);  	if ((qrem & LONG_MASK) >= dhLong) {  		estProduct -= (dl & LONG_MASK);  		rs = ((qrem & LONG_MASK) << 32) | nl;  		if (unsignedLongCompare (estProduct' rs))  			qhat--;  	}  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: if ((qrem & LONG_MASK) >= dhLong) {  	estProduct -= (dl & LONG_MASK);  	rs = ((qrem & LONG_MASK) << 32) | nl;  	if (unsignedLongCompare (estProduct' rs))  		qhat--;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,divideMagnitude,The following statement contains a magic number: rs = ((qrem & LONG_MASK) << 32) | nl;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,hybridGCD,The following statement contains a magic number: while (b.intLen != 0) {  	if (Math.Abs (a.intLen - b.intLen) < 2)  		return a.binaryGCD (b);  	MutableBigInteger r = a.divide (b' q);  	a = b;  	b = r;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,hybridGCD,The following statement contains a magic number: if (Math.Abs (a.intLen - b.intLen) < 2)  	return a.binaryGCD (b);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,binaryGCD,The following statement contains a magic number: while ((lb = t.getLowestSetBit ()) >= 0) {  	// steps B3 and B4  	t.rightShift (lb);  	// step B5  	if (tsign > 0)  		u = t;  	else  		v = t;  	// Special case one word numbers  	if (u.intLen < 2 && v.intLen < 2) {  		int x = u._value [u.offset];  		int y = v._value [v.offset];  		x = binaryGcd (x' y);  		r._value [0] = x;  		r.intLen = 1;  		r.offset = 0;  		if (k > 0)  			r.leftShift (k);  		return r;  	}  	// step B6  	if ((tsign = u.difference (v)) == 0)  		break;  	t = (tsign >= 0) ? u : v;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,binaryGCD,The following statement contains a magic number: while ((lb = t.getLowestSetBit ()) >= 0) {  	// steps B3 and B4  	t.rightShift (lb);  	// step B5  	if (tsign > 0)  		u = t;  	else  		v = t;  	// Special case one word numbers  	if (u.intLen < 2 && v.intLen < 2) {  		int x = u._value [u.offset];  		int y = v._value [v.offset];  		x = binaryGcd (x' y);  		r._value [0] = x;  		r.intLen = 1;  		r.offset = 0;  		if (k > 0)  			r.leftShift (k);  		return r;  	}  	// step B6  	if ((tsign = u.difference (v)) == 0)  		break;  	t = (tsign >= 0) ? u : v;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,binaryGCD,The following statement contains a magic number: if (u.intLen < 2 && v.intLen < 2) {  	int x = u._value [u.offset];  	int y = v._value [v.offset];  	x = binaryGcd (x' y);  	r._value [0] = x;  	r.intLen = 1;  	r.offset = 0;  	if (k > 0)  		r.leftShift (k);  	return r;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,binaryGCD,The following statement contains a magic number: if (u.intLen < 2 && v.intLen < 2) {  	int x = u._value [u.offset];  	int y = v._value [v.offset];  	x = binaryGcd (x' y);  	r._value [0] = x;  	r.intLen = 1;  	r.offset = 0;  	if (k > 0)  		r.leftShift (k);  	return r;  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: if (k > 64)  	return euclidModInverse (k);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: if (k < 33) {  	t = (k == 32 ? t : t & ((1 << k) - 1));  	return new MutableBigInteger (t);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: if (k < 33) {  	t = (k == 32 ? t : t & ((1 << k) - 1));  	return new MutableBigInteger (t);  }  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: t = (k == 32 ? t : t & ((1 << k) - 1));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: if (intLen > 1)  	pLong |= ((long)_value [offset + intLen - 2] << 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: if (intLen > 1)  	pLong |= ((long)_value [offset + intLen - 2] << 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: pLong |= ((long)_value [offset + intLen - 2] << 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: pLong |= ((long)_value [offset + intLen - 2] << 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: tLong = tLong * (2 - pLong * tLong);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: tLong = (k == 64 ? tLong : tLong & ((1L << k) - 1));  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: result._value [0] = (int)Operator.UnsignedRightShift (tLong' 32);  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,modInverseMP2,The following statement contains a magic number: result.intLen = 2;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,inverseMod32,The following statement contains a magic number: t *= 2 - val * t;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,inverseMod32,The following statement contains a magic number: t *= 2 - val * t;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,inverseMod32,The following statement contains a magic number: t *= 2 - val * t;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,inverseMod32,The following statement contains a magic number: t *= 2 - val * t;  
Magic Number,NPOI.Util,MutableBigInteger,C:\repos\xoposhiy_npoi\trunk\main\Util\BigInteger.cs,fixup,The following statement contains a magic number: for (int i = 0' numWords = k >> 5; i < numWords; i++) {  	// V = R * c (mod 2^j)  	int v = r * c._value [c.offset + c.intLen - 1];  	// c = c + (v * p)  	p.mul (v' temp);  	c.add (temp);  	// c = c / 2^j  	c.intLen--;  }  
Magic Number,NPOI.Util,Character,C:\repos\xoposhiy_npoi\trunk\main\Util\Character.cs,GetNumericValue,The following statement contains a magic number: if (src >= 'A' && src <= 'Z') {  	return ((int)src) - 55;  }  
Magic Number,NPOI.Util,Character,C:\repos\xoposhiy_npoi\trunk\main\Util\Character.cs,GetNumericValue,The following statement contains a magic number: return ((int)src) - 55;  
Magic Number,NPOI.Util,Character,C:\repos\xoposhiy_npoi\trunk\main\Util\Character.cs,GetNumericValue,The following statement contains a magic number: if (src >= 'a' && src <= 'z') {  	return ((int)src) - 87;  }  
Magic Number,NPOI.Util,Character,C:\repos\xoposhiy_npoi\trunk\main\Util\Character.cs,GetNumericValue,The following statement contains a magic number: return ((int)src) - 87;  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes = new byte[16];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [0] = src [3 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [1] = src [2 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [2] = src [1 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [3] = src [0 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [4] = src [5 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [4] = src [5 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [5] = src [4 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [5] = src [4 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [6] = src [7 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [6] = src [7 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [7] = src [6 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: bytes [7] = src [6 + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: for (int i = 8; i < 16; i++)  	bytes [i] = src [i + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Read,The following statement contains a magic number: for (int i = 8; i < 16; i++)  	bytes [i] = src [i + offset];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: if (dst.Length < 16)  	throw new ArrayTypeMismatchException ("Destination byte[] must have room for at least 16 bytes' " + "but has a length of only " + dst.Length + ".");  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [0 + offset] = bytes [3];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [1 + offset] = bytes [2];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [2 + offset] = bytes [1];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [3 + offset] = bytes [0];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [4 + offset] = bytes [5];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [4 + offset] = bytes [5];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [5 + offset] = bytes [4];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [5 + offset] = bytes [4];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [6 + offset] = bytes [7];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [6 + offset] = bytes [7];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [7 + offset] = bytes [6];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: dst [7 + offset] = bytes [6];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: for (int i = 8; i < 16; i++)  	dst [i + offset] = bytes [i];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,Write,The following statement contains a magic number: for (int i = 8; i < 16; i++)  	dst [i + offset] = bytes [i];  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	sbClassId.Append (HexDump.ToHex (bytes [i]));  	if (i == 3 || i == 5 || i == 7 || i == 9)  		sbClassId.Append ('-');  }  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	sbClassId.Append (HexDump.ToHex (bytes [i]));  	if (i == 3 || i == 5 || i == 7 || i == 9)  		sbClassId.Append ('-');  }  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	sbClassId.Append (HexDump.ToHex (bytes [i]));  	if (i == 3 || i == 5 || i == 7 || i == 9)  		sbClassId.Append ('-');  }  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	sbClassId.Append (HexDump.ToHex (bytes [i]));  	if (i == 3 || i == 5 || i == 7 || i == 9)  		sbClassId.Append ('-');  }  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	sbClassId.Append (HexDump.ToHex (bytes [i]));  	if (i == 3 || i == 5 || i == 7 || i == 9)  		sbClassId.Append ('-');  }  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: if (i == 3 || i == 5 || i == 7 || i == 9)  	sbClassId.Append ('-');  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: if (i == 3 || i == 5 || i == 7 || i == 9)  	sbClassId.Append ('-');  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: if (i == 3 || i == 5 || i == 7 || i == 9)  	sbClassId.Append ('-');  
Magic Number,NPOI.Util,ClassID,C:\repos\xoposhiy_npoi\trunk\main\Util\ClassID.cs,ToString,The following statement contains a magic number: if (i == 3 || i == 5 || i == 7 || i == 9)  	sbClassId.Append ('-');  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,CRC32,The following statement contains a magic number: crc32Table = new ulong[256];  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,CRC32,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	dwCrc = (ulong)i;  	for (j = 8; j > 0; j--) {  		if ((dwCrc & 1) == 1)  			dwCrc = (dwCrc >> 1) ^ ulPolynomial;  		else  			dwCrc >>= 1;  	}  	crc32Table [i] = dwCrc;  }  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,CRC32,The following statement contains a magic number: for (i = 0; i < 256; i++) {  	dwCrc = (ulong)i;  	for (j = 8; j > 0; j--) {  		if ((dwCrc & 1) == 1)  			dwCrc = (dwCrc >> 1) ^ ulPolynomial;  		else  			dwCrc >>= 1;  	}  	crc32Table [i] = dwCrc;  }  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,CRC32,The following statement contains a magic number: for (j = 8; j > 0; j--) {  	if ((dwCrc & 1) == 1)  		dwCrc = (dwCrc >> 1) ^ ulPolynomial;  	else  		dwCrc >>= 1;  }  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,CRC32,The following statement contains a magic number: j = 8
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,ByteCRC,The following statement contains a magic number: for (ulong buffptr = 0; buffptr < len; buffptr++) {  	ulong tabPtr = ulCRC & 0xFF;  	tabPtr = tabPtr ^ buffer [buffptr];  	ulCRC = ulCRC >> 8;  	ulCRC = ulCRC ^ crc32Table [tabPtr];  }  
Magic Number,NPOI.Util,CRC32,C:\repos\xoposhiy_npoi\trunk\main\Util\CRC32.cs,ByteCRC,The following statement contains a magic number: ulCRC = ulCRC >> 8;  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	buffer.Append (_hexcodes [(value >> _shifts [i + 6]) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	buffer.Append (_hexcodes [(value >> _shifts [i + 6]) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	buffer.Append (_hexcodes [(value >> _shifts [i + 6]) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: buffer.Append (_hexcodes [(value >> _shifts [i + 6]) & 15]);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: buffer.Append (_hexcodes [(value >> _shifts [i + 6]) & 15]);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	buffer.Append (_hexcodes [((int)(value >> _shifts [i + _shifts.Length - 8])) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	buffer.Append (_hexcodes [((int)(value >> _shifts [i + _shifts.Length - 8])) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	buffer.Append (_hexcodes [((int)(value >> _shifts [i + _shifts.Length - 8])) & 15]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: buffer.Append (_hexcodes [((int)(value >> _shifts [i + _shifts.Length - 8])) & 15]);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: buffer.Append (_hexcodes [((int)(value >> _shifts [i + _shifts.Length - 8])) & 15]);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data.Length; i += 16) {  	int chars_read = data.Length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data.Length; i += 16) {  	int chars_read = data.Length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data.Length; i += 16) {  	int chars_read = data.Length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data.Length; i += 16) {  	int chars_read = data.Length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data.Length; i += 16) {  	int chars_read = data.Length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: i += 16
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (chars_read > 16) {  	chars_read = 16;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (chars_read > 16) {  	chars_read = 16;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: chars_read = 16;  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	if (j < chars_read) {  		buffer.Append (Dump (data [j + i]));  	}  	else {  		buffer.Append ("  ");  	}  	buffer.Append (' ');  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int k = 0; k < chars_read; k++) {  	if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  		buffer.Append ((char)data [k + i]);  	}  	else {  		buffer.Append ('.');  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  	buffer.Append ((char)data [k + i]);  }  else {  	buffer.Append ('.');  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (data.Length != 0) {  	long display_offset = offset + index;  	StringBuilder buffer = new StringBuilder (74);  	int data_length = Math.Min (data.Length' index + length);  	for (int i = index; i < data_length; i += 16) {  		int chars_read = data_length - i;  		if (chars_read > 16) {  			chars_read = 16;  		}  		buffer.Append (Dump (display_offset)).Append (' ');  		for (int j = 0; j < 16; j++) {  			if (j < chars_read) {  				buffer.Append (Dump (data [j + i]));  			}  			else {  				buffer.Append ("  ");  			}  			buffer.Append (' ');  		}  		for (int k = 0; k < chars_read; k++) {  			if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  				buffer.Append ((char)data [k + i]);  			}  			else {  				buffer.Append ('.');  			}  		}  		buffer.Append (EOL);  		byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  		if (stream != null) {  			//Console.Write(buffer.ToString());  			stream.Write (bytes' 0' bytes.Length);  			// Console.Write(Encoding.UTF8.GetString(bytes));  			stream.Flush ();  		}  		buffer.Length = 0;  		display_offset += chars_read;  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data_length; i += 16) {  	int chars_read = data_length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  	if (stream != null) {  		//Console.Write(buffer.ToString());  		stream.Write (bytes' 0' bytes.Length);  		// Console.Write(Encoding.UTF8.GetString(bytes));  		stream.Flush ();  	}  	buffer.Length = 0;  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data_length; i += 16) {  	int chars_read = data_length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  	if (stream != null) {  		//Console.Write(buffer.ToString());  		stream.Write (bytes' 0' bytes.Length);  		// Console.Write(Encoding.UTF8.GetString(bytes));  		stream.Flush ();  	}  	buffer.Length = 0;  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data_length; i += 16) {  	int chars_read = data_length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  	if (stream != null) {  		//Console.Write(buffer.ToString());  		stream.Write (bytes' 0' bytes.Length);  		// Console.Write(Encoding.UTF8.GetString(bytes));  		stream.Flush ();  	}  	buffer.Length = 0;  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data_length; i += 16) {  	int chars_read = data_length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  	if (stream != null) {  		//Console.Write(buffer.ToString());  		stream.Write (bytes' 0' bytes.Length);  		// Console.Write(Encoding.UTF8.GetString(bytes));  		stream.Flush ();  	}  	buffer.Length = 0;  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int i = index; i < data_length; i += 16) {  	int chars_read = data_length - i;  	if (chars_read > 16) {  		chars_read = 16;  	}  	buffer.Append (Dump (display_offset)).Append (' ');  	for (int j = 0; j < 16; j++) {  		if (j < chars_read) {  			buffer.Append (Dump (data [j + i]));  		}  		else {  			buffer.Append ("  ");  		}  		buffer.Append (' ');  	}  	for (int k = 0; k < chars_read; k++) {  		if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  			buffer.Append ((char)data [k + i]);  		}  		else {  			buffer.Append ('.');  		}  	}  	buffer.Append (EOL);  	byte[] bytes = Encoding.UTF8.GetBytes (buffer.ToString ());  	if (stream != null) {  		//Console.Write(buffer.ToString());  		stream.Write (bytes' 0' bytes.Length);  		// Console.Write(Encoding.UTF8.GetString(bytes));  		stream.Flush ();  	}  	buffer.Length = 0;  	display_offset += chars_read;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: i += 16
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (chars_read > 16) {  	chars_read = 16;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if (chars_read > 16) {  	chars_read = 16;  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: chars_read = 16;  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int j = 0; j < 16; j++) {  	if (j < chars_read) {  		buffer.Append (Dump (data [j + i]));  	}  	else {  		buffer.Append ("  ");  	}  	buffer.Append (' ');  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: for (int k = 0; k < chars_read; k++) {  	if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  		buffer.Append ((char)data [k + i]);  	}  	else {  		buffer.Append ('.');  	}  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,Dump,The following statement contains a magic number: if ((data [k + i] >= ' ') && (data [k + i] < 127)) {  	buffer.Append ((char)data [k + i]);  }  else {  	buffer.Append ('.');  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ShortToHex,The following statement contains a magic number: return ToHexChars (value' 2);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,IntToHex,The following statement contains a magic number: return ToHexChars (value' 4);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,LongToHex,The following statement contains a magic number: return ToHexChars (value' 8);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHexChars,The following statement contains a magic number: do {  	result [--charPos] = _hexcodes [(int)(value & 0x0F)];  	value >>= 4;  }  while (charPos > 1);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHexChars,The following statement contains a magic number: value >>= 4;  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: return ToHex ((long)value' 2);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: return ToHex ((long)value' 4);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: return ToHex ((long)value' 8);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: return ToHex (value' 16);  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: for (int i = 0; i < digits; i++) {  	buffer.Append (_hexcodes [(int)((value >> _shifts [i + (16 - digits)]) & 15L)]);  }  
Magic Number,NPOI.Util,HexDump,C:\repos\xoposhiy_npoi\trunk\main\Util\HexDump.cs,ToHex,The following statement contains a magic number: buffer.Append (_hexcodes [(int)((value >> _shifts [i + (16 - digits)]) & 15L)]);  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: while (!done) {  	int count = stream.ReadByte ();  	char baseChar = 'a';  	if (count == eofChar)  		break;  	switch (count) {  	case '#':  		ReadToEOL (stream);  		break;  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		b <<= 4;  		b += (byte)(count - '0');  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		baseChar = 'A';  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		b <<= 4;  		b += (byte)(count + 10 - baseChar);  		characterCount++;  		if (characterCount == 2) {  			bytes.Add ((byte)b);  			characterCount = 0;  			b = (byte)0;  		}  		break;  	case -1:  		done = true;  		break;  	default:  		break;  	}  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: switch (count) {  case '#':  	ReadToEOL (stream);  	break;  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b <<= 4;  	b += (byte)(count - '0');  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	baseChar = 'A';  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	b <<= 4;  	b += (byte)(count + 10 - baseChar);  	characterCount++;  	if (characterCount == 2) {  		bytes.Add ((byte)b);  		characterCount = 0;  		b = (byte)0;  	}  	break;  case -1:  	done = true;  	break;  default:  	break;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: b <<= 4;  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: if (characterCount == 2) {  	bytes.Add ((byte)b);  	characterCount = 0;  	b = (byte)0;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: b <<= 4;  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: b += (byte)(count + 10 - baseChar);  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: if (characterCount == 2) {  	bytes.Add ((byte)b);  	characterCount = 0;  	b = (byte)0;  }  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: b <<= 4;  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: b += (byte)(count + 10 - baseChar);  
Magic Number,NPOI.Util,HexRead,C:\repos\xoposhiy_npoi\trunk\main\Util\HexRead.cs,ReadData,The following statement contains a magic number: if (characterCount == 2) {  	bytes.Add ((byte)b);  	characterCount = 0;  	b = (byte)0;  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: if (index > _limit) {  	throw new IndexOutOfRangeException ();  }  else if (index == _limit) {  	Add (value);  }  else {  	// index < limit -- insert into the middle  	if (_limit == _array.Length) {  		growArray (_limit * 2);  	}  	Array.Copy (_array' index' _array' index + 1' _limit - index);  	_array [index] = value;  	_limit++;  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: if (index == _limit) {  	Add (value);  }  else {  	// index < limit -- insert into the middle  	if (_limit == _array.Length) {  		growArray (_limit * 2);  	}  	Array.Copy (_array' index' _array' index + 1' _limit - index);  	_array [index] = value;  	_limit++;  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: if (_limit == _array.Length) {  	growArray (_limit * 2);  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: growArray (_limit * 2);  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: if (_limit == _array.Length) {  	growArray (_limit * 2);  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,Add,The following statement contains a magic number: growArray (_limit * 2);  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,GetHashCode,The following statement contains a magic number: for (int j = 0; j < _limit; j++) {  	hash = (31 * hash) + _array [j];  }  
Magic Number,NPOI.Util,IntList,C:\repos\xoposhiy_npoi\trunk\main\Util\IntList.cs,GetHashCode,The following statement contains a magic number: hash = (31 * hash) + _array [j];  
Magic Number,NPOI.Util,IOUtils,C:\repos\xoposhiy_npoi\trunk\main\Util\IOUtils.cs,ToByteArray,The following statement contains a magic number: using (MemoryStream baos = new MemoryStream ()) {  	byte[] buffer = new byte[4096];  	int read = -2;  	while (read != -1 && read != 0) {  		read = stream.Read (buffer' 0' buffer.Length);  		if (read > 0) {  			baos.Write (buffer' 0' read);  		}  	}  	return baos.ToArray ();  }  
Magic Number,NPOI.Util,IOUtils,C:\repos\xoposhiy_npoi\trunk\main\Util\IOUtils.cs,ToByteArray,The following statement contains a magic number: using (MemoryStream baos = new MemoryStream ()) {  	byte[] buffer = new byte[4096];  	int read = -2;  	while (read != -1 && read != 0) {  		read = stream.Read (buffer' 0' buffer.Length);  		if (read > 0) {  			baos.Write (buffer' 0' read);  		}  	}  	return baos.ToArray ();  }  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadInt,The following statement contains a magic number: CheckPosition (4);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: CheckPosition (8);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadUShort,The following statement contains a magic number: CheckPosition (2);  
Magic Number,NPOI.Util,LittleEndianByteArrayInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayInputStream.cs,ReadUShort,The following statement contains a magic number: return (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteInt,The following statement contains a magic number: CheckPosition (4);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteInt,The following statement contains a magic number: _buf [i++] = (byte)((v >> 8) & 0xFF);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteInt,The following statement contains a magic number: _buf [i++] = (byte)((v >> 16) & 0xFF);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteInt,The following statement contains a magic number: _buf [i++] = (byte)((v >> 24) & 0xFF);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteLong,The following statement contains a magic number: WriteInt ((int)(v >> 32));  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteShort,The following statement contains a magic number: CheckPosition (2);  
Magic Number,NPOI.Util,LittleEndianByteArrayOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianByteArrayOutputStream.cs,WriteShort,The following statement contains a magic number: _buf [i++] = (byte)((v >> 8) & 0xFF);  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadLong,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndianInputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianInputStream.cs,ReadUShort,The following statement contains a magic number: return (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndianOutputStream,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndianOutputStream.cs,WriteLong,The following statement contains a magic number: WriteInt ((int)(v >> 32));  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetShort,The following statement contains a magic number: return (short)((b1 << 8) + (b0 << 0));  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetUShort,The following statement contains a magic number: return (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetInt,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetLong,The following statement contains a magic number: for (int j = offset + LONG_SIZE - 1; j >= offset; j--) {  	result <<= 8;  	result |= 0xffL & data [j];  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetLong,The following statement contains a magic number: result <<= 8;  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutShort,The following statement contains a magic number: data [i++] = (byte)((value >> 8) & 0xFF);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutUShort,The following statement contains a magic number: data [i++] = (byte)((value >> 8) & 0xFF);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutInt,The following statement contains a magic number: data [i++] = (byte)((value >> 8) & 0xFF);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutInt,The following statement contains a magic number: data [i++] = (byte)((value >> 16) & 0xFF);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutInt,The following statement contains a magic number: data [i++] = (byte)((value >> 24) & 0xFF);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutLong,The following statement contains a magic number: for (int j = offset; j < limit; j++) {  	data [j] = (byte)(v & 0xFF);  	v >>= 8;  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutLong,The following statement contains a magic number: v >>= 8;  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadUShort,The following statement contains a magic number: return (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadInt,The following statement contains a magic number: return (ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,ReadLong,The following statement contains a magic number: return ((long)ch8 << 56) + ((long)ch7 << 48) + ((long)ch6 << 40) + ((long)ch5 << 32) + ((long)ch4 << 24) + // cast to long to preserve bit 31 (sign bit for ints)  (ch3 << 16) + (ch2 << 8) + (ch1 << 0);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetNumber,The following statement contains a magic number: for (int i = (offset + size) - 1; i >= offset; i--) {  	num = num << 8;  	num |= 0xffL & data [i];  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,GetNumber,The following statement contains a magic number: num = num << 8;  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutNumber,The following statement contains a magic number: for (int i = offset; i < limit; i++) {  	data [i] = (byte)(v & 0xffL);  	v >>= 8;  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutNumber,The following statement contains a magic number: v >>= 8;  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutNumber,The following statement contains a magic number: for (int i = offset; i < limit; i++) {  	data [i] = (byte)(v & 0xffL);  	v >>= 8;  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutNumber,The following statement contains a magic number: v >>= 8;  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutShortArray,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  	PutNumber (data' (offset + 2) + (i * 2)' Convert.ToInt64 (value [i])' LittleEndianConsts.SHORT_SIZE);  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutShortArray,The following statement contains a magic number: for (int i = 0; i < value.Length; i++) {  	PutNumber (data' (offset + 2) + (i * 2)' Convert.ToInt64 (value [i])' LittleEndianConsts.SHORT_SIZE);  }  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutShortArray,The following statement contains a magic number: PutNumber (data' (offset + 2) + (i * 2)' Convert.ToInt64 (value [i])' LittleEndianConsts.SHORT_SIZE);  
Magic Number,NPOI.Util,LittleEndian,C:\repos\xoposhiy_npoi\trunk\main\Util\LittleEndian.cs,PutShortArray,The following statement contains a magic number: PutNumber (data' (offset + 2) + (i * 2)' Convert.ToInt64 (value [i])' LittleEndianConsts.SHORT_SIZE);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: while ((flag = src.ReadByte ()) != -1) {  	// Compare each bit in our flag byte in turn:  	for (mask = 1; mask < 256; mask <<= 1) {  		// Is this a new code (un-compressed)' or  		//  the use of existing codes (compressed)?  		bool IsMaskSet = (flag & mask) > 0;  		if (IsMaskSet ^ maskMeansCompressed) {  			// Retrieve the un-compressed code  			if ((dataI = src.ReadByte ()) != -1) {  				// Save the byte into the dictionary  				buffer [(pos & 4095)] = fromInt (dataI);  				pos++;  				// And output the byte  				res.WriteByte (fromInt (dataI));  				//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  			}  		}  		else {  			// We have a compressed sequence  			// Grab the next 16 bits of data  			dataIPt1 = src.ReadByte ();  			dataIPt2 = src.ReadByte ();  			if (dataIPt1 == -1 || dataIPt2 == -1)  				break;  			// Build up how long the code sequence is' and  			//  what position of the code to start at  			// (The position is the usually the first 12 bits'   			//  and the length is usually the last 4 bits)  			len = (dataIPt2 & 15) + codeLengthIncrease;  			if (positionIsBigEndian) {  				pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  			}  			else {  				pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  			}  			// Adjust the pointer as needed  			pntr = adjustDictionaryOffset (pntr);  			// Loop over the codes' outputting what they correspond to  			for (int i = 0; i < len; i++) {  				dataB [i] = buffer [(pntr + i) & 4095];  				buffer [(pos + i) & 4095] = dataB [i];  			}  			res.Write (dataB' 0' len);  			// Record how far along the stream we have Moved  			pos = pos + len;  		}  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (mask = 1; mask < 256; mask <<= 1) {  	// Is this a new code (un-compressed)' or  	//  the use of existing codes (compressed)?  	bool IsMaskSet = (flag & mask) > 0;  	if (IsMaskSet ^ maskMeansCompressed) {  		// Retrieve the un-compressed code  		if ((dataI = src.ReadByte ()) != -1) {  			// Save the byte into the dictionary  			buffer [(pos & 4095)] = fromInt (dataI);  			pos++;  			// And output the byte  			res.WriteByte (fromInt (dataI));  			//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  		}  	}  	else {  		// We have a compressed sequence  		// Grab the next 16 bits of data  		dataIPt1 = src.ReadByte ();  		dataIPt2 = src.ReadByte ();  		if (dataIPt1 == -1 || dataIPt2 == -1)  			break;  		// Build up how long the code sequence is' and  		//  what position of the code to start at  		// (The position is the usually the first 12 bits'   		//  and the length is usually the last 4 bits)  		len = (dataIPt2 & 15) + codeLengthIncrease;  		if (positionIsBigEndian) {  			pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  		}  		else {  			pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  		}  		// Adjust the pointer as needed  		pntr = adjustDictionaryOffset (pntr);  		// Loop over the codes' outputting what they correspond to  		for (int i = 0; i < len; i++) {  			dataB [i] = buffer [(pntr + i) & 4095];  			buffer [(pos + i) & 4095] = dataB [i];  		}  		res.Write (dataB' 0' len);  		// Record how far along the stream we have Moved  		pos = pos + len;  	}  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (IsMaskSet ^ maskMeansCompressed) {  	// Retrieve the un-compressed code  	if ((dataI = src.ReadByte ()) != -1) {  		// Save the byte into the dictionary  		buffer [(pos & 4095)] = fromInt (dataI);  		pos++;  		// And output the byte  		res.WriteByte (fromInt (dataI));  		//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  	}  }  else {  	// We have a compressed sequence  	// Grab the next 16 bits of data  	dataIPt1 = src.ReadByte ();  	dataIPt2 = src.ReadByte ();  	if (dataIPt1 == -1 || dataIPt2 == -1)  		break;  	// Build up how long the code sequence is' and  	//  what position of the code to start at  	// (The position is the usually the first 12 bits'   	//  and the length is usually the last 4 bits)  	len = (dataIPt2 & 15) + codeLengthIncrease;  	if (positionIsBigEndian) {  		pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  	}  	else {  		pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  	}  	// Adjust the pointer as needed  	pntr = adjustDictionaryOffset (pntr);  	// Loop over the codes' outputting what they correspond to  	for (int i = 0; i < len; i++) {  		dataB [i] = buffer [(pntr + i) & 4095];  		buffer [(pos + i) & 4095] = dataB [i];  	}  	res.Write (dataB' 0' len);  	// Record how far along the stream we have Moved  	pos = pos + len;  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if ((dataI = src.ReadByte ()) != -1) {  	// Save the byte into the dictionary  	buffer [(pos & 4095)] = fromInt (dataI);  	pos++;  	// And output the byte  	res.WriteByte (fromInt (dataI));  	//res.Write(new byte[] { fromInt(dataI) }' 0' 1);  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: buffer [(pos & 4095)] = fromInt (dataI);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: len = (dataIPt2 & 15) + codeLengthIncrease;  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (positionIsBigEndian) {  	pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  }  else {  	pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (positionIsBigEndian) {  	pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  }  else {  	pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: if (positionIsBigEndian) {  	pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  }  else {  	pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: pntr = (dataIPt1 << 4) + (dataIPt2 >> 4);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: pntr = dataIPt1 + ((dataIPt2 & 0xF0) << 4);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	dataB [i] = buffer [(pntr + i) & 4095];  	buffer [(pos + i) & 4095] = dataB [i];  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	dataB [i] = buffer [(pntr + i) & 4095];  	buffer [(pos + i) & 4095] = dataB [i];  }  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: dataB [i] = buffer [(pntr + i) & 4095];  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,decompress,The following statement contains a magic number: buffer [(pos + i) & 4095] = dataB [i];  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,fromInt,The following statement contains a magic number: if (b < 128)  	return (byte)b;  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,fromInt,The following statement contains a magic number: return (byte)(b - 256);  
Magic Number,NPOI.Util,LZWDecompresser,C:\repos\xoposhiy_npoi\trunk\main\Util\LZWDecompresser.cs,fromByte,The following statement contains a magic number: return b + 256;  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (32).Append (obj1).Append (obj2));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (32).Append (obj1).Append (obj2));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (48).Append (obj1).Append (obj2).Append (obj3));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (48).Append (obj1).Append (obj2).Append (obj3));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (64).Append (obj1).Append (obj2).Append (obj3).Append (obj4));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (64).Append (obj1).Append (obj2).Append (obj3).Append (obj4));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (80).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (80).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8));  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8));  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (32).Append (obj1).Append (obj2)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (32).Append (obj1).Append (obj2)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (48).Append (obj1).Append (obj2).Append (obj3)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (48).Append (obj1).Append (obj2).Append (obj3)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (64).Append (obj1).Append (obj2).Append (obj3).Append (obj4)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (64).Append (obj1).Append (obj2).Append (obj3).Append (obj4)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (80).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (80).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (96).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (112).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7)' exception);  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: if (Check (level)) {  	Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8)' exception);  }  
Magic Number,NPOI.Util,POILogger,C:\repos\xoposhiy_npoi\trunk\main\Util\POILogger.cs,Log,The following statement contains a magic number: Log (level' new StringBuilder (128).Append (obj1).Append (obj2).Append (obj3).Append (obj4).Append (obj5).Append (obj6).Append (obj7).Append (obj8)' exception);  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: if (index > _limit) {  	throw new IndexOutOfRangeException ();  }  else if (index == _limit) {  	Add (value);  }  else {  	// index < limit -- insert into the middle  	if (_limit == _array.Length) {  		GrowArray (_limit * 2);  	}  	Array.Copy (_array' index' _array' index + 1' _limit - index);  	_array [index] = value;  	_limit++;  }  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: if (index == _limit) {  	Add (value);  }  else {  	// index < limit -- insert into the middle  	if (_limit == _array.Length) {  		GrowArray (_limit * 2);  	}  	Array.Copy (_array' index' _array' index + 1' _limit - index);  	_array [index] = value;  	_limit++;  }  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: if (_limit == _array.Length) {  	GrowArray (_limit * 2);  }  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: GrowArray (_limit * 2);  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: if (_limit == _array.Length) {  	GrowArray (_limit * 2);  }  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,Add,The following statement contains a magic number: GrowArray (_limit * 2);  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,GetHashCode,The following statement contains a magic number: for (int j = 0; j < _limit; j++) {  	hash = (31 * hash) + _array [j];  }  
Magic Number,NPOI.Util,ShortList,C:\repos\xoposhiy_npoi\trunk\main\Util\ShortList.cs,GetHashCode,The following statement contains a magic number: hash = (31 * hash) + _array [j];  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeLE,The following statement contains a magic number: if ((len < 0) || (((str.Length - offset) / 2) < len)) {  	throw new ArgumentException ("Illegal Length");  }  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeLE,The following statement contains a magic number: return Encoding.Unicode.GetString (str' offset' len * 2);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeLE,The following statement contains a magic number: return GetFromUnicodeLE (str' 0' str.Length / 2);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeBE,The following statement contains a magic number: if ((len < 0) || (((str.Length - offset) / 2) < len)) {  	throw new ArgumentException ("Illegal Length");  }  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeBE,The following statement contains a magic number: try {  	return Encoding.GetEncoding ("UTF-16BE").GetString (str' offset' len * 2);  }  catch {  	throw new InvalidOperationException ();  	/*unreachable*/}  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeBE,The following statement contains a magic number: return Encoding.GetEncoding ("UTF-16BE").GetString (str' offset' len * 2);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetFromUnicodeBE,The following statement contains a magic number: return GetFromUnicodeBE (str' 0' str.Length / 2);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,GetEncodedSize,The following statement contains a magic number: result += value.Length * (StringUtil.HasMultibyte (value) ? 2 : 1);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,ToHexString,The following statement contains a magic number: return Convert.ToString ((int)chr' 16);  
Magic Number,NPOI.Util,StringUtil,C:\repos\xoposhiy_npoi\trunk\main\Util\StringUtil.cs,NeedToEncode,The following statement contains a magic number: if (chr > 127)  	return true;  
Magic Number,NPOI.Util,TempFile,C:\repos\xoposhiy_npoi\trunk\main\Util\TempFile.cs,GetTempFilePath,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,NPOI.POIFS.Properties,DirectoryProperty,C:\repos\xoposhiy_npoi\trunk\main\POIFS\property\DirectoryProperty.cs,PreWrite,The following statement contains a magic number: if (_children.Count > 0) {  	Property[] children = new Property[this._children.Count];  	this._children.CopyTo (children' 0);  	Array.Sort (children' new PropertyComparator ());  	int midpoint = children.Length / 2;  	this.ChildProperty = children [midpoint].Index;  	children [0].PreviousChild = null;  	children [0].NextChild = null;  	for (int j = 1; j < midpoint; j++) {  		children [j].PreviousChild = children [j - 1];  		children [j].NextChild = null;  	}  	if (midpoint != 0) {  		children [midpoint].PreviousChild = children [midpoint - 1];  	}  	if (midpoint != (children.Length - 1)) {  		children [midpoint].NextChild = children [midpoint + 1];  		for (int j = midpoint + 1; j < children.Length - 1; j++) {  			children [j].PreviousChild = null;  			children [j].NextChild = children [j + 1];  		}  		children [children.Length - 1].PreviousChild = null;  		children [children.Length - 1].NextChild = null;  	}  	else {  		children [midpoint].NextChild = null;  	}  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,HeaderBlock,The following statement contains a magic number: try {  	stream.Position = 0;  	PrivateHeaderBlock (ReadFirst512 (stream));  	if (bigBlockSize.GetBigBlockSize () != 512) {  		int rest = bigBlockSize.GetBigBlockSize () - 512;  		byte[] temp = new byte[rest];  		IOUtils.ReadFully (stream' temp);  	}  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,HeaderBlock,The following statement contains a magic number: try {  	stream.Position = 0;  	PrivateHeaderBlock (ReadFirst512 (stream));  	if (bigBlockSize.GetBigBlockSize () != 512) {  		int rest = bigBlockSize.GetBigBlockSize () - 512;  		byte[] temp = new byte[rest];  		IOUtils.ReadFully (stream' temp);  	}  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,HeaderBlock,The following statement contains a magic number: if (bigBlockSize.GetBigBlockSize () != 512) {  	int rest = bigBlockSize.GetBigBlockSize () - 512;  	byte[] temp = new byte[rest];  	IOUtils.ReadFully (stream' temp);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,HeaderBlock,The following statement contains a magic number: if (bigBlockSize.GetBigBlockSize () != 512) {  	int rest = bigBlockSize.GetBigBlockSize () - 512;  	byte[] temp = new byte[rest];  	IOUtils.ReadFully (stream' temp);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (signature != _signature) {  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	throw new IOException ("Invalid header signature; read " + LongToHex (signature) + "' expected " + LongToHex (_signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (signature != _signature) {  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	throw new IOException ("Invalid header signature; read " + LongToHex (signature) + "' expected " + LongToHex (_signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (signature != _signature) {  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	throw new IOException ("Invalid header signature; read " + LongToHex (signature) + "' expected " + LongToHex (_signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (signature != _signature) {  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	throw new IOException ("Invalid header signature; read " + LongToHex (signature) + "' expected " + LongToHex (_signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 12) {  	bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 12) {  	bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 12) {  	bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 12) {  	bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 12) {  	bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: if (_data [30] == 9) {  	bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,PrivateHeaderBlock,The following statement contains a magic number: throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,HeaderBlock,The following statement contains a magic number: new ShortField ((int)0x1c' (short)-2' ref _data);  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,ReadFirst512,The following statement contains a magic number: if (bsCount != 512) {  	AlertShortRead (bsCount' 512);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,ReadFirst512,The following statement contains a magic number: if (bsCount != 512) {  	AlertShortRead (bsCount' 512);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,ReadFirst512,The following statement contains a magic number: AlertShortRead (bsCount' 512);  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,WriteData,The following statement contains a magic number: try {  	new IntegerField (_bat_count_offset' _bat_count' _data);  	new IntegerField (_property_start_offset' _property_start' _data);  	new IntegerField (_sbat_start_offset' _sbat_start' _data);  	new IntegerField (_sbat_block_count_offset' _sbat_count' _data);  	new IntegerField (_xbat_start_offset' _xbat_start' _data);  	new IntegerField (_xbat_count_offset' _xbat_count' _data);  	stream.Write (_data' 0' 512);  	for (int i = POIFSConstants.SMALLER_BIG_BLOCK_SIZE; i < bigBlockSize.GetBigBlockSize (); i++) {  		//stream.Write(Write(0);  		stream.WriteByte (0);  	}  }  catch (IOException ex) {  	throw ex;  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlock.cs,WriteData,The following statement contains a magic number: stream.Write (_data' 0' 512);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadUshortLE,The following statement contains a magic number: return (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadUshortLE,The following statement contains a magic number: return (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadIntLE,The following statement contains a magic number: return (b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0);  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,DataInputBlock,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\DataInputBlock.cs,ReadLongLE,The following statement contains a magic number: return (((long)b7 << 56) + ((long)b6 << 48) + ((long)b5 << 40) + ((long)b4 << 32) + ((long)b3 << 24) + (b2 << 16) + (b1 << 8) + (b0 << 0));  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (signature != HeaderBlockConstants._signature) {  	// Is it one of the usual suspects?  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		// BIFF2 raw stream starts with BOF (sid=0x0009' size=0x0004' data=0x00t0)  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	// Give a generic error  	throw new IOException ("Invalid header signature; Read " + LongToHex (signature) + "' expected " + LongToHex (HeaderBlockConstants._signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (signature != HeaderBlockConstants._signature) {  	// Is it one of the usual suspects?  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		// BIFF2 raw stream starts with BOF (sid=0x0009' size=0x0004' data=0x00t0)  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	// Give a generic error  	throw new IOException ("Invalid header signature; Read " + LongToHex (signature) + "' expected " + LongToHex (HeaderBlockConstants._signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (signature != HeaderBlockConstants._signature) {  	// Is it one of the usual suspects?  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		// BIFF2 raw stream starts with BOF (sid=0x0009' size=0x0004' data=0x00t0)  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	// Give a generic error  	throw new IOException ("Invalid header signature; Read " + LongToHex (signature) + "' expected " + LongToHex (HeaderBlockConstants._signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (signature != HeaderBlockConstants._signature) {  	// Is it one of the usual suspects?  	byte[] OOXML_FILE_HEADER = POIFSConstants.OOXML_FILE_HEADER;  	if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  		throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  	}  	if ((signature & unchecked((long)0xFF8FFFFFFFFFFFFFL)) == 0x0010000200040009L) {  		// BIFF2 raw stream starts with BOF (sid=0x0009' size=0x0004' data=0x00t0)  		throw new ArgumentException ("The supplied data appears to be in BIFF2 format.  " + "POI only supports BIFF8 format");  	}  	// Give a generic error  	throw new IOException ("Invalid header signature; Read " + LongToHex (signature) + "' expected " + LongToHex (HeaderBlockConstants._signature));  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [0] == OOXML_FILE_HEADER [0] && _data [1] == OOXML_FILE_HEADER [1] && _data [2] == OOXML_FILE_HEADER [2] && _data [3] == OOXML_FILE_HEADER [3]) {  	throw new OfficeXmlFileException ("The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 12) {  	this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 12) {  	this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 12) {  	this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 12) {  	this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 12) {  	this.bigBlockSize = POIFSConstants.LARGER_BIG_BLOCK_SIZE_DETAILS;  }  else if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (_data [30] == 9) {  	this.bigBlockSize = POIFSConstants.SMALLER_BIG_BLOCK_SIZE_DETAILS;  }  else {  	throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: throw new IOException ("Unsupported blocksize  (2^" + _data [30] + "). Expected 2^9 or 2^12.");  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (bigBlockSize.GetBigBlockSize () != 512) {  	int rest = bigBlockSize.GetBigBlockSize () - 512;  	byte[] tmp = new byte[rest];  	IOUtils.ReadFully (stream' tmp);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,HeaderBlockReader,The following statement contains a magic number: if (bigBlockSize.GetBigBlockSize () != 512) {  	int rest = bigBlockSize.GetBigBlockSize () - 512;  	byte[] tmp = new byte[rest];  	IOUtils.ReadFully (stream' tmp);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,ReadFirst512,The following statement contains a magic number: if (bsCount != 512) {  	AlertShortRead (bsCount' 512);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,ReadFirst512,The following statement contains a magic number: if (bsCount != 512) {  	AlertShortRead (bsCount' 512);  }  
Magic Number,NPOI.POIFS.Storage,HeaderBlockReader,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Storage\HeaderBlockReader.cs,ReadFirst512,The following statement contains a magic number: AlertShortRead (bsCount' 512);  
Magic Number,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,GetEncodedSize,The following statement contains a magic number: if (obj == EMPTY_REPRESENTATION) {  	return 8;  }  
Magic Number,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,GetEncodedSize,The following statement contains a magic number: return 8;  
Magic Number,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,GetEncodedSize,The following statement contains a magic number: if (cls == typeof(bool) || cls == typeof(double) || cls == typeof(ErrorConstant)) {  	return 8;  }  
Magic Number,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,GetEncodedSize,The following statement contains a magic number: return 8;  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: for (int i = 0; i < nChars; i++) {  	char ch = password [i];  	passwordData [i * 2 + 0] = (byte)((ch << 0) & 0xFF);  	passwordData [i * 2 + 1] = (byte)((ch << 8) & 0xFF);  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: for (int i = 0; i < nChars; i++) {  	char ch = password [i];  	passwordData [i * 2 + 0] = (byte)((ch << 0) & 0xFF);  	passwordData [i * 2 + 1] = (byte)((ch << 8) & 0xFF);  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: for (int i = 0; i < nChars; i++) {  	char ch = password [i];  	passwordData [i * 2 + 0] = (byte)((ch << 0) & 0xFF);  	passwordData [i * 2 + 1] = (byte)((ch << 8) & 0xFF);  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: passwordData [i * 2 + 0] = (byte)((ch << 0) & 0xFF);  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: passwordData [i * 2 + 1] = (byte)((ch << 8) & 0xFF);  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: passwordData [i * 2 + 1] = (byte)((ch << 8) & 0xFF);  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: using (MD5 md5 = new MD5CryptoServiceProvider ()) {  	byte[] passwordHash = md5.ComputeHash (passwordData);  	md5.Initialize ();  	byte[] data = new byte[PASSWORD_HASH_NUMBER_OF_BYTES_USED * 16 + docIdData.Length * 16];  	int offset = 0;  	for (int i = 0; i < 16; i++) {  		Array.Copy (passwordHash' 0' data' offset' PASSWORD_HASH_NUMBER_OF_BYTES_USED);  		offset += PASSWORD_HASH_NUMBER_OF_BYTES_USED;  		// passwordHash.Length;  		Array.Copy (docIdData' 0' data' offset' docIdData.Length);  		offset += docIdData.Length;  	}  	kd = md5.ComputeHash (data);  	byte[] result = new byte[KEY_DIGEST_LENGTH];  	Array.Copy (kd' 0' result' 0' KEY_DIGEST_LENGTH);  	md5.Clear ();  	return result;  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: using (MD5 md5 = new MD5CryptoServiceProvider ()) {  	byte[] passwordHash = md5.ComputeHash (passwordData);  	md5.Initialize ();  	byte[] data = new byte[PASSWORD_HASH_NUMBER_OF_BYTES_USED * 16 + docIdData.Length * 16];  	int offset = 0;  	for (int i = 0; i < 16; i++) {  		Array.Copy (passwordHash' 0' data' offset' PASSWORD_HASH_NUMBER_OF_BYTES_USED);  		offset += PASSWORD_HASH_NUMBER_OF_BYTES_USED;  		// passwordHash.Length;  		Array.Copy (docIdData' 0' data' offset' docIdData.Length);  		offset += docIdData.Length;  	}  	kd = md5.ComputeHash (data);  	byte[] result = new byte[KEY_DIGEST_LENGTH];  	Array.Copy (kd' 0' result' 0' KEY_DIGEST_LENGTH);  	md5.Clear ();  	return result;  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: using (MD5 md5 = new MD5CryptoServiceProvider ()) {  	byte[] passwordHash = md5.ComputeHash (passwordData);  	md5.Initialize ();  	byte[] data = new byte[PASSWORD_HASH_NUMBER_OF_BYTES_USED * 16 + docIdData.Length * 16];  	int offset = 0;  	for (int i = 0; i < 16; i++) {  		Array.Copy (passwordHash' 0' data' offset' PASSWORD_HASH_NUMBER_OF_BYTES_USED);  		offset += PASSWORD_HASH_NUMBER_OF_BYTES_USED;  		// passwordHash.Length;  		Array.Copy (docIdData' 0' data' offset' docIdData.Length);  		offset += docIdData.Length;  	}  	kd = md5.ComputeHash (data);  	byte[] result = new byte[KEY_DIGEST_LENGTH];  	Array.Copy (kd' 0' result' 0' KEY_DIGEST_LENGTH);  	md5.Clear ();  	return result;  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateKeyDigest,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	Array.Copy (passwordHash' 0' data' offset' PASSWORD_HASH_NUMBER_OF_BYTES_USED);  	offset += PASSWORD_HASH_NUMBER_OF_BYTES_USED;  	// passwordHash.Length;  	Array.Copy (docIdData' 0' data' offset' docIdData.Length);  	offset += docIdData.Length;  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,Check16Bytes,The following statement contains a magic number: if (data.Length != 16) {  	throw new ArgumentException ("Expected 16 byte " + argName + "' but got " + HexDump.ToHex (data));  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateRC4,The following statement contains a magic number: using (MD5 md5 = new MD5CryptoServiceProvider ()) {  	using (MemoryStream baos = new MemoryStream (4)) {  		new LittleEndianOutputStream (baos).WriteInt (keyBlockNo);  		byte[] baosToArray = baos.ToArray ();  		byte[] data = new byte[baosToArray.Length + _keyDigest.Length];  		Array.Copy (_keyDigest' 0' data' 0' _keyDigest.Length);  		Array.Copy (baosToArray' 0' data' _keyDigest.Length' baosToArray.Length);  		byte[] digest = md5.ComputeHash (data);  		return new RC4 (digest);  	}  }  
Magic Number,NPOI.HSSF.Record.Crypto,Biff8EncryptionKey,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8EncryptionKey.cs,CreateRC4,The following statement contains a magic number: using (MemoryStream baos = new MemoryStream (4)) {  	new LittleEndianOutputStream (baos).WriteInt (keyBlockNo);  	byte[] baosToArray = baos.ToArray ();  	byte[] data = new byte[baosToArray.Length + _keyDigest.Length];  	Array.Copy (_keyDigest' 0' data' 0' _keyDigest.Length);  	Array.Copy (baosToArray' 0' data' _keyDigest.Length' baosToArray.Length);  	byte[] digest = md5.ComputeHash (data);  	return new RC4 (digest);  }  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,RC4,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	_s [i] = (byte)i;  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,RC4,The following statement contains a magic number: for (int i = 0' j = 0; i < 256; i++) {  	byte temp;  	j = (j + key [i % key_length] + _s [i]) & 255;  	temp = _s [i];  	_s [i] = _s [j];  	_s [j] = temp;  }  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,RC4,The following statement contains a magic number: for (int i = 0' j = 0; i < 256; i++) {  	byte temp;  	j = (j + key [i % key_length] + _s [i]) & 255;  	temp = _s [i];  	_s [i] = _s [j];  	_s [j] = temp;  }  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,RC4,The following statement contains a magic number: j = (j + key [i % key_length] + _s [i]) & 255;  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,Output,The following statement contains a magic number: _i = (_i + 1) & 255;  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,Output,The following statement contains a magic number: _j = (_j + _s [_i]) & 255;  
Magic Number,NPOI.HSSF.Record.Crypto,RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\RC4.cs,Output,The following statement contains a magic number: return _s [(_s [_i] + _s [_j]) & 255];  
Magic Number,NPOI.HSSF.Record.PivotTable,ExtendedPivotTableViewFieldsRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\PivotTable\ExtendedPivotTableViewFieldsRecord.cs,ExtendedPivotTableViewFieldsRecord,The following statement contains a magic number: switch (in1.Remaining) {  case 0:  	// as per "Microsoft Excel Developer's Kit" book  	// older version of SXVDEX - doesn't seem to have a sub-total name  	reserved1 = 0;  	reserved2 = 0;  	subName = null;  	return;  case 10:  	// as per "MICROSOFT OFFICE EXCEL 97-2007 BINARY FILE FORMAT SPECIFICATION" pdf  	break;  default:  	throw new RecordFormatException ("Unexpected remaining size (" + in1.Remaining + ")");  }  
Magic Number,NPOI.POIFS.Dev,POIFSLister,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Dev\POIFSLister.cs,DisplayDirectory,The following statement contains a magic number: while (it.MoveNext ()) {  	Object entry = it.Current;  	if (entry is DirectoryNode) {  		DisplayDirectory ((DirectoryNode)entry' newIndent);  	}  	else {  		DocumentNode doc = (DocumentNode)entry;  		String name = doc.Name;  		if (name [0] < 10) {  			String altname = "(0x0" + (int)name [0] + ")" + name.Substring (1);  			name = name.Substring (1) + " <" + altname + ">";  		}  		Console.WriteLine (newIndent + name);  	}  }  
Magic Number,NPOI.POIFS.Dev,POIFSLister,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Dev\POIFSLister.cs,DisplayDirectory,The following statement contains a magic number: if (entry is DirectoryNode) {  	DisplayDirectory ((DirectoryNode)entry' newIndent);  }  else {  	DocumentNode doc = (DocumentNode)entry;  	String name = doc.Name;  	if (name [0] < 10) {  		String altname = "(0x0" + (int)name [0] + ")" + name.Substring (1);  		name = name.Substring (1) + " <" + altname + ">";  	}  	Console.WriteLine (newIndent + name);  }  
Magic Number,NPOI.POIFS.Dev,POIFSLister,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Dev\POIFSLister.cs,DisplayDirectory,The following statement contains a magic number: if (name [0] < 10) {  	String altname = "(0x0" + (int)name [0] + ")" + name.Substring (1);  	name = name.Substring (1) + " <" + altname + ">";  }  
Magic Number,NPOI.SS.Formula.PTG,AreaPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaPtgBase.cs,WriteCoordinates,The following statement contains a magic number: LittleEndian.PutUShort (array' offset + 2' field_2_last_row);  
Magic Number,NPOI.SS.Formula.PTG,AreaPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaPtgBase.cs,WriteCoordinates,The following statement contains a magic number: LittleEndian.PutUShort (array' offset + 4' field_3_first_column);  
Magic Number,NPOI.SS.Formula.PTG,AreaPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AreaPtgBase.cs,WriteCoordinates,The following statement contains a magic number: LittleEndian.PutUShort (array' offset + 6' field_4_last_column);  
Magic Number,NPOI.SS.Formula.PTG,ArrayPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ArrayPtg.cs,WriteTokenValueBytes,The following statement contains a magic number: return 3 + ConstantValueParser.GetEncodedSize (_arrayValues);  
Magic Number,NPOI.SS.Formula.PTG,AttrPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AttrPtg.cs,ToString,The following statement contains a magic number: if (IsSpace) {  	sb.Append ("space count=").Append ((field_2_data >> 8) & 0x00FF);  	sb.Append (" type=").Append (field_2_data & 0x00FF).Append (" ");  }  
Magic Number,NPOI.SS.Formula.PTG,AttrPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\AttrPtg.cs,ToString,The following statement contains a magic number: sb.Append ("space count=").Append ((field_2_data >> 8) & 0x00FF);  
Magic Number,NPOI.SS.Formula.PTG,ExternSheetNameResolver,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ExternSheetNameResolver.cs,PrependSheetName,The following statement contains a magic number: if (externalSheet != null) {  	String wbName = externalSheet.GetWorkbookName ();  	String sheetName = externalSheet.GetSheetName ();  	sb = new StringBuilder (wbName.Length + sheetName.Length + cellRefText.Length + 4);  	SheetNameFormatter.AppendFormat (sb' wbName' sheetName);  }  else {  	String sheetName = book.GetSheetNameByExternSheet (field_1_index_extern_sheet);  	sb = new StringBuilder (sheetName.Length + cellRefText.Length + 4);  	if (sheetName.Length < 1) {  		// What excel does if sheet has been deleted  		sb.Append ("#REF");  		// note - '!' added just once below  	}  	else {  		SheetNameFormatter.AppendFormat (sb' sheetName);  	}  }  
Magic Number,NPOI.SS.Formula.PTG,ExternSheetNameResolver,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ExternSheetNameResolver.cs,PrependSheetName,The following statement contains a magic number: if (externalSheet != null) {  	String wbName = externalSheet.GetWorkbookName ();  	String sheetName = externalSheet.GetSheetName ();  	sb = new StringBuilder (wbName.Length + sheetName.Length + cellRefText.Length + 4);  	SheetNameFormatter.AppendFormat (sb' wbName' sheetName);  }  else {  	String sheetName = book.GetSheetNameByExternSheet (field_1_index_extern_sheet);  	sb = new StringBuilder (sheetName.Length + cellRefText.Length + 4);  	if (sheetName.Length < 1) {  		// What excel does if sheet has been deleted  		sb.Append ("#REF");  		// note - '!' added just once below  	}  	else {  		SheetNameFormatter.AppendFormat (sb' sheetName);  	}  }  
Magic Number,NPOI.SS.Formula.PTG,ExternSheetNameResolver,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ExternSheetNameResolver.cs,PrependSheetName,The following statement contains a magic number: sb = new StringBuilder (wbName.Length + sheetName.Length + cellRefText.Length + 4);  
Magic Number,NPOI.SS.Formula.PTG,ExternSheetNameResolver,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ExternSheetNameResolver.cs,PrependSheetName,The following statement contains a magic number: sb = new StringBuilder (sheetName.Length + cellRefText.Length + 4);  
Magic Number,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,SerializePtgs,The following statement contains a magic number: for (int k = 0; k < size; k++) {  	Ptg ptg = ptgs [k];  	ptg.Write (out1);  	if (ptg is ArrayPtg) {  		if (arrayPtgs == null) {  			arrayPtgs = new ArrayList (5);  		}  		arrayPtgs.Add (ptg);  	}  }  
Magic Number,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,SerializePtgs,The following statement contains a magic number: if (ptg is ArrayPtg) {  	if (arrayPtgs == null) {  		arrayPtgs = new ArrayList (5);  	}  	arrayPtgs.Add (ptg);  }  
Magic Number,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,SerializePtgs,The following statement contains a magic number: if (arrayPtgs == null) {  	arrayPtgs = new ArrayList (5);  }  
Magic Number,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,SerializePtgs,The following statement contains a magic number: arrayPtgs = new ArrayList (5);  
Magic Number,NPOI.SS.Formula.PTG,RefPtgBase,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\RefPtgBase.cs,WriteCoordinates,The following statement contains a magic number: LittleEndian.PutUShort (array' offset + 2' field_2_col);  
Magic Number,NPOI.SS.Formula.PTG,StringPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\StringPtg.cs,StringPtg,The following statement contains a magic number: if (value.Length > 255) {  	throw new ArgumentException ("String literals in formulas can't be bigger than 255 Chars ASCII");  }  
Magic Number,NPOI.SS.Formula,CollaboratingWorkbooksEnvironment,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\CollaboratingWorkbooksEnvironment.cs,GetWorkbookEvaluator,The following statement contains a magic number: if (_evaluatorsByName.ContainsKey (workbookName)) {  	result = (WorkbookEvaluator)_evaluatorsByName [workbookName];  }  else {  	StringBuilder sb = new StringBuilder (256);  	sb.Append ("Could not resolve external workbook name '").Append (workbookName).Append ("'.");  	if (_evaluators.Length < 1) {  		sb.Append (" Workbook environment has not been set up.");  	}  	else {  		sb.Append (" The following workbook names are valid: (");  		IEnumerator i = _evaluatorsByName.Keys.GetEnumerator ();  		int count = 0;  		while (i.MoveNext ()) {  			if (count++ > 0) {  				sb.Append ("' ");  			}  			sb.Append ("'").Append (i.Current).Append ("'");  		}  		sb.Append (")");  	}  	throw new WorkbookNotFoundException (sb.ToString ());  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntry.cs,ChangeConsumingCells,The following statement contains a magic number: if (nUsed < 1) {  	usedSet = new ArrayList ();  }  else {  	usedSet = new ArrayList (nUsed * 3 / 2);  	for (int i = 0; i < nUsed; i++) {  		usedSet.Add (usedCells [i]);  	}  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntry.cs,ChangeConsumingCells,The following statement contains a magic number: if (nUsed < 1) {  	usedSet = new ArrayList ();  }  else {  	usedSet = new ArrayList (nUsed * 3 / 2);  	for (int i = 0; i < nUsed; i++) {  		usedSet.Add (usedCells [i]);  	}  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntry.cs,ChangeConsumingCells,The following statement contains a magic number: usedSet = new ArrayList (nUsed * 3 / 2);  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntry,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntry.cs,ChangeConsumingCells,The following statement contains a magic number: usedSet = new ArrayList (nUsed * 3 / 2);  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Add,The following statement contains a magic number: if (_size * 3 >= _arr.Length * 2) {  	// re-Hash  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[4 + _arr.Length * 3 / 2];  	// grow 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Add,The following statement contains a magic number: if (_size * 3 >= _arr.Length * 2) {  	// re-Hash  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[4 + _arr.Length * 3 / 2];  	// grow 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Add,The following statement contains a magic number: if (_size * 3 >= _arr.Length * 2) {  	// re-Hash  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[4 + _arr.Length * 3 / 2];  	// grow 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Add,The following statement contains a magic number: if (_size * 3 >= _arr.Length * 2) {  	// re-Hash  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[4 + _arr.Length * 3 / 2];  	// grow 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Add,The following statement contains a magic number: if (_size * 3 >= _arr.Length * 2) {  	// re-Hash  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[4 + _arr.Length * 3 / 2];  	// grow 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Remove,The following statement contains a magic number: if (_size * 3 < _arr.Length && _arr.Length > 8) {  	// re-Hash  	bool found = false;  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[_arr.Length / 2];  	// shrink 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			if (prevCce == cce) {  				found = true;  				_size--;  				// skip it  				continue;  			}  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  	return found;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Remove,The following statement contains a magic number: if (_size * 3 < _arr.Length && _arr.Length > 8) {  	// re-Hash  	bool found = false;  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[_arr.Length / 2];  	// shrink 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			if (prevCce == cce) {  				found = true;  				_size--;  				// skip it  				continue;  			}  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  	return found;  }  
Magic Number,NPOI.SS.Formula,FormulaCellCacheEntrySet,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaCellCacheEntrySet.cs,Remove,The following statement contains a magic number: if (_size * 3 < _arr.Length && _arr.Length > 8) {  	// re-Hash  	bool found = false;  	FormulaCellCacheEntry[] prevArr = _arr;  	FormulaCellCacheEntry[] newArr = new FormulaCellCacheEntry[_arr.Length / 2];  	// shrink 50%  	for (int i = 0; i < prevArr.Length; i++) {  		FormulaCellCacheEntry prevCce = _arr [i];  		if (prevCce != null) {  			if (prevCce == cce) {  				found = true;  				_size--;  				// skip it  				continue;  			}  			AddInternal (newArr' prevCce);  		}  	}  	_arr = newArr;  	return found;  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The following statement contains a magic number: if (look == '.') {  	GetChar ();  	int dotCount = 1;  	while (look == '.') {  		dotCount++;  		GetChar ();  	}  	bool whiteBeforePart2 = IsWhite (look);  	SkipWhite ();  	SimpleRangePart part2 = ParseSimpleRangePart ();  	String part1And2 = formulaString.Substring (savePointer - 1' pointer - savePointer);  	if (part2 == null) {  		if (sheetIden != null) {  			throw new FormulaParseException ("Complete area reference expected after sheet name at index " + pointer + ".");  		}  		return ParseNonRange (savePointer);  	}  	if (whiteAfterPart1 || whiteBeforePart2) {  		if (part1.IsRowOrColumn || part2.IsRowOrColumn) {  			// "A .. B" not valid syntax for "A:B"  			// and there's no other valid expression that fits this grammar  			throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must not contain whitespace.");  		}  		return CreateAreaRefParseNode (sheetIden' part1' part2);  	}  	if (dotCount == 1 && part1.IsRow && part2.IsRow) {  		// actually' this is looking more like a number  		return ParseNonRange (savePointer);  	}  	if (part1.IsRowOrColumn || part2.IsRowOrColumn) {  		if (dotCount != 2) {  			throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must have exactly 2 dots.");  		}  	}  	return CreateAreaRefParseNode (sheetIden' part1' part2);  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The following statement contains a magic number: if (part1.IsRowOrColumn || part2.IsRowOrColumn) {  	if (dotCount != 2) {  		throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must have exactly 2 dots.");  	}  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseRangeable,The following statement contains a magic number: if (dotCount != 2) {  	throw new FormulaParseException ("Dotted range (full row or column) expression '" + part1And2 + "' must have exactly 2 dots.");  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleRangePart,The following statement contains a magic number: if (hasLetters && hasDigits) {  	if (!IsValidCellReference (rep)) {  		return null;  	}  }  else if (hasLetters) {  	if (!CellReference.IsColumnWithnRange (rep.Replace ("$"' "")' _ssVersion)) {  		return null;  	}  }  else if (hasDigits) {  	int i;  	try {  		i = Int32.Parse (rep.Replace ("$"' "")' CultureInfo.InvariantCulture);  	}  	catch (Exception) {  		return null;  	}  	if (i < 1 || i > 65536) {  		return null;  	}  }  else {  	// just dollars ? can this happen?  	return null;  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleRangePart,The following statement contains a magic number: if (hasLetters) {  	if (!CellReference.IsColumnWithnRange (rep.Replace ("$"' "")' _ssVersion)) {  		return null;  	}  }  else if (hasDigits) {  	int i;  	try {  		i = Int32.Parse (rep.Replace ("$"' "")' CultureInfo.InvariantCulture);  	}  	catch (Exception) {  		return null;  	}  	if (i < 1 || i > 65536) {  		return null;  	}  }  else {  	// just dollars ? can this happen?  	return null;  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleRangePart,The following statement contains a magic number: if (hasDigits) {  	int i;  	try {  		i = Int32.Parse (rep.Replace ("$"' "")' CultureInfo.InvariantCulture);  	}  	catch (Exception) {  		return null;  	}  	if (i < 1 || i > 65536) {  		return null;  	}  }  else {  	// just dollars ? can this happen?  	return null;  }  
Magic Number,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleRangePart,The following statement contains a magic number: if (i < 1 || i > 65536) {  	return null;  }  
Magic Number,NPOI.SS.Formula,BookSheetKey,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaUsedBlankCellSet.cs,GetHashCode,The following statement contains a magic number: return _bookIndex * 17 + _sheetIndex;  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: if (GetChildren ().Length > 2) {  	// false param present  	// false parameter  	GetChildren () [2].CollectPtgs (temp);  	int skipAfterFalseParamIndex = temp.CreatePlaceholder ();  	int falseParamSize = temp.sumTokenSizes (skipAfterTrueParamIndex + 1' skipAfterFalseParamIndex);  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (falseParamSize + 4 + 4 - 1);  	// 1 less than distance to end of if FuncVar(size=4). +4 for attr skip before  	AttrPtg attrSkipAfterFalse = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  	temp.SetPlaceholder (skipAfterFalseParamIndex' attrSkipAfterFalse);  }  else {  	// false parameter not present  	AttrPtg attrSkipAfterTrue = AttrPtg.CreateSkip (4 - 1);  	// 1 less than distance to end of if FuncVar(size=4).  	temp.SetPlaceholder (ifAttrIndex' attrIf);  	temp.SetPlaceholder (skipAfterTrueParamIndex' attrSkipAfterTrue);  }  
Magic Number,NPOI.SS.Formula,ParseNode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\ParseNode.cs,CollectIfPtgs,The following statement contains a magic number: GetChildren () [2].CollectPtgs (temp);  
Magic Number,NPOI.SS.Formula,Loc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PlainCellCache.cs,ToBookSheetColumn,The following statement contains a magic number: return ((bookIndex & 0xFFFFL) << 48) + ((sheetIndex & 0xFFFFL) << 32) + ((columnIndex & 0xFFFFL) << 0);  
Magic Number,NPOI.SS.Formula,Loc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PlainCellCache.cs,ToBookSheetColumn,The following statement contains a magic number: return ((bookIndex & 0xFFFFL) << 48) + ((sheetIndex & 0xFFFFL) << 32) + ((columnIndex & 0xFFFFL) << 0);  
Magic Number,NPOI.SS.Formula,Loc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PlainCellCache.cs,GetHashCode,The following statement contains a magic number: return (int)(_bookSheetColumn ^ (Operator.UnsignedRightShift (_bookSheetColumn' 32))) + 17 * _rowIndex;  
Magic Number,NPOI.SS.Formula,Loc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PlainCellCache.cs,GetHashCode,The following statement contains a magic number: return (int)(_bookSheetColumn ^ (Operator.UnsignedRightShift (_bookSheetColumn' 32))) + 17 * _rowIndex;  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: for (int i = 0' iSize = ptgs.Length; i < iSize; i++) {  	// since we don't know how To handle these yet :(  	Ptg ptg = ptgs [i];  	if (ptg is AttrPtg) {  		AttrPtg attrPtg = (AttrPtg)ptg;  		if (attrPtg.IsSum) {  			// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  			// expects the equivalent function Token  			//byte nArgs = 1;  // tAttrSum always Has 1 parameter  			ptg = FuncVarPtg.SUM;  			//.Create("SUM"' nArgs);  		}  		if (attrPtg.IsOptimizedChoose) {  			ValueEval arg0 = stack.Pop ();  			int[] jumpTable = attrPtg.JumpTable;  			int dist;  			int nChoices = jumpTable.Length;  			try {  				int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  				if (switchIndex < 1 || switchIndex > nChoices) {  					stack.Push (ErrorEval.VALUE_INVALID);  					dist = attrPtg.ChooseFuncOffset + 4;  					// +4 for tFuncFar(CHOOSE)  				}  				else {  					dist = jumpTable [switchIndex - 1];  				}  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			// Encoded dist for tAttrChoose includes size of jump table' but  			// countTokensToBeSkipped() does not (it counts whole tokens).  			dist -= nChoices * 2 + 2;  			// subtract jump table size  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (attrPtg.IsOptimizedIf) {  			ValueEval arg0 = stack.Pop ();  			bool evaluatedPredicate;  			try {  				evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				attrPtg = (AttrPtg)ptgs [i];  				dist = attrPtg.Data + 1;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				continue;  			}  			if (evaluatedPredicate) {  				// nothing to skip - true param folows  			}  			else {  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				Ptg nextPtg = ptgs [i + 1];  				if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  					// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  					i++;  					stack.Push (BoolEval.FALSE);  				}  			}  			continue;  		}  		if (attrPtg.IsSkip) {  			int dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			if (stack.Peek () == MissingArgEval.instance) {  				stack.Pop ();  				stack.Push (BlankEval.instance);  			}  			continue;  		}  	}  	if (ptg is ControlPtg) {  		// skip Parentheses' Attr' etc  		continue;  	}  	if (ptg is MemFuncPtg) {  		// can ignore' rest of Tokens for this expression are in OK RPN order  		continue;  	}  	if (ptg is MemErrPtg) {  		continue;  	}  	ValueEval opResult;  	if (ptg is OperationPtg) {  		OperationPtg optg = (OperationPtg)ptg;  		if (optg is UnionPtg) {  			continue;  		}  		int numops = optg.NumberOfOperands;  		ValueEval[] ops = new ValueEval[numops];  		// storing the ops in reverse order since they are popping  		for (int j = numops - 1; j >= 0; j--) {  			ValueEval p = (ValueEval)stack.Pop ();  			ops [j] = p;  		}  		//				logDebug("Invoke " + operation + " (nAgs=" + numops + ")");  		opResult = OperationEvaluatorFactory.Evaluate (optg' ops' ec);  	}  	else {  		opResult = GetEvalForPtg (ptg' ec);  	}  	if (opResult == null) {  		throw new Exception ("Evaluation result must not be null");  	}  	//			logDebug("push " + opResult);  	stack.Push (opResult);  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: for (int i = 0' iSize = ptgs.Length; i < iSize; i++) {  	// since we don't know how To handle these yet :(  	Ptg ptg = ptgs [i];  	if (ptg is AttrPtg) {  		AttrPtg attrPtg = (AttrPtg)ptg;  		if (attrPtg.IsSum) {  			// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  			// expects the equivalent function Token  			//byte nArgs = 1;  // tAttrSum always Has 1 parameter  			ptg = FuncVarPtg.SUM;  			//.Create("SUM"' nArgs);  		}  		if (attrPtg.IsOptimizedChoose) {  			ValueEval arg0 = stack.Pop ();  			int[] jumpTable = attrPtg.JumpTable;  			int dist;  			int nChoices = jumpTable.Length;  			try {  				int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  				if (switchIndex < 1 || switchIndex > nChoices) {  					stack.Push (ErrorEval.VALUE_INVALID);  					dist = attrPtg.ChooseFuncOffset + 4;  					// +4 for tFuncFar(CHOOSE)  				}  				else {  					dist = jumpTable [switchIndex - 1];  				}  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			// Encoded dist for tAttrChoose includes size of jump table' but  			// countTokensToBeSkipped() does not (it counts whole tokens).  			dist -= nChoices * 2 + 2;  			// subtract jump table size  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (attrPtg.IsOptimizedIf) {  			ValueEval arg0 = stack.Pop ();  			bool evaluatedPredicate;  			try {  				evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				attrPtg = (AttrPtg)ptgs [i];  				dist = attrPtg.Data + 1;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				continue;  			}  			if (evaluatedPredicate) {  				// nothing to skip - true param folows  			}  			else {  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				Ptg nextPtg = ptgs [i + 1];  				if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  					// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  					i++;  					stack.Push (BoolEval.FALSE);  				}  			}  			continue;  		}  		if (attrPtg.IsSkip) {  			int dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			if (stack.Peek () == MissingArgEval.instance) {  				stack.Pop ();  				stack.Push (BlankEval.instance);  			}  			continue;  		}  	}  	if (ptg is ControlPtg) {  		// skip Parentheses' Attr' etc  		continue;  	}  	if (ptg is MemFuncPtg) {  		// can ignore' rest of Tokens for this expression are in OK RPN order  		continue;  	}  	if (ptg is MemErrPtg) {  		continue;  	}  	ValueEval opResult;  	if (ptg is OperationPtg) {  		OperationPtg optg = (OperationPtg)ptg;  		if (optg is UnionPtg) {  			continue;  		}  		int numops = optg.NumberOfOperands;  		ValueEval[] ops = new ValueEval[numops];  		// storing the ops in reverse order since they are popping  		for (int j = numops - 1; j >= 0; j--) {  			ValueEval p = (ValueEval)stack.Pop ();  			ops [j] = p;  		}  		//				logDebug("Invoke " + operation + " (nAgs=" + numops + ")");  		opResult = OperationEvaluatorFactory.Evaluate (optg' ops' ec);  	}  	else {  		opResult = GetEvalForPtg (ptg' ec);  	}  	if (opResult == null) {  		throw new Exception ("Evaluation result must not be null");  	}  	//			logDebug("push " + opResult);  	stack.Push (opResult);  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: for (int i = 0' iSize = ptgs.Length; i < iSize; i++) {  	// since we don't know how To handle these yet :(  	Ptg ptg = ptgs [i];  	if (ptg is AttrPtg) {  		AttrPtg attrPtg = (AttrPtg)ptg;  		if (attrPtg.IsSum) {  			// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  			// expects the equivalent function Token  			//byte nArgs = 1;  // tAttrSum always Has 1 parameter  			ptg = FuncVarPtg.SUM;  			//.Create("SUM"' nArgs);  		}  		if (attrPtg.IsOptimizedChoose) {  			ValueEval arg0 = stack.Pop ();  			int[] jumpTable = attrPtg.JumpTable;  			int dist;  			int nChoices = jumpTable.Length;  			try {  				int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  				if (switchIndex < 1 || switchIndex > nChoices) {  					stack.Push (ErrorEval.VALUE_INVALID);  					dist = attrPtg.ChooseFuncOffset + 4;  					// +4 for tFuncFar(CHOOSE)  				}  				else {  					dist = jumpTable [switchIndex - 1];  				}  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			// Encoded dist for tAttrChoose includes size of jump table' but  			// countTokensToBeSkipped() does not (it counts whole tokens).  			dist -= nChoices * 2 + 2;  			// subtract jump table size  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (attrPtg.IsOptimizedIf) {  			ValueEval arg0 = stack.Pop ();  			bool evaluatedPredicate;  			try {  				evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				attrPtg = (AttrPtg)ptgs [i];  				dist = attrPtg.Data + 1;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				continue;  			}  			if (evaluatedPredicate) {  				// nothing to skip - true param folows  			}  			else {  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				Ptg nextPtg = ptgs [i + 1];  				if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  					// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  					i++;  					stack.Push (BoolEval.FALSE);  				}  			}  			continue;  		}  		if (attrPtg.IsSkip) {  			int dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			if (stack.Peek () == MissingArgEval.instance) {  				stack.Pop ();  				stack.Push (BlankEval.instance);  			}  			continue;  		}  	}  	if (ptg is ControlPtg) {  		// skip Parentheses' Attr' etc  		continue;  	}  	if (ptg is MemFuncPtg) {  		// can ignore' rest of Tokens for this expression are in OK RPN order  		continue;  	}  	if (ptg is MemErrPtg) {  		continue;  	}  	ValueEval opResult;  	if (ptg is OperationPtg) {  		OperationPtg optg = (OperationPtg)ptg;  		if (optg is UnionPtg) {  			continue;  		}  		int numops = optg.NumberOfOperands;  		ValueEval[] ops = new ValueEval[numops];  		// storing the ops in reverse order since they are popping  		for (int j = numops - 1; j >= 0; j--) {  			ValueEval p = (ValueEval)stack.Pop ();  			ops [j] = p;  		}  		//				logDebug("Invoke " + operation + " (nAgs=" + numops + ")");  		opResult = OperationEvaluatorFactory.Evaluate (optg' ops' ec);  	}  	else {  		opResult = GetEvalForPtg (ptg' ec);  	}  	if (opResult == null) {  		throw new Exception ("Evaluation result must not be null");  	}  	//			logDebug("push " + opResult);  	stack.Push (opResult);  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: for (int i = 0' iSize = ptgs.Length; i < iSize; i++) {  	// since we don't know how To handle these yet :(  	Ptg ptg = ptgs [i];  	if (ptg is AttrPtg) {  		AttrPtg attrPtg = (AttrPtg)ptg;  		if (attrPtg.IsSum) {  			// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  			// expects the equivalent function Token  			//byte nArgs = 1;  // tAttrSum always Has 1 parameter  			ptg = FuncVarPtg.SUM;  			//.Create("SUM"' nArgs);  		}  		if (attrPtg.IsOptimizedChoose) {  			ValueEval arg0 = stack.Pop ();  			int[] jumpTable = attrPtg.JumpTable;  			int dist;  			int nChoices = jumpTable.Length;  			try {  				int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  				if (switchIndex < 1 || switchIndex > nChoices) {  					stack.Push (ErrorEval.VALUE_INVALID);  					dist = attrPtg.ChooseFuncOffset + 4;  					// +4 for tFuncFar(CHOOSE)  				}  				else {  					dist = jumpTable [switchIndex - 1];  				}  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			// Encoded dist for tAttrChoose includes size of jump table' but  			// countTokensToBeSkipped() does not (it counts whole tokens).  			dist -= nChoices * 2 + 2;  			// subtract jump table size  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (attrPtg.IsOptimizedIf) {  			ValueEval arg0 = stack.Pop ();  			bool evaluatedPredicate;  			try {  				evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			}  			catch (EvaluationException e) {  				stack.Push (e.GetErrorEval ());  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				attrPtg = (AttrPtg)ptgs [i];  				dist = attrPtg.Data + 1;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				continue;  			}  			if (evaluatedPredicate) {  				// nothing to skip - true param folows  			}  			else {  				int dist = attrPtg.Data;  				i += CountTokensToBeSkipped (ptgs' i' dist);  				Ptg nextPtg = ptgs [i + 1];  				if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  					// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  					i++;  					stack.Push (BoolEval.FALSE);  				}  			}  			continue;  		}  		if (attrPtg.IsSkip) {  			int dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			if (stack.Peek () == MissingArgEval.instance) {  				stack.Pop ();  				stack.Push (BlankEval.instance);  			}  			continue;  		}  	}  	if (ptg is ControlPtg) {  		// skip Parentheses' Attr' etc  		continue;  	}  	if (ptg is MemFuncPtg) {  		// can ignore' rest of Tokens for this expression are in OK RPN order  		continue;  	}  	if (ptg is MemErrPtg) {  		continue;  	}  	ValueEval opResult;  	if (ptg is OperationPtg) {  		OperationPtg optg = (OperationPtg)ptg;  		if (optg is UnionPtg) {  			continue;  		}  		int numops = optg.NumberOfOperands;  		ValueEval[] ops = new ValueEval[numops];  		// storing the ops in reverse order since they are popping  		for (int j = numops - 1; j >= 0; j--) {  			ValueEval p = (ValueEval)stack.Pop ();  			ops [j] = p;  		}  		//				logDebug("Invoke " + operation + " (nAgs=" + numops + ")");  		opResult = OperationEvaluatorFactory.Evaluate (optg' ops' ec);  	}  	else {  		opResult = GetEvalForPtg (ptg' ec);  	}  	if (opResult == null) {  		throw new Exception ("Evaluation result must not be null");  	}  	//			logDebug("push " + opResult);  	stack.Push (opResult);  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (ptg is AttrPtg) {  	AttrPtg attrPtg = (AttrPtg)ptg;  	if (attrPtg.IsSum) {  		// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  		// expects the equivalent function Token  		//byte nArgs = 1;  // tAttrSum always Has 1 parameter  		ptg = FuncVarPtg.SUM;  		//.Create("SUM"' nArgs);  	}  	if (attrPtg.IsOptimizedChoose) {  		ValueEval arg0 = stack.Pop ();  		int[] jumpTable = attrPtg.JumpTable;  		int dist;  		int nChoices = jumpTable.Length;  		try {  			int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			if (switchIndex < 1 || switchIndex > nChoices) {  				stack.Push (ErrorEval.VALUE_INVALID);  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			else {  				dist = jumpTable [switchIndex - 1];  			}  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		// Encoded dist for tAttrChoose includes size of jump table' but  		// countTokensToBeSkipped() does not (it counts whole tokens).  		dist -= nChoices * 2 + 2;  		// subtract jump table size  		i += CountTokensToBeSkipped (ptgs' i' dist);  		continue;  	}  	if (attrPtg.IsOptimizedIf) {  		ValueEval arg0 = stack.Pop ();  		bool evaluatedPredicate;  		try {  			evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			attrPtg = (AttrPtg)ptgs [i];  			dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (evaluatedPredicate) {  			// nothing to skip - true param folows  		}  		else {  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			Ptg nextPtg = ptgs [i + 1];  			if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  				// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  				i++;  				stack.Push (BoolEval.FALSE);  			}  		}  		continue;  	}  	if (attrPtg.IsSkip) {  		int dist = attrPtg.Data + 1;  		i += CountTokensToBeSkipped (ptgs' i' dist);  		if (stack.Peek () == MissingArgEval.instance) {  			stack.Pop ();  			stack.Push (BlankEval.instance);  		}  		continue;  	}  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (ptg is AttrPtg) {  	AttrPtg attrPtg = (AttrPtg)ptg;  	if (attrPtg.IsSum) {  		// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  		// expects the equivalent function Token  		//byte nArgs = 1;  // tAttrSum always Has 1 parameter  		ptg = FuncVarPtg.SUM;  		//.Create("SUM"' nArgs);  	}  	if (attrPtg.IsOptimizedChoose) {  		ValueEval arg0 = stack.Pop ();  		int[] jumpTable = attrPtg.JumpTable;  		int dist;  		int nChoices = jumpTable.Length;  		try {  			int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			if (switchIndex < 1 || switchIndex > nChoices) {  				stack.Push (ErrorEval.VALUE_INVALID);  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			else {  				dist = jumpTable [switchIndex - 1];  			}  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		// Encoded dist for tAttrChoose includes size of jump table' but  		// countTokensToBeSkipped() does not (it counts whole tokens).  		dist -= nChoices * 2 + 2;  		// subtract jump table size  		i += CountTokensToBeSkipped (ptgs' i' dist);  		continue;  	}  	if (attrPtg.IsOptimizedIf) {  		ValueEval arg0 = stack.Pop ();  		bool evaluatedPredicate;  		try {  			evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			attrPtg = (AttrPtg)ptgs [i];  			dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (evaluatedPredicate) {  			// nothing to skip - true param folows  		}  		else {  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			Ptg nextPtg = ptgs [i + 1];  			if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  				// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  				i++;  				stack.Push (BoolEval.FALSE);  			}  		}  		continue;  	}  	if (attrPtg.IsSkip) {  		int dist = attrPtg.Data + 1;  		i += CountTokensToBeSkipped (ptgs' i' dist);  		if (stack.Peek () == MissingArgEval.instance) {  			stack.Pop ();  			stack.Push (BlankEval.instance);  		}  		continue;  	}  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (ptg is AttrPtg) {  	AttrPtg attrPtg = (AttrPtg)ptg;  	if (attrPtg.IsSum) {  		// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  		// expects the equivalent function Token  		//byte nArgs = 1;  // tAttrSum always Has 1 parameter  		ptg = FuncVarPtg.SUM;  		//.Create("SUM"' nArgs);  	}  	if (attrPtg.IsOptimizedChoose) {  		ValueEval arg0 = stack.Pop ();  		int[] jumpTable = attrPtg.JumpTable;  		int dist;  		int nChoices = jumpTable.Length;  		try {  			int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			if (switchIndex < 1 || switchIndex > nChoices) {  				stack.Push (ErrorEval.VALUE_INVALID);  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			else {  				dist = jumpTable [switchIndex - 1];  			}  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		// Encoded dist for tAttrChoose includes size of jump table' but  		// countTokensToBeSkipped() does not (it counts whole tokens).  		dist -= nChoices * 2 + 2;  		// subtract jump table size  		i += CountTokensToBeSkipped (ptgs' i' dist);  		continue;  	}  	if (attrPtg.IsOptimizedIf) {  		ValueEval arg0 = stack.Pop ();  		bool evaluatedPredicate;  		try {  			evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			attrPtg = (AttrPtg)ptgs [i];  			dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (evaluatedPredicate) {  			// nothing to skip - true param folows  		}  		else {  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			Ptg nextPtg = ptgs [i + 1];  			if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  				// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  				i++;  				stack.Push (BoolEval.FALSE);  			}  		}  		continue;  	}  	if (attrPtg.IsSkip) {  		int dist = attrPtg.Data + 1;  		i += CountTokensToBeSkipped (ptgs' i' dist);  		if (stack.Peek () == MissingArgEval.instance) {  			stack.Pop ();  			stack.Push (BlankEval.instance);  		}  		continue;  	}  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (ptg is AttrPtg) {  	AttrPtg attrPtg = (AttrPtg)ptg;  	if (attrPtg.IsSum) {  		// Excel prefers To encode 'SUM()' as a tAttr Token' but this evaluator  		// expects the equivalent function Token  		//byte nArgs = 1;  // tAttrSum always Has 1 parameter  		ptg = FuncVarPtg.SUM;  		//.Create("SUM"' nArgs);  	}  	if (attrPtg.IsOptimizedChoose) {  		ValueEval arg0 = stack.Pop ();  		int[] jumpTable = attrPtg.JumpTable;  		int dist;  		int nChoices = jumpTable.Length;  		try {  			int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  			if (switchIndex < 1 || switchIndex > nChoices) {  				stack.Push (ErrorEval.VALUE_INVALID);  				dist = attrPtg.ChooseFuncOffset + 4;  				// +4 for tFuncFar(CHOOSE)  			}  			else {  				dist = jumpTable [switchIndex - 1];  			}  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		// Encoded dist for tAttrChoose includes size of jump table' but  		// countTokensToBeSkipped() does not (it counts whole tokens).  		dist -= nChoices * 2 + 2;  		// subtract jump table size  		i += CountTokensToBeSkipped (ptgs' i' dist);  		continue;  	}  	if (attrPtg.IsOptimizedIf) {  		ValueEval arg0 = stack.Pop ();  		bool evaluatedPredicate;  		try {  			evaluatedPredicate = If.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		}  		catch (EvaluationException e) {  			stack.Push (e.GetErrorEval ());  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			attrPtg = (AttrPtg)ptgs [i];  			dist = attrPtg.Data + 1;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			continue;  		}  		if (evaluatedPredicate) {  			// nothing to skip - true param folows  		}  		else {  			int dist = attrPtg.Data;  			i += CountTokensToBeSkipped (ptgs' i' dist);  			Ptg nextPtg = ptgs [i + 1];  			if (ptgs [i] is AttrPtg && nextPtg is FuncVarPtg) {  				// this is an if statement without a false param (as opposed to MissingArgPtg as the false param)  				i++;  				stack.Push (BoolEval.FALSE);  			}  		}  		continue;  	}  	if (attrPtg.IsSkip) {  		int dist = attrPtg.Data + 1;  		i += CountTokensToBeSkipped (ptgs' i' dist);  		if (stack.Peek () == MissingArgEval.instance) {  			stack.Pop ();  			stack.Push (BlankEval.instance);  		}  		continue;  	}  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (attrPtg.IsOptimizedChoose) {  	ValueEval arg0 = stack.Pop ();  	int[] jumpTable = attrPtg.JumpTable;  	int dist;  	int nChoices = jumpTable.Length;  	try {  		int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		if (switchIndex < 1 || switchIndex > nChoices) {  			stack.Push (ErrorEval.VALUE_INVALID);  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		else {  			dist = jumpTable [switchIndex - 1];  		}  	}  	catch (EvaluationException e) {  		stack.Push (e.GetErrorEval ());  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	// Encoded dist for tAttrChoose includes size of jump table' but  	// countTokensToBeSkipped() does not (it counts whole tokens).  	dist -= nChoices * 2 + 2;  	// subtract jump table size  	i += CountTokensToBeSkipped (ptgs' i' dist);  	continue;  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (attrPtg.IsOptimizedChoose) {  	ValueEval arg0 = stack.Pop ();  	int[] jumpTable = attrPtg.JumpTable;  	int dist;  	int nChoices = jumpTable.Length;  	try {  		int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		if (switchIndex < 1 || switchIndex > nChoices) {  			stack.Push (ErrorEval.VALUE_INVALID);  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		else {  			dist = jumpTable [switchIndex - 1];  		}  	}  	catch (EvaluationException e) {  		stack.Push (e.GetErrorEval ());  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	// Encoded dist for tAttrChoose includes size of jump table' but  	// countTokensToBeSkipped() does not (it counts whole tokens).  	dist -= nChoices * 2 + 2;  	// subtract jump table size  	i += CountTokensToBeSkipped (ptgs' i' dist);  	continue;  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (attrPtg.IsOptimizedChoose) {  	ValueEval arg0 = stack.Pop ();  	int[] jumpTable = attrPtg.JumpTable;  	int dist;  	int nChoices = jumpTable.Length;  	try {  		int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		if (switchIndex < 1 || switchIndex > nChoices) {  			stack.Push (ErrorEval.VALUE_INVALID);  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		else {  			dist = jumpTable [switchIndex - 1];  		}  	}  	catch (EvaluationException e) {  		stack.Push (e.GetErrorEval ());  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	// Encoded dist for tAttrChoose includes size of jump table' but  	// countTokensToBeSkipped() does not (it counts whole tokens).  	dist -= nChoices * 2 + 2;  	// subtract jump table size  	i += CountTokensToBeSkipped (ptgs' i' dist);  	continue;  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (attrPtg.IsOptimizedChoose) {  	ValueEval arg0 = stack.Pop ();  	int[] jumpTable = attrPtg.JumpTable;  	int dist;  	int nChoices = jumpTable.Length;  	try {  		int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  		if (switchIndex < 1 || switchIndex > nChoices) {  			stack.Push (ErrorEval.VALUE_INVALID);  			dist = attrPtg.ChooseFuncOffset + 4;  			// +4 for tFuncFar(CHOOSE)  		}  		else {  			dist = jumpTable [switchIndex - 1];  		}  	}  	catch (EvaluationException e) {  		stack.Push (e.GetErrorEval ());  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	// Encoded dist for tAttrChoose includes size of jump table' but  	// countTokensToBeSkipped() does not (it counts whole tokens).  	dist -= nChoices * 2 + 2;  	// subtract jump table size  	i += CountTokensToBeSkipped (ptgs' i' dist);  	continue;  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: try {  	int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  	if (switchIndex < 1 || switchIndex > nChoices) {  		stack.Push (ErrorEval.VALUE_INVALID);  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	else {  		dist = jumpTable [switchIndex - 1];  	}  }  catch (EvaluationException e) {  	stack.Push (e.GetErrorEval ());  	dist = attrPtg.ChooseFuncOffset + 4;  	// +4 for tFuncFar(CHOOSE)  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: try {  	int switchIndex = Choose.EvaluateFirstArg (arg0' ec.RowIndex' ec.ColumnIndex);  	if (switchIndex < 1 || switchIndex > nChoices) {  		stack.Push (ErrorEval.VALUE_INVALID);  		dist = attrPtg.ChooseFuncOffset + 4;  		// +4 for tFuncFar(CHOOSE)  	}  	else {  		dist = jumpTable [switchIndex - 1];  	}  }  catch (EvaluationException e) {  	stack.Push (e.GetErrorEval ());  	dist = attrPtg.ChooseFuncOffset + 4;  	// +4 for tFuncFar(CHOOSE)  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: if (switchIndex < 1 || switchIndex > nChoices) {  	stack.Push (ErrorEval.VALUE_INVALID);  	dist = attrPtg.ChooseFuncOffset + 4;  	// +4 for tFuncFar(CHOOSE)  }  else {  	dist = jumpTable [switchIndex - 1];  }  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: dist = attrPtg.ChooseFuncOffset + 4;  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: dist = attrPtg.ChooseFuncOffset + 4;  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: dist -= nChoices * 2 + 2;  
Magic Number,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,EvaluateFormula,The following statement contains a magic number: dist -= nChoices * 2 + 2;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [2] = LogicalFunction.ISNA;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [3] = LogicalFunction.ISERROR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [5] = AggregateFunction.AVERAGE;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [6] = AggregateFunction.MIN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [7] = AggregateFunction.MAX;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [8] = new Row ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [9] = new Column ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [10] = new Na ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [11] = new Npv ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [12] = AggregateFunction.STDEV;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [13] = NumericFunction.DOLLAR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [14] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [15] = NumericFunction.SIN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [16] = NumericFunction.COS;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [17] = NumericFunction.TAN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [18] = NumericFunction.ATAN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [19] = new Pi ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [20] = NumericFunction.SQRT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [21] = NumericFunction.EXP;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [22] = NumericFunction.LN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [23] = NumericFunction.LOG10;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [24] = NumericFunction.ABS;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [25] = NumericFunction.INT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [26] = NumericFunction.SIGN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [27] = NumericFunction.ROUND;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [28] = new Lookup ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [29] = new Index ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [30] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [31] = TextFunction.MID;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [32] = TextFunction.LEN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [33] = new Value ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [34] = new True ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [35] = new False ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [36] = new And ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [37] = new Or ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [38] = new Not ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [39] = NumericFunction.MOD;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [40] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [41] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [42] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [43] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [44] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [45] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [46] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [47] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [48] = TextFunction.TEXT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [49] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [50] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [51] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [52] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [53] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [54] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [56] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [57] = FinanceFunction.FV;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [58] = FinanceFunction.NPER;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [59] = FinanceFunction.PMT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [60] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [61] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [62] = new Irr ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [63] = new Rand ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [64] = new Match ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [65] = DateFunc.instance;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [66] = new TimeFunc ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [67] = CalendarFieldFunction.DAY;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [68] = CalendarFieldFunction.MONTH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [69] = CalendarFieldFunction.YEAR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [70] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [71] = CalendarFieldFunction.HOUR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [72] = CalendarFieldFunction.MINUTE;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [73] = CalendarFieldFunction.SECOND;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [74] = new Now ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [75] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [76] = new Rows ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [77] = new Columns ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [79] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [80] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [81] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [82] = TextFunction.SEARCH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [83] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [84] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [85] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [86] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [87] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [88] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [89] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [90] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [91] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [92] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [93] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [94] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [95] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [96] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [97] = NumericFunction.ATAN2;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [98] = NumericFunction.ASIN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [99] = NumericFunction.ACOS;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [101] = new Hlookup ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [102] = new Vlookup ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [103] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [104] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [105] = LogicalFunction.ISREF;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [106] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [107] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [108] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [109] = NumericFunction.LOG;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [110] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [111] = TextFunction.CHAR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [112] = TextFunction.LOWER;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [113] = TextFunction.UPPER;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [114] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [115] = TextFunction.LEFT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [116] = TextFunction.RIGHT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [117] = TextFunction.EXACT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [118] = TextFunction.TRIM;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [119] = new Replace ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [120] = new Substitute ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [121] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [122] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [123] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [124] = TextFunction.FIND;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [125] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [126] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [127] = LogicalFunction.ISTEXT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [128] = LogicalFunction.ISNUMBER;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [129] = LogicalFunction.ISBLANK;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [130] = new T ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [131] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [132] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [133] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [134] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [135] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [136] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [137] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [138] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [139] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [140] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [141] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [142] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [143] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [144] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [145] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [146] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [147] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [149] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [150] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [151] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [152] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [153] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [154] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [155] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [156] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [157] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [158] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [159] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [160] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [161] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [162] = TextFunction.CLEAN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [163] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [164] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [165] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [166] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [167] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [168] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [169] = new Counta ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [170] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [175] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [176] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [177] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [178] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [179] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [180] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [181] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [182] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [183] = AggregateFunction.PRODUCT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [184] = NumericFunction.FACT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [185] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [186] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [187] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [188] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [189] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [190] = LogicalFunction.ISNONTEXT;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [191] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [192] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [193] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [194] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [195] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [196] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [197] = NumericFunction.TRUNC;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [198] = LogicalFunction.ISLOGICAL;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [199] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [200] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [201] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [204] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [205] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [206] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [207] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [208] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [209] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [210] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [211] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [212] = NumericFunction.ROUNDUP;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [213] = NumericFunction.ROUNDDOWN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [214] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [215] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [216] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [219] = new Address ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [220] = new Days360 ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [221] = new Today ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [222] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [227] = AggregateFunction.MEDIAN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [228] = new Sumproduct ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [229] = NumericFunction.SINH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [230] = NumericFunction.COSH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [231] = NumericFunction.TANH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [232] = NumericFunction.ASINH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [233] = NumericFunction.ACOSH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [234] = NumericFunction.ATANH;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [235] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [236] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [237] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [238] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [239] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [240] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [241] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [242] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [243] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [244] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [245] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [246] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [247] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [248] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [250] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [252] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [253] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [254] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [256] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [257] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [258] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [259] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [260] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [261] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [262] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [263] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [264] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [265] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [266] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [267] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [268] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [269] = AggregateFunction.AVEDEV;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [270] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [271] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [272] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [273] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [274] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [275] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [276] = NumericFunction.COMBIN;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [277] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [278] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [279] = new Even ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [280] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [281] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [282] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [283] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [284] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [285] = NumericFunction.FLOOR;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [286] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [287] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [288] = NumericFunction.CEILING;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [289] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [290] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [291] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [292] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [293] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [294] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [295] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [296] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [297] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [298] = new Odd ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [299] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [300] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [301] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [302] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [303] = new Sumxmy2 ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [304] = new Sumx2my2 ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [305] = new Sumx2py2 ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [306] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [307] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [308] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [309] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [310] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [311] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [312] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [313] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [314] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [315] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [316] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [317] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [318] = AggregateFunction.DEVSQ;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [319] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [320] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [321] = AggregateFunction.SUMSQ;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [322] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [323] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [324] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [325] = AggregateFunction.LARGE;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [326] = AggregateFunction.SMALL;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [327] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [328] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [329] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [330] = new Mode ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [331] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [332] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [334] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [335] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [336] = TextFunction.CONCATENATE;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [337] = NumericFunction.POWER;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [338] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [339] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [340] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [341] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [342] = NumericFunction.RADIANS;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [343] = NumericFunction.DEGREES;  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [344] = new Subtotal ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [345] = new Sumif ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [346] = new Countif ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [347] = new Countblank ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [348] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [349] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [350] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [351] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [352] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [353] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [354] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [355] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [356] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [357] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [358] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [359] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [360] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [361] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [362] = new Maxa ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [363] = new Mina ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [364] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [365] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [366] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,ProduceFunctions,The following statement contains a magic number: retval [367] = new NotImplementedFunction ();  
Magic Number,NPOI.SS.Formula.Eval,PercentEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\PercentEval.cs,Evaluate,The following statement contains a magic number: return new NumberEval (d0 / 100);  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length < 2 || args.Length > 5) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length < 2 || args.Length > 5) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: try {  	bool pAbsRow' pAbsCol;  	int row = (int)NumericFunction.SingleOperandEvaluate (args [0]' srcRowIndex' srcColumnIndex);  	int col = (int)NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	int refType;  	if (args.Length > 2) {  		refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  	}  	else {  		refType = REF_ABSOLUTE;  	}  	switch (refType) {  	case REF_ABSOLUTE:  		pAbsRow = true;  		pAbsCol = true;  		break;  	case REF_ROW_ABSOLUTE_COLUMN_RELATIVE:  		pAbsRow = true;  		pAbsCol = false;  		break;  	case REF_ROW_RELATIVE_RELATIVE_ABSOLUTE:  		pAbsRow = false;  		pAbsCol = true;  		break;  	case REF_RELATIVE:  		pAbsRow = false;  		pAbsCol = false;  		break;  	default:  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  	bool a1;  	if (args.Length > 3) {  		ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  		// TODO R1C1 style is not yet supported  		a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  	}  	else {  		a1 = true;  	}  	String sheetName;  	if (args.Length == 5) {  		ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  		sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  	}  	else {  		sheetName = null;  	}  	CellReference ref1 = new CellReference (row - 1' col - 1' pAbsRow' pAbsCol);  	StringBuilder sb = new StringBuilder (32);  	if (sheetName != null) {  		SheetNameFormatter.AppendFormat (sb' sheetName);  		sb.Append ('!');  	}  	sb.Append (ref1.FormatAsString ());  	return new StringEval (sb.ToString ());  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length > 2) {  	refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  }  else {  	refType = REF_ABSOLUTE;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length > 2) {  	refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  }  else {  	refType = REF_ABSOLUTE;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: refType = (int)NumericFunction.SingleOperandEvaluate (args [2]' srcRowIndex' srcColumnIndex);  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length > 3) {  	ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  	// TODO R1C1 style is not yet supported  	a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  }  else {  	a1 = true;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length > 3) {  	ValueEval ve = OperandResolver.GetSingleValue (args [3]' srcRowIndex' srcColumnIndex);  	// TODO R1C1 style is not yet supported  	a1 = ve == MissingArgEval.instance ? true : OperandResolver.CoerceValueToBoolean (ve' false).Value;  }  else {  	a1 = true;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length == 5) {  	ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  	sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  }  else {  	sheetName = null;  }  
Magic Number,NPOI.SS.Formula.Functions,Address,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Address.cs,Evaluate,The following statement contains a magic number: if (args.Length == 5) {  	ValueEval ve = OperandResolver.GetSingleValue (args [4]' srcRowIndex' srcColumnIndex);  	sheetName = ve == MissingArgEval.instance ? null : OperandResolver.CoerceValueToString (ve);  }  else {  	sheetName = null;  }  
Magic Number,NPOI.SS.Formula.Functions,LARGE,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\AggregateFunction.cs,Evaluate,The following statement contains a magic number: if (ops.Length < 2) {  	throw new EvaluationException (ErrorEval.NUM_ERROR);  }  
Magic Number,NPOI.SS.Formula.Functions,SMALL,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\AggregateFunction.cs,Evaluate,The following statement contains a magic number: if (ops.Length < 2) {  	throw new EvaluationException (ErrorEval.NUM_ERROR);  }  
Magic Number,NPOI.SS.Formula.Functions,CalendarFieldFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\CalendarFieldFunction.cs,GetCalField,The following statement contains a magic number: if ((int)serialDate == 0) {  	// Special weird case  	// day zero should be 31-Dec-1899'  but Excel seems to think it is 0-Jan-1900  	switch (_dateFieldId) {  	case YEAR_ID:  		return 1900;  	case MONTH_ID:  		return 1;  	case DAY_OF_MONTH_ID:  		return 0;  	}  	//throw new InvalidOperationException("bad date field " + _dateFieldId);  }  
Magic Number,NPOI.SS.Formula.Functions,CalendarFieldFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\CalendarFieldFunction.cs,GetCalField,The following statement contains a magic number: switch (_dateFieldId) {  case YEAR_ID:  	return 1900;  case MONTH_ID:  	return 1;  case DAY_OF_MONTH_ID:  	return 0;  }  
Magic Number,NPOI.SS.Formula.Functions,CalendarFieldFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\CalendarFieldFunction.cs,GetCalField,The following statement contains a magic number: return 1900;  
Magic Number,NPOI.SS.Formula.Functions,Choose,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Choose.cs,Evaluate,The following statement contains a magic number: if (args.Length < 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Count,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Count.cs,Evaluate,The following statement contains a magic number: if (nArgs > 30) {  	// too many arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Counta,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Counta.cs,Evaluate,The following statement contains a magic number: if (nArgs > 30) {  	// too many arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Countif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Countif.cs,ParseError,The following statement contains a magic number: if (value.Length < 4 || value [0] != '#') {  	return null;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900 && month == 2 && day == 29) {  	return 60.0;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900 && month == 2 && day == 29) {  	return 60.0;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900 && month == 2 && day == 29) {  	return 60.0;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900 && month == 2 && day == 29) {  	return 60.0;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: return 60.0;  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900) {  	if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  		day--;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900) {  	if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  		day--;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900) {  	if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  		day--;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if (year == 1900) {  	if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  		day--;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  	day--;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  	day--;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,Evaluate,The following statement contains a magic number: if ((month == 1 && day >= 60) || (month == 2 && day >= 30)) {  	day--;  }  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,GetYear,The following statement contains a magic number: return year < 1900 ? 1900 + year : year;  
Magic Number,NPOI.SS.Formula.Functions,DateFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\DateFunc.cs,GetYear,The following statement contains a magic number: return year < 1900 ? 1900 + year : year;  
Magic Number,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetStartingDate,The following statement contains a magic number: if (IsLastDayOfMonth (startingDate)) {  	startingDate = new DateTime (startingDate.Year' startingDate.Month' 30' startingDate.Hour' startingDate.Minute' startingDate.Second);  }  
Magic Number,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetStartingDate,The following statement contains a magic number: startingDate = new DateTime (startingDate.Year' startingDate.Month' 30' startingDate.Hour' startingDate.Minute' startingDate.Second);  
Magic Number,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetEndingDateAccordingToStartingDate,The following statement contains a magic number: if (IsLastDayOfMonth (endingDate)) {  	if (startingDate.Day < 30) {  		endingDate = GetFirstDayOfNextMonth (endingDate);  	}  }  
Magic Number,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetEndingDateAccordingToStartingDate,The following statement contains a magic number: if (startingDate.Day < 30) {  	endingDate = GetFirstDayOfNextMonth (endingDate);  }  
Magic Number,NPOI.SS.Formula.Functions,Days360,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Days360.cs,GetFirstDayOfNextMonth,The following statement contains a magic number: if (date.Month < 12) {  	newDate = new DateTime (date.Year' date.Month + 1' 1' date.Hour' date.Minute' date.Second);  }  else {  	newDate = new DateTime (date.Year + 1' 1' 1' date.Hour' date.Minute' date.Second);  }  
Magic Number,NPOI.SS.Formula.Functions,Degrees,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Degrees.cs,Evaluate,The following statement contains a magic number: return d * 180 / Math.PI;  
Magic Number,NPOI.SS.Formula.Functions,Even,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Even.cs,calcEven,The following statement contains a magic number: return x + 2;  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (ds.Length) {  case 5:  	arg4 = ds [4];  	break;  case 4:  	arg3 = ds [3];  	break;  case 3:  	break;  default:  	throw new ArgumentException ("Wrong number of arguments");  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (ds.Length) {  case 5:  	arg4 = ds [4];  	break;  case 4:  	arg3 = ds [3];  	break;  case 3:  	break;  default:  	throw new ArgumentException ("Wrong number of arguments");  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (ds.Length) {  case 5:  	arg4 = ds [4];  	break;  case 4:  	arg3 = ds [3];  	break;  case 3:  	break;  default:  	throw new ArgumentException ("Wrong number of arguments");  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (ds.Length) {  case 5:  	arg4 = ds [4];  	break;  case 4:  	arg3 = ds [3];  	break;  case 3:  	break;  default:  	throw new ArgumentException ("Wrong number of arguments");  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: switch (ds.Length) {  case 5:  	arg4 = ds [4];  	break;  case 4:  	arg3 = ds [3];  	break;  case 3:  	break;  default:  	throw new ArgumentException ("Wrong number of arguments");  }  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: arg4 = ds [4];  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: arg3 = ds [3];  
Magic Number,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (ds [0]' ds [1]' ds [2]' arg3' arg4 != 0.0);  
Magic Number,NPOI.SS.Formula.Functions,Fixed2ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed2ArgFunction.cs,Evaluate,The following statement contains a magic number: if (args.Length != 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Fixed3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed3ArgFunction.cs,Evaluate,The following statement contains a magic number: if (args.Length != 3) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Fixed3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed3ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  
Magic Number,NPOI.SS.Formula.Functions,Fixed4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed4ArgFunction.cs,Evaluate,The following statement contains a magic number: if (args.Length != 4) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Fixed4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed4ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Functions,Fixed4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Fixed4ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 4:  	arg3 = args [3];  	// important: assumed array element Is never null  	break;  case 3:  	break;  default:  	// wrong number of arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 4:  	arg3 = args [3];  	// important: assumed array element Is never null  	break;  case 3:  	break;  default:  	// wrong number of arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 4:  	arg3 = args [3];  	// important: assumed array element Is never null  	break;  case 3:  	break;  default:  	// wrong number of arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The following statement contains a magic number: arg3 = args [3];  
Magic Number,NPOI.SS.Formula.Functions,Hlookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Hlookup.cs,Evaluate,The following statement contains a magic number: try {  	// Evaluation order:  	// arg0 lookup_value' arg1 table_array' arg3 range_lookup' Find lookup value' arg2 row_index' fetch result  	ValueEval lookupValue = OperandResolver.GetSingleValue (args [0]' srcCellRow' srcCellCol);  	AreaEval tableArray = LookupUtils.ResolveTableArrayArg (args [1]);  	bool IsRangeLookup = LookupUtils.ResolveRangeLookupArg (arg3' srcCellRow' srcCellCol);  	int colIndex = LookupUtils.LookupIndexOfValue (lookupValue' LookupUtils.CreateRowVector (tableArray' 0)' IsRangeLookup);  	int rowIndex = LookupUtils.ResolveRowOrColIndexArg (args [2]' srcCellRow' srcCellCol);  	ValueVector resultCol = CreateResultColumnVector (tableArray' rowIndex);  	return resultCol.GetItem (colIndex);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,Evaluate,The following statement contains a magic number: try {  	ValueEval ve = OperandResolver.GetSingleValue (args [0]' ec.RowIndex' ec.ColumnIndex);  	text = OperandResolver.CoerceValueToString (ve);  	switch (args.Length) {  	case 1:  		isA1style = true;  		break;  	case 2:  		isA1style = EvaluateBooleanArg (args [1]' ec);  		break;  	default:  		return ErrorEval.VALUE_INVALID;  	}  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 1:  	isA1style = true;  	break;  case 2:  	isA1style = EvaluateBooleanArg (args [1]' ec);  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: if (firstChar == '\'') {  	// workbookName or sheetName needs quoting  	// quotes go around both  	if (text [lastIx] != '\'') {  		return null;  	}  	firstChar = text [1];  	if (Char.IsWhiteSpace (firstChar)) {  		return null;  	}  	String wbName;  	int sheetStartPos;  	if (firstChar == '[') {  		int rbPos = text.ToString ().LastIndexOf (']');  		if (rbPos < 0) {  			return null;  		}  		wbName = UnescapeString (text.Substring (2' rbPos - 2));  		if (wbName == null || CanTrim (wbName)) {  			return null;  		}  		sheetStartPos = rbPos + 1;  	}  	else {  		wbName = null;  		sheetStartPos = 1;  	}  	// else - just sheet name  	String sheetName = UnescapeString (text.Substring (sheetStartPos' lastIx - sheetStartPos));  	if (sheetName == null) {  		// note - when quoted' sheetName can  		// start/end with whitespace  		return null;  	}  	return new String[] {  		wbName'  		sheetName'  	};  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: if (firstChar == '\'') {  	// workbookName or sheetName needs quoting  	// quotes go around both  	if (text [lastIx] != '\'') {  		return null;  	}  	firstChar = text [1];  	if (Char.IsWhiteSpace (firstChar)) {  		return null;  	}  	String wbName;  	int sheetStartPos;  	if (firstChar == '[') {  		int rbPos = text.ToString ().LastIndexOf (']');  		if (rbPos < 0) {  			return null;  		}  		wbName = UnescapeString (text.Substring (2' rbPos - 2));  		if (wbName == null || CanTrim (wbName)) {  			return null;  		}  		sheetStartPos = rbPos + 1;  	}  	else {  		wbName = null;  		sheetStartPos = 1;  	}  	// else - just sheet name  	String sheetName = UnescapeString (text.Substring (sheetStartPos' lastIx - sheetStartPos));  	if (sheetName == null) {  		// note - when quoted' sheetName can  		// start/end with whitespace  		return null;  	}  	return new String[] {  		wbName'  		sheetName'  	};  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: if (firstChar == '[') {  	int rbPos = text.ToString ().LastIndexOf (']');  	if (rbPos < 0) {  		return null;  	}  	wbName = UnescapeString (text.Substring (2' rbPos - 2));  	if (wbName == null || CanTrim (wbName)) {  		return null;  	}  	sheetStartPos = rbPos + 1;  }  else {  	wbName = null;  	sheetStartPos = 1;  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: if (firstChar == '[') {  	int rbPos = text.ToString ().LastIndexOf (']');  	if (rbPos < 0) {  		return null;  	}  	wbName = UnescapeString (text.Substring (2' rbPos - 2));  	if (wbName == null || CanTrim (wbName)) {  		return null;  	}  	sheetStartPos = rbPos + 1;  }  else {  	wbName = null;  	sheetStartPos = 1;  }  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: wbName = UnescapeString (text.Substring (2' rbPos - 2));  
Magic Number,NPOI.SS.Formula.Functions,Indirect,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Indirect.cs,ParseWorkbookAndSheetName,The following statement contains a magic number: wbName = UnescapeString (text.Substring (2' rbPos - 2));  
Magic Number,NPOI.SS.Formula.Functions,Int,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Int.cs,Evaluate,The following statement contains a magic number: return Math.Round (d - 0.5);  
Magic Number,NPOI.SS.Formula.Functions,Irr,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Irr.cs,Evaluate,The following statement contains a magic number: if (args.Length == 0 || args.Length > 2) {  	// Wrong number of arguments  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Irr,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Irr.cs,Evaluate,The following statement contains a magic number: try {  	double[] values = AggregateFunction.ValueCollector.CollectValues (args [0]);  	double guess;  	if (args.Length == 2) {  		guess = NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  	}  	else {  		guess = 0.1d;  	}  	double result = irr (values' guess);  	NumericFunction.CheckValue (result);  	return new NumberEval (result);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Irr,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Irr.cs,Evaluate,The following statement contains a magic number: if (args.Length == 2) {  	guess = NumericFunction.SingleOperandEvaluate (args [1]' srcRowIndex' srcColumnIndex);  }  else {  	guess = 0.1d;  }  
Magic Number,NPOI.SS.Formula.Functions,Lookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Lookup.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	break;  case 2:  	// complex rules to choose lookupVector and resultVector from the single area ref  	throw new Exception ("Two arg version of LOOKUP not supported yet");  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Lookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Lookup.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	break;  case 2:  	// complex rules to choose lookupVector and resultVector from the single area ref  	throw new Exception ("Two arg version of LOOKUP not supported yet");  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Lookup,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Lookup.cs,Evaluate,The following statement contains a magic number: try {  	ValueEval lookupValue = OperandResolver.GetSingleValue (args [0]' srcCellRow' srcCellCol);  	AreaEval aeLookupVector = LookupUtils.ResolveTableArrayArg (args [1]);  	AreaEval aeResultVector = LookupUtils.ResolveTableArrayArg (args [2]);  	ValueVector lookupVector = CreateVector (aeLookupVector);  	ValueVector resultVector = CreateVector (aeResultVector);  	if (lookupVector.Size > resultVector.Size) {  		// Excel seems to handle this by accessing past the end of the result vector.  		throw new Exception ("Lookup vector and result vector of differing sizes not supported yet");  	}  	int index = LookupUtils.LookupIndexOfValue (lookupValue' lookupVector' true);  	return resultVector.GetItem (index);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,BinarySearchIndexes,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\LookupUtils.cs,GetMidIx,The following statement contains a magic number: if (ixDiff < 2) {  	return -1;  }  
Magic Number,NPOI.SS.Formula.Functions,BinarySearchIndexes,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\LookupUtils.cs,GetMidIx,The following statement contains a magic number: return _lowIx + (ixDiff / 2);  
Magic Number,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	try {  		match_type = EvaluateMatchTypeArg (args [2]' srcCellRow' srcCellCol);  	}  	catch (EvaluationException) {  		// Excel/MATCH() seems to have slightly abnormal handling of errors with  		// the last parameter.  Errors do not propagate up.  Every error Gets  		// translated into #REF!  		return ErrorEval.REF_INVALID;  	}  	break;  case 2:  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	try {  		match_type = EvaluateMatchTypeArg (args [2]' srcCellRow' srcCellCol);  	}  	catch (EvaluationException) {  		// Excel/MATCH() seems to have slightly abnormal handling of errors with  		// the last parameter.  Errors do not propagate up.  Every error Gets  		// translated into #REF!  		return ErrorEval.REF_INVALID;  	}  	break;  case 2:  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	try {  		match_type = EvaluateMatchTypeArg (args [2]' srcCellRow' srcCellCol);  	}  	catch (EvaluationException) {  		// Excel/MATCH() seems to have slightly abnormal handling of errors with  		// the last parameter.  Errors do not propagate up.  Every error Gets  		// translated into #REF!  		return ErrorEval.REF_INVALID;  	}  	break;  case 2:  	break;  default:  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,The following statement contains a magic number: try {  	match_type = EvaluateMatchTypeArg (args [2]' srcCellRow' srcCellCol);  }  catch (EvaluationException) {  	// Excel/MATCH() seems to have slightly abnormal handling of errors with  	// the last parameter.  Errors do not propagate up.  Every error Gets  	// translated into #REF!  	return ErrorEval.REF_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Match,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Match.cs,Evaluate,The following statement contains a magic number: match_type = EvaluateMatchTypeArg (args [2]' srcCellRow' srcCellCol);  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,round,The following statement contains a magic number: if (double.IsNaN (n) || double.IsInfinity (n)) {  	retval = double.NaN;  }  else {  	//if (p != 0)  	//{  	decimal temp = (decimal)Math.Pow (10' p);  	retval = (double)(Math.Round ((decimal)n * temp) / temp);  	//}  	//else  	//{  	//    retval = Math.Round(n);  	//}  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundUp,The following statement contains a magic number: if (double.IsNaN (n) || double.IsInfinity (n)) {  	retval = double.NaN;  }  else {  	if (p != 0) {  		double temp = Math.Pow (10' p);  		double nat = Math.Abs (n * temp);  		retval = sign (n) * ((nat == (long)nat) ? nat / temp : Math.Round (nat + 0.5) / temp);  	}  	else {  		double na = Math.Abs (n);  		retval = sign (n) * ((na == (long)na) ? na : (long)na + 1);  	}  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundUp,The following statement contains a magic number: if (double.IsNaN (n) || double.IsInfinity (n)) {  	retval = double.NaN;  }  else {  	if (p != 0) {  		double temp = Math.Pow (10' p);  		double nat = Math.Abs (n * temp);  		retval = sign (n) * ((nat == (long)nat) ? nat / temp : Math.Round (nat + 0.5) / temp);  	}  	else {  		double na = Math.Abs (n);  		retval = sign (n) * ((na == (long)na) ? na : (long)na + 1);  	}  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundUp,The following statement contains a magic number: if (p != 0) {  	double temp = Math.Pow (10' p);  	double nat = Math.Abs (n * temp);  	retval = sign (n) * ((nat == (long)nat) ? nat / temp : Math.Round (nat + 0.5) / temp);  }  else {  	double na = Math.Abs (n);  	retval = sign (n) * ((na == (long)na) ? na : (long)na + 1);  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundUp,The following statement contains a magic number: if (p != 0) {  	double temp = Math.Pow (10' p);  	double nat = Math.Abs (n * temp);  	retval = sign (n) * ((nat == (long)nat) ? nat / temp : Math.Round (nat + 0.5) / temp);  }  else {  	double na = Math.Abs (n);  	retval = sign (n) * ((na == (long)na) ? na : (long)na + 1);  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundUp,The following statement contains a magic number: retval = sign (n) * ((nat == (long)nat) ? nat / temp : Math.Round (nat + 0.5) / temp);  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundDown,The following statement contains a magic number: if (double.IsNaN (n) || double.IsInfinity (n)) {  	retval = double.NaN;  }  else {  	if (p != 0) {  		double temp = Math.Pow (10' p);  		retval = sign (n) * Math.Round ((Math.Abs (n) * temp) - 0.5' MidpointRounding.AwayFromZero) / temp;  	}  	else {  		retval = (long)n;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundDown,The following statement contains a magic number: if (double.IsNaN (n) || double.IsInfinity (n)) {  	retval = double.NaN;  }  else {  	if (p != 0) {  		double temp = Math.Pow (10' p);  		retval = sign (n) * Math.Round ((Math.Abs (n) * temp) - 0.5' MidpointRounding.AwayFromZero) / temp;  	}  	else {  		retval = (long)n;  	}  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundDown,The following statement contains a magic number: if (p != 0) {  	double temp = Math.Pow (10' p);  	retval = sign (n) * Math.Round ((Math.Abs (n) * temp) - 0.5' MidpointRounding.AwayFromZero) / temp;  }  else {  	retval = (long)n;  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundDown,The following statement contains a magic number: if (p != 0) {  	double temp = Math.Pow (10' p);  	retval = sign (n) * Math.Round ((Math.Abs (n) * temp) - 0.5' MidpointRounding.AwayFromZero) / temp;  }  else {  	retval = (long)n;  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,roundDown,The following statement contains a magic number: retval = sign (n) * Math.Round ((Math.Abs (n) * temp) - 0.5' MidpointRounding.AwayFromZero) / temp;  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,factorial,The following statement contains a magic number: if (n >= 0) {  	if (n <= 170) {  		for (int i = 1; i <= n; i++) {  			d *= i;  		}  	}  	else {  		d = double.PositiveInfinity;  	}  }  else {  	d = double.NaN;  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,factorial,The following statement contains a magic number: if (n <= 170) {  	for (int i = 1; i <= n; i++) {  		d *= i;  	}  }  else {  	d = double.PositiveInfinity;  }  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,acosh,The following statement contains a magic number: return Math.Log (Math.Sqrt (Math.Pow (d' 2) - 1) + d);  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,atanh,The following statement contains a magic number: return Math.Log ((1 + d) / (1 - d)) / 2;  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,cosh,The following statement contains a magic number: d = (ePowX + ePowNegX) / 2;  
Magic Number,NPOI.SS.Formula.Functions,MathX,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\MathX.cs,sinh,The following statement contains a magic number: d = (ePowX - ePowNegX) / 2;  
Magic Number,NPOI.SS.Formula.Functions,Mode,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Mode.cs,Evaluate,The following statement contains a magic number: if (v.Length < 2) {  	throw new EvaluationException (ErrorEval.NA);  }  
Magic Number,NPOI.SS.Formula.Functions,Npv,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Npv.cs,Evaluate,The following statement contains a magic number: if (nArgs < 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Poisson,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Numeric\Poisson.cs,Factorial,The following statement contains a magic number: if (n < 0 || n > 20) {  	throw new ArgumentException ("Valid argument should be in the range [0..20]");  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: if (args.Length < 3 || args.Length > 5) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: if (args.Length < 3 || args.Length > 5) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: try {  	BaseRef baseRef = EvaluateBaseRef (args [0]);  	int rowOffset = EvaluateIntArg (args [1]' srcCellRow' srcCellCol);  	int columnOffset = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	int height = baseRef.Height;  	int width = baseRef.Width;  	switch (args.Length) {  	case 5:  		width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  		break;  	case 4:  		height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  		break;  	}  	// Zero height or width raises #REF! error  	if (height == 0 || width == 0) {  		return ErrorEval.REF_INVALID;  	}  	LinearOffsetRange rowOffsetRange = new LinearOffsetRange (rowOffset' height);  	LinearOffsetRange colOffsetRange = new LinearOffsetRange (columnOffset' width);  	return CreateOffset (baseRef' rowOffsetRange' colOffsetRange);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: try {  	BaseRef baseRef = EvaluateBaseRef (args [0]);  	int rowOffset = EvaluateIntArg (args [1]' srcCellRow' srcCellCol);  	int columnOffset = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	int height = baseRef.Height;  	int width = baseRef.Width;  	switch (args.Length) {  	case 5:  		width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  		break;  	case 4:  		height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  		break;  	}  	// Zero height or width raises #REF! error  	if (height == 0 || width == 0) {  		return ErrorEval.REF_INVALID;  	}  	LinearOffsetRange rowOffsetRange = new LinearOffsetRange (rowOffset' height);  	LinearOffsetRange colOffsetRange = new LinearOffsetRange (columnOffset' width);  	return CreateOffset (baseRef' rowOffsetRange' colOffsetRange);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: try {  	BaseRef baseRef = EvaluateBaseRef (args [0]);  	int rowOffset = EvaluateIntArg (args [1]' srcCellRow' srcCellCol);  	int columnOffset = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	int height = baseRef.Height;  	int width = baseRef.Width;  	switch (args.Length) {  	case 5:  		width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  		break;  	case 4:  		height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  		break;  	}  	// Zero height or width raises #REF! error  	if (height == 0 || width == 0) {  		return ErrorEval.REF_INVALID;  	}  	LinearOffsetRange rowOffsetRange = new LinearOffsetRange (rowOffset' height);  	LinearOffsetRange colOffsetRange = new LinearOffsetRange (columnOffset' width);  	return CreateOffset (baseRef' rowOffsetRange' colOffsetRange);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: try {  	BaseRef baseRef = EvaluateBaseRef (args [0]);  	int rowOffset = EvaluateIntArg (args [1]' srcCellRow' srcCellCol);  	int columnOffset = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	int height = baseRef.Height;  	int width = baseRef.Width;  	switch (args.Length) {  	case 5:  		width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  		break;  	case 4:  		height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  		break;  	}  	// Zero height or width raises #REF! error  	if (height == 0 || width == 0) {  		return ErrorEval.REF_INVALID;  	}  	LinearOffsetRange rowOffsetRange = new LinearOffsetRange (rowOffset' height);  	LinearOffsetRange colOffsetRange = new LinearOffsetRange (columnOffset' width);  	return CreateOffset (baseRef' rowOffsetRange' colOffsetRange);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: try {  	BaseRef baseRef = EvaluateBaseRef (args [0]);  	int rowOffset = EvaluateIntArg (args [1]' srcCellRow' srcCellCol);  	int columnOffset = EvaluateIntArg (args [2]' srcCellRow' srcCellCol);  	int height = baseRef.Height;  	int width = baseRef.Width;  	switch (args.Length) {  	case 5:  		width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  		break;  	case 4:  		height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  		break;  	}  	// Zero height or width raises #REF! error  	if (height == 0 || width == 0) {  		return ErrorEval.REF_INVALID;  	}  	LinearOffsetRange rowOffsetRange = new LinearOffsetRange (rowOffset' height);  	LinearOffsetRange colOffsetRange = new LinearOffsetRange (columnOffset' width);  	return CreateOffset (baseRef' rowOffsetRange' colOffsetRange);  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 5:  	width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  	break;  case 4:  	height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	break;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 5:  	width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  	break;  case 4:  	height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	break;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 5:  	width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  	break;  case 4:  	height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	break;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 5:  	width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  	break;  case 4:  	height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	break;  }  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  
Magic Number,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following statement contains a magic number: height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  
Magic Number,NPOI.SS.Formula.Functions,Radians,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Radians.cs,Evaluate,The following statement contains a magic number: return d * Math.PI / 180;  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: if (v != null && v.Length >= 1) {  	int n = v.Length;  	Array.Sort (v);  	r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  }  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: if (v != null && v.Length >= 1) {  	int n = v.Length;  	Array.Sort (v);  	r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  }  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: if (v != null && v.Length >= 1) {  	int n = v.Length;  	Array.Sort (v);  	r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  }  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: if (v != null && v.Length >= 1) {  	int n = v.Length;  	Array.Sort (v);  	r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  }  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: if (v != null && v.Length >= 1) {  	int n = v.Length;  	Array.Sort (v);  	r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  }  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  
Magic Number,NPOI.SS.Formula.Functions,StatsLib,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\StatsLib.cs,median,The following statement contains a magic number: r = (n % 2 == 0) ? (v [n / 2] + v [n / 2 - 1]) / 2 : v [n / 2];  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: if (functionCode > 100 && functionCode < 112) {  	throw new NotImplementedException ("SUBTOTAL - with 'exclude hidden values' option");  }  
Magic Number,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following statement contains a magic number: if (functionCode > 100 && functionCode < 112) {  	throw new NotImplementedException ("SUBTOTAL - with 'exclude hidden values' option");  }  
Magic Number,NPOI.SS.Formula.Functions,CHAR,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\CHAR.cs,Evaluate,The following statement contains a magic number: try {  	arg = TextFunction.EvaluateIntArg (arg0' srcRowIndex' srcColumnIndex);  	if (arg < 0 || arg >= 256) {  		throw new EvaluationException (ErrorEval.VALUE_INVALID);  	}  }  catch (EvaluationException e) {  	return e.GetErrorEval ();  }  
Magic Number,NPOI.SS.Formula.Functions,CHAR,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\CHAR.cs,Evaluate,The following statement contains a magic number: if (arg < 0 || arg >= 256) {  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Functions,Exact,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Exact.cs,EvaluateFunc,The following statement contains a magic number: if (args.Length != 2) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Mid,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Mid.cs,EvaluateFunc,The following statement contains a magic number: if (args.Length != 3) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Replace,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Replace.cs,EvaluateFunc,The following statement contains a magic number: if (args.Length != 4) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,The following statement contains a magic number: if (args.Length < 3 || args.Length > 4) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,The following statement contains a magic number: if (args.Length < 3 || args.Length > 4) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,The following statement contains a magic number: switch (args.Length) {  case 4:  	int instanceNumber = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	if (instanceNumber < 1) {  		return ErrorEval.VALUE_INVALID;  	}  	result = ReplaceOneOccurrence (oldStr' searchStr' newStr' instanceNumber);  	break;  case 3:  	result = ReplaceAllOccurrences (oldStr' searchStr' newStr);  	break;  default:  	throw new InvalidOperationException ("Cannot happen");  }  
Magic Number,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,The following statement contains a magic number: switch (args.Length) {  case 4:  	int instanceNumber = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	if (instanceNumber < 1) {  		return ErrorEval.VALUE_INVALID;  	}  	result = ReplaceOneOccurrence (oldStr' searchStr' newStr' instanceNumber);  	break;  case 3:  	result = ReplaceAllOccurrences (oldStr' searchStr' newStr);  	break;  default:  	throw new InvalidOperationException ("Cannot happen");  }  
Magic Number,NPOI.SS.Formula.Functions,Substitute,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Substitute.cs,EvaluateFunc,The following statement contains a magic number: switch (args.Length) {  case 4:  	int instanceNumber = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	if (instanceNumber < 1) {  		return ErrorEval.VALUE_INVALID;  	}  	result = ReplaceOneOccurrence (oldStr' searchStr' newStr' instanceNumber);  	break;  case 3:  	result = ReplaceAllOccurrences (oldStr' searchStr' newStr);  	break;  default:  	throw new InvalidOperationException ("Cannot happen");  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (Regex.Match (s1' @"^[\d'\#'\.'\$'\']+$").Success) {  	//TODO: simulate DecimalFormat class in java.  	FormatBase formatter = new DecimalFormat (s1);  	return new StringEval (formatter.Format (s0));  }  else if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (s1.IndexOf ("/"' StringComparison.Ordinal) == s1.LastIndexOf ("/"' StringComparison.Ordinal) && s1.IndexOf ("/"' StringComparison.Ordinal) >= 0 && !s1.Contains ("-")) {  	double wholePart = Math.Floor (s0);  	double decPart = s0 - wholePart;  	if (wholePart * decPart == 0) {  		return new StringEval ("0");  	}  	String[] parts = s1.Split (' ');  	String[] fractParts;  	if (parts.Length == 2) {  		fractParts = parts [1].Split ('/');  	}  	else {  		fractParts = s1.Split ('/');  	}  	if (fractParts.Length == 2) {  		double minVal = 1.0;  		double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  		double currNeum = 0;  		for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  			for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  				if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  					currDenom = i;  					currNeum = i2;  					minVal = Math.Abs ((double)i2 / (double)i - decPart);  				}  			}  		}  		FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  		FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  		if (parts.Length == 2) {  			FormatBase wholeFormatter = new DecimalFormat (parts [0]);  			String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  		else {  			String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  			return new StringEval (result);  		}  	}  	else {  		return ErrorEval.VALUE_INVALID;  	}  }  else {  	return TryParseDateTime (s0' s1);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (parts.Length == 2) {  	fractParts = parts [1].Split ('/');  }  else {  	fractParts = s1.Split ('/');  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (fractParts.Length == 2) {  	double minVal = 1.0;  	double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  	double currNeum = 0;  	for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  		for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  			if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  				currDenom = i;  				currNeum = i2;  				minVal = Math.Abs ((double)i2 / (double)i - decPart);  			}  		}  	}  	FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  	FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  	if (parts.Length == 2) {  		FormatBase wholeFormatter = new DecimalFormat (parts [0]);  		String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  	else {  		String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  }  else {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (fractParts.Length == 2) {  	double minVal = 1.0;  	double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  	double currNeum = 0;  	for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  		for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  			if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  				currDenom = i;  				currNeum = i2;  				minVal = Math.Abs ((double)i2 / (double)i - decPart);  			}  		}  	}  	FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  	FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  	if (parts.Length == 2) {  		FormatBase wholeFormatter = new DecimalFormat (parts [0]);  		String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  	else {  		String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  }  else {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (fractParts.Length == 2) {  	double minVal = 1.0;  	double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  	double currNeum = 0;  	for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  		for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  			if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  				currDenom = i;  				currNeum = i2;  				minVal = Math.Abs ((double)i2 / (double)i - decPart);  			}  		}  	}  	FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  	FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  	if (parts.Length == 2) {  		FormatBase wholeFormatter = new DecimalFormat (parts [0]);  		String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  	else {  		String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  }  else {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (fractParts.Length == 2) {  	double minVal = 1.0;  	double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  	double currNeum = 0;  	for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  		for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  			if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  				currDenom = i;  				currNeum = i2;  				minVal = Math.Abs ((double)i2 / (double)i - decPart);  			}  		}  	}  	FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  	FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  	if (parts.Length == 2) {  		FormatBase wholeFormatter = new DecimalFormat (parts [0]);  		String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  	else {  		String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  }  else {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (fractParts.Length == 2) {  	double minVal = 1.0;  	double currDenom = Math.Pow (10' fractParts [1].Length) - 1d;  	double currNeum = 0;  	for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  		for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  			if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  				currDenom = i;  				currNeum = i2;  				minVal = Math.Abs ((double)i2 / (double)i - decPart);  			}  		}  	}  	FormatBase neumFormatter = new DecimalFormat (fractParts [0]);  	FormatBase denomFormatter = new DecimalFormat (fractParts [1]);  	if (parts.Length == 2) {  		FormatBase wholeFormatter = new DecimalFormat (parts [0]);  		String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  	else {  		String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  		return new StringEval (result);  	}  }  else {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  	for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  		if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  			currDenom = i;  			currNeum = i2;  			minVal = Math.Abs ((double)i2 / (double)i - decPart);  		}  	}  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: for (int i = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i > 0; i--) {  	for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  		if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  			currDenom = i;  			currNeum = i2;  			minVal = Math.Abs ((double)i2 / (double)i - decPart);  		}  	}  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: for (int i2 = (int)(Math.Pow (10' fractParts [1].Length) - 1d); i2 > 0; i2--) {  	if (minVal >= Math.Abs ((double)i2 / (double)i - decPart)) {  		currDenom = i;  		currNeum = i2;  		minVal = Math.Abs ((double)i2 / (double)i - decPart);  	}  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,Evaluate,The following statement contains a magic number: if (parts.Length == 2) {  	FormatBase wholeFormatter = new DecimalFormat (parts [0]);  	String result = wholeFormatter.Format (wholePart) + " " + neumFormatter.Format (currNeum) + "/" + denomFormatter.Format (currDenom);  	return new StringEval (result);  }  else {  	String result = neumFormatter.Format (currNeum + (currDenom * wholePart)) + "/" + denomFormatter.Format (currDenom);  	return new StringEval (result);  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: try {  	FormatBase dateFormatter = new SimpleDateFormat (s1);  	//first month of java Gregorian Calendar month field is 0  	DateTime dt = new DateTime (1899' 12' 30' 0' 0' 0);  	dt = dt.AddDays ((int)Math.Floor (s0));  	double dayFraction = s0 - Math.Floor (s0);  	dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  	return new StringEval (dateFormatter.Format (dt));  }  catch (Exception) {  	return ErrorEval.VALUE_INVALID;  }  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  
Magic Number,NPOI.SS.Formula.Functions,Text,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\Text.cs,TryParseDateTime,The following statement contains a magic number: dt = dt.AddMilliseconds ((int)Math.Round (dayFraction * 24 * 60 * 60 * 1000));  
Magic Number,NPOI.SS.Formula.Functions,TextFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Text\TextFunction.cs,IsPrintable,The following statement contains a magic number: return charCode >= 32;  
Magic Number,NPOI.SS.Formula.Functions,TimeFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\TimeFunc.cs,Evaluate,The following statement contains a magic number: if (hours > 32767 || minutes > 32767 || seconds > 32767) {  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Functions,TimeFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\TimeFunc.cs,Evaluate,The following statement contains a magic number: if (hours > 32767 || minutes > 32767 || seconds > 32767) {  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Functions,TimeFunc,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\TimeFunc.cs,Evaluate,The following statement contains a magic number: if (hours > 32767 || minutes > 32767 || seconds > 32767) {  	throw new EvaluationException (ErrorEval.VALUE_INVALID);  }  
Magic Number,NPOI.SS.Formula.Functions,Var1or2ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var1or2ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 1:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]);  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following statement contains a magic number: return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  
Magic Number,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,FunctionDataBuilder,The following statement contains a magic number: _functionDataByName = new Hashtable (sizeEstimate * 3 / 2);  
Magic Number,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,FunctionDataBuilder,The following statement contains a magic number: _functionDataByName = new Hashtable (sizeEstimate * 3 / 2);  
Magic Number,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,FunctionDataBuilder,The following statement contains a magic number: _functionDataByIndex = new Hashtable (sizeEstimate * 3 / 2);  
Magic Number,NPOI.SS.Formula.Function,FunctionDataBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionDataBuilder.cs,FunctionDataBuilder,The following statement contains a magic number: _functionDataByIndex = new Hashtable (sizeEstimate * 3 / 2);  
Magic Number,NPOI.SS.Formula.Function,FunctionMetadataReader,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadataReader.cs,CreateRegistry,The following statement contains a magic number: using (StringReader br = new StringReader (Resource1.functionMetadata)) {  	FunctionDataBuilder fdb = new FunctionDataBuilder (400);  	try {  		while (true) {  			String line = br.ReadLine ();  			if (line == null) {  				break;  			}  			if (line.Length < 1 || line [0] == '#') {  				continue;  			}  			String TrimLine = line.Trim ();  			if (TrimLine.Length < 1) {  				continue;  			}  			ProcessLine (fdb' line);  		}  	}  	catch (IOException) {  		throw;  	}  	return fdb.Build ();  }  
Magic Number,NPOI.SS.Formula.Function,FunctionMetadataReader,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadataReader.cs,ProcessLine,The following statement contains a magic number: if (parts.Length != 8) {  	throw new Exception ("Bad line format '" + line + "' - expected 8 data fields");  }  
Magic Number,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,AreaReference,The following statement contains a magic number: if (parts.Length != 2) {  	throw new ArgumentException ("Bad area ref '" + reference + "'");  }  
Magic Number,NPOI.SS.Util,AreaReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\AreaReference.cs,IsWholeColumnReference,The following statement contains a magic number: if (topLeft.Row == 0 && topLeft.IsRowAbsolute && (botRight.Row == -1 || botRight.Row == 65535) && botRight.IsRowAbsolute) {  	return true;  }  
Magic Number,NPOI.SS.Util,CellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress.cs,Serialize,The following statement contains a magic number: LittleEndian.PutUShort (data' offset + 2' LastRow);  
Magic Number,NPOI.SS.Util,CellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress.cs,Serialize,The following statement contains a magic number: LittleEndian.PutUShort (data' offset + 4' FirstColumn);  
Magic Number,NPOI.SS.Util,CellRangeAddress,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress.cs,Serialize,The following statement contains a magic number: LittleEndian.PutUShort (data' offset + 6' LastColumn);  
Magic Number,NPOI.SS.Util,CellRangeAddress8Bit,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress8Bit.cs,Serialize,The following statement contains a magic number: LittleEndian.PutUShort (data' offset + 2' LastRow);  
Magic Number,NPOI.SS.Util,CellRangeAddress8Bit,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress8Bit.cs,Serialize,The following statement contains a magic number: LittleEndian.PutByte (data' offset + 4' FirstColumn);  
Magic Number,NPOI.SS.Util,CellRangeAddress8Bit,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddress8Bit.cs,Serialize,The following statement contains a magic number: LittleEndian.PutByte (data' offset + 5' LastColumn);  
Magic Number,NPOI.SS.Util,CellRangeAddressList,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellRangeAddressList.cs,GetEncodedSize,The following statement contains a magic number: return 2 + CellRangeAddress.GetEncodedSize (numberOfRanges);  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertColStringToIndex,The following statement contains a magic number: for (int k = ref1.Length - 1; k >= 0; k--) {  	char thechar = ref1 [k];  	if (thechar == ABSOLUTE_REFERENCE_MARKER) {  		if (k != 0) {  			throw new ArgumentException ("Bad col ref format '" + ref1 + "'");  		}  		break;  	}  	// Character.getNumericValue() returns the values  	//  10-35 for the letter A-Z  	int shift = (int)Math.Pow (26' pos);  	retval += (NPOI.Util.Character.GetNumericValue (thechar) - 9) * shift;  	pos++;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertColStringToIndex,The following statement contains a magic number: for (int k = ref1.Length - 1; k >= 0; k--) {  	char thechar = ref1 [k];  	if (thechar == ABSOLUTE_REFERENCE_MARKER) {  		if (k != 0) {  			throw new ArgumentException ("Bad col ref format '" + ref1 + "'");  		}  		break;  	}  	// Character.getNumericValue() returns the values  	//  10-35 for the letter A-Z  	int shift = (int)Math.Pow (26' pos);  	retval += (NPOI.Util.Character.GetNumericValue (thechar) - 9) * shift;  	pos++;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertColStringToIndex,The following statement contains a magic number: retval += (NPOI.Util.Character.GetNumericValue (thechar) - 9) * shift;  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: while (colRemain > 0) {  	int thisPart = colRemain % 26;  	if (thisPart == 0) {  		thisPart = 26;  	}  	colRemain = (colRemain - thisPart) / 26;  	// The letter A is at 65  	char colChar = (char)(thisPart + 64);  	colRef = colChar + colRef;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: while (colRemain > 0) {  	int thisPart = colRemain % 26;  	if (thisPart == 0) {  		thisPart = 26;  	}  	colRemain = (colRemain - thisPart) / 26;  	// The letter A is at 65  	char colChar = (char)(thisPart + 64);  	colRef = colChar + colRef;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: while (colRemain > 0) {  	int thisPart = colRemain % 26;  	if (thisPart == 0) {  		thisPart = 26;  	}  	colRemain = (colRemain - thisPart) / 26;  	// The letter A is at 65  	char colChar = (char)(thisPart + 64);  	colRef = colChar + colRef;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: while (colRemain > 0) {  	int thisPart = colRemain % 26;  	if (thisPart == 0) {  		thisPart = 26;  	}  	colRemain = (colRemain - thisPart) / 26;  	// The letter A is at 65  	char colChar = (char)(thisPart + 64);  	colRef = colChar + colRef;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: if (thisPart == 0) {  	thisPart = 26;  }  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: thisPart = 26;  
Magic Number,NPOI.SS.Util,CellReference,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\CellReference.cs,ConvertNumToColString,The following statement contains a magic number: colRemain = (colRemain - thisPart) / 26;  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,GetFrac,The following statement contains a magic number: return (new BigInteger (rawBits) & BI_FRAC_MASK | BI_IMPLIED_FRAC_MSB) << 11;  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: if (biasedExp == 0) {  	// sub-normal numbers  	BigInteger frac = new BigInteger (rawBits) & BI_FRAC_MASK;  	int expAdj = 64 - frac.BitLength ();  	_significand = frac << expAdj;  	_binaryExponent = (biasedExp & 0x07FF) - 1023 - expAdj;  }  else {  	BigInteger frac = GetFrac (rawBits);  	_significand = frac;  	_binaryExponent = (biasedExp & 0x07FF) - 1023;  }  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: if (biasedExp == 0) {  	// sub-normal numbers  	BigInteger frac = new BigInteger (rawBits) & BI_FRAC_MASK;  	int expAdj = 64 - frac.BitLength ();  	_significand = frac << expAdj;  	_binaryExponent = (biasedExp & 0x07FF) - 1023 - expAdj;  }  else {  	BigInteger frac = GetFrac (rawBits);  	_significand = frac;  	_binaryExponent = (biasedExp & 0x07FF) - 1023;  }  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: if (biasedExp == 0) {  	// sub-normal numbers  	BigInteger frac = new BigInteger (rawBits) & BI_FRAC_MASK;  	int expAdj = 64 - frac.BitLength ();  	_significand = frac << expAdj;  	_binaryExponent = (biasedExp & 0x07FF) - 1023 - expAdj;  }  else {  	BigInteger frac = GetFrac (rawBits);  	_significand = frac;  	_binaryExponent = (biasedExp & 0x07FF) - 1023;  }  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: _binaryExponent = (biasedExp & 0x07FF) - 1023 - expAdj;  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: _binaryExponent = (biasedExp & 0x07FF) - 1023;  
Magic Number,NPOI.SS.Util,ExpandedDouble,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\ExpandedDouble.cs,ExpandedDouble,The following statement contains a magic number: if (frac.BitLength () != 64) {  	throw new ArgumentException ("bad bit length");  }  
Magic Number,NPOI.SS.Util,SSNFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (0' 3)).Append ('-');  
Magic Number,NPOI.SS.Util,SSNFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (3' 2)).Append ('-');  
Magic Number,NPOI.SS.Util,SSNFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (3' 2)).Append ('-');  
Magic Number,NPOI.SS.Util,SSNFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (5' 4));  
Magic Number,NPOI.SS.Util,SSNFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (5' 4));  
Magic Number,NPOI.SS.Util,ZipPlusFourFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (0' 5)).Append ('-');  
Magic Number,NPOI.SS.Util,ZipPlusFourFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (5' 4));  
Magic Number,NPOI.SS.Util,ZipPlusFourFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: sb.Append (result.Substring (5' 4));  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: if (len <= 4) {  	return result;  }  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: seg3 = result.Substring (len - 4);  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: seg2 = result.Substring (Math.Max (0' len - 7)' len - 4 - beginpos);  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: seg2 = result.Substring (Math.Max (0' len - 7)' len - 4 - beginpos);  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: beginpos = Math.Max (0' len - 10);  
Magic Number,NPOI.SS.Util,PhoneFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\Format.cs,Format,The following statement contains a magic number: seg1 = result.Substring (beginpos' Math.Max (0' len - 7) - beginpos);  
Magic Number,NPOI.SS.Util,MutableFPNumber,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\MutableFPNumber.cs,Normalise64bit,The following statement contains a magic number: if (sc > 32) {  	int highShift = (sc - 1) & 0xFFFFE0;  	_significand = _significand >> (highShift);  	sc -= highShift;  	oldBitLen -= highShift;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: if (binaryExponent > 49 || binaryExponent < 46) {  	// working with ints (left Shifted 20) instead of doubles  	// x = 14.5 - binaryExponent * log10(2);  	int x = (29 << 19) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20;  	x += C_2_POW_19;  	// round  	pow10 = -(x >> 20);  }  else {  	pow10 = 0;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: if (binaryExponent > 49 || binaryExponent < 46) {  	// working with ints (left Shifted 20) instead of doubles  	// x = 14.5 - binaryExponent * log10(2);  	int x = (29 << 19) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20;  	x += C_2_POW_19;  	// round  	pow10 = -(x >> 20);  }  else {  	pow10 = 0;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: if (binaryExponent > 49 || binaryExponent < 46) {  	// working with ints (left Shifted 20) instead of doubles  	// x = 14.5 - binaryExponent * log10(2);  	int x = (29 << 19) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20;  	x += C_2_POW_19;  	// round  	pow10 = -(x >> 20);  }  else {  	pow10 = 0;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: if (binaryExponent > 49 || binaryExponent < 46) {  	// working with ints (left Shifted 20) instead of doubles  	// x = 14.5 - binaryExponent * log10(2);  	int x = (29 << 19) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20;  	x += C_2_POW_19;  	// round  	pow10 = -(x >> 20);  }  else {  	pow10 = 0;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: if (binaryExponent > 49 || binaryExponent < 46) {  	// working with ints (left Shifted 20) instead of doubles  	// x = 14.5 - binaryExponent * log10(2);  	int x = (29 << 19) - binaryExponent * LOG_BASE_10_OF_2_TIMES_2_POW_20;  	x += C_2_POW_19;  	// round  	pow10 = -(x >> 20);  }  else {  	pow10 = 0;  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: pow10 = -(x >> 20);  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: switch (cc.Get64BitNormalisedExponent ()) {  case 46:  	if (cc.IsAboveMinRep ()) {  		break;  	}  	goto case 44;  case 44:  case 45:  	cc.multiplyByPowerOfTen (1);  	pow10--;  	break;  case 47:  case 48:  	break;  case 49:  	if (cc.IsBelowMaxRep ()) {  		break;  	}  	goto case 50;  case 50:  	cc.multiplyByPowerOfTen (-1);  	pow10++;  	break;  default:  	throw new InvalidOperationException ("Bad binary exp " + cc.Get64BitNormalisedExponent () + ".");  }  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: goto case 44;  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,Create,The following statement contains a magic number: goto case 50;  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,RoundUnits,The following statement contains a magic number: return new NormalisedDecimal (wholePart / 10' 0' de + 1);  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,ComposeFrac,The following statement contains a magic number: return new BigInteger (new byte[] {  	(byte)(wp >> 56)'  	// N.B. assuming sign bit is zero  	(byte)(wp >> 48)'  	(byte)(wp >> 40)'  	(byte)(wp >> 32)'  	(byte)(wp >> 24)'  	(byte)(wp >> 16)'  	(byte)(wp >> 8)'  	(byte)(wp >> 0)'  	(byte)(fp >> 16)'  	(byte)(fp >> 8)'  	(byte)(fp >> 0)'  });  
Magic Number,NPOI.SS.Util,NormalisedDecimal,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NormalisedDecimal.cs,GetFractionalDigits,The following statement contains a magic number: return GetFractionalPart ().ToString (CultureInfo.InvariantCulture).Substring (2);  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,RawDoubleBitsToText,The following statement contains a magic number: if (ed.GetBinaryExponent () < -1022) {  	// value is 'denormalised' which means it is less than 2^-1022  	// excel displays all these numbers as zero' even though calculations work OK  	return isNegative ? "-0" : "0";  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,RawDoubleBitsToText,The following statement contains a magic number: if (ed.GetBinaryExponent () == 1024) {  	// Special number NaN /InfInity  	// Normally one would not create HybridDecimal objects from these values  	// except in these cases Excel really tries to render them as if they were normal numbers  	if (rawBits == EXCEL_NAN_BITS) {  		return "3.484840871308E+308";  	}  	// This is where excel really Gets it wrong  	// Special numbers like InfInity and NaN are interpreted according to  	// the standard rules below.  	isNegative = false;  	// except that the sign bit is ignored  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,ConvertToText,The following statement contains a magic number: if (Math.Abs (decExponent) > 98) {  	decimalDigits = rnd.GetSignificantDecimalDigitsLastDigitRounded ();  	if (decimalDigits.Length == 16) {  		// rounding caused carry  		decExponent++;  	}  }  else {  	decimalDigits = rnd.GetSignificantDecimalDigits ();  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,ConvertToText,The following statement contains a magic number: if (Math.Abs (decExponent) > 98) {  	decimalDigits = rnd.GetSignificantDecimalDigitsLastDigitRounded ();  	if (decimalDigits.Length == 16) {  		// rounding caused carry  		decExponent++;  	}  }  else {  	decimalDigits = rnd.GetSignificantDecimalDigits ();  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,ConvertToText,The following statement contains a magic number: if (decimalDigits.Length == 16) {  	// rounding caused carry  	decExponent++;  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,FormatGreaterThanOne,The following statement contains a magic number: if (decExponent > 19) {  	// scientific notation  	sb.Append (decimalDigits [0]);  	if (countSigDigits > 1) {  		sb.Append ('.');  		sb.Append (decimalDigits.Substring (1' countSigDigits - 1));  	}  	sb.Append ("E+");  	AppendExp (sb' decExponent);  	return;  }  
Magic Number,NPOI.SS.Util,NumberToTextConverter,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\NumberToTextConverter.cs,AppendExp,The following statement contains a magic number: if (val < 10) {  	sb.Append ('0');  	sb.Append ((char)('0' + val));  	return;  }  
Magic Number,NPOI.SS.Util,SheetBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetBuilder.cs,IsFormulaDefinition,The following statement contains a magic number: if (obj is String) {  	String str = (String)obj;  	if (str.Length < 2) {  		return false;  	}  	else {  		return ((String)obj) [0] == '=';  	}  }  else {  	return false;  }  
Magic Number,NPOI.SS.Util,SheetBuilder,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetBuilder.cs,IsFormulaDefinition,The following statement contains a magic number: if (str.Length < 2) {  	return false;  }  else {  	return ((String)obj) [0] == '=';  }  
Magic Number,NPOI.SS.Util,SheetReferences,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetReferences.cs,SheetReferences,The following statement contains a magic number: map = new Hashtable (5);  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: using (Bitmap bmp = new Bitmap (2048' 100)) {  	Graphics g = Graphics.FromImage (bmp);  	//rows:  	bool skipthisrow = false;  	for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  		IRow row = (IRow)it.Current;  		ICell cell = row.GetCell (column);  		if (cell == null) {  			continue;  		}  		int colspan = 1;  		for (int i = 0; i < sheet.NumMergedRegions; i++) {  			CellRangeAddress region = sheet.GetMergedRegion (i);  			if (ContainsCell (region' row.RowNum' column)) {  				if (!useMergedCells) {  					// If we're not using merged cells' skip this one and Move on to the next.  					//continue rows;  					skipthisrow = true;  				}  				cell = row.GetCell (region.FirstColumn);  				colspan = 1 + region.LastColumn - region.FirstColumn;  			}  		}  		if (skipthisrow) {  			continue;  		}  		ICellStyle style = cell.CellStyle;  		NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  		CellType cellType = cell.CellType;  		// for formula cells we compute the cell width for the cached formula result  		if (cellType == CellType.FORMULA)  			cellType = cell.CachedFormulaResultType;  		if (cellType == CellType.STRING) {  			IRichTextString rt = cell.RichStringCellValue;  			String[] lines = rt.String.Split ("\n".ToCharArray ());  			for (int i = 0; i < lines.Length; i++) {  				String txt = lines [i] + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				font = IFont2Font (font1);  				if (rt.NumFormattingRuns > 0) {  					// TODO: support rich text fragments  				}  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = Math.Abs (sf.Height * Math.Sin (angle));  					double x2 = Math.Abs (sf.Width * Math.Cos (angle));  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  		else {  			String sval = null;  			if (cellType == CellType.NUMERIC) {  				// Try to Get it formatted to look the same as excel  				try {  					sval = formatter.FormatCellValue (cell' dummyEvaluator);  				}  				catch (Exception) {  					sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  				}  			}  			else if (cellType == CellType.BOOLEAN) {  				sval = cell.BooleanCellValue.ToString ().ToUpper ();  			}  			if (sval != null) {  				String txt = sval + defaultChar;  				//str = new AttributedString(txt);  				//copyAttributes(font' str' 0' txt.Length);  				//layout = new TextLayout(str.Iterator' fontRenderContext);  				if (style.Rotation != 0) {  					/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  					//AffineTransform trans = new AffineTransform();  					//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  					//trans.Concatenate(  					//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  					//);  					//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					SizeF sf = g.MeasureString (txt' font);  					double x1 = sf.Height * Math.Sin (angle);  					double x2 = sf.Width * Math.Cos (angle);  					double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  				else {  					//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  					double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  					width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				}  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (IEnumerator it = sheet.GetRowEnumerator (); it.MoveNext ();) {  	IRow row = (IRow)it.Current;  	ICell cell = row.GetCell (column);  	if (cell == null) {  		continue;  	}  	int colspan = 1;  	for (int i = 0; i < sheet.NumMergedRegions; i++) {  		CellRangeAddress region = sheet.GetMergedRegion (i);  		if (ContainsCell (region' row.RowNum' column)) {  			if (!useMergedCells) {  				// If we're not using merged cells' skip this one and Move on to the next.  				//continue rows;  				skipthisrow = true;  			}  			cell = row.GetCell (region.FirstColumn);  			colspan = 1 + region.LastColumn - region.FirstColumn;  		}  	}  	if (skipthisrow) {  		continue;  	}  	ICellStyle style = cell.CellStyle;  	NPOI.SS.UserModel.IFont font1 = wb.GetFontAt (style.FontIndex);  	CellType cellType = cell.CellType;  	// for formula cells we compute the cell width for the cached formula result  	if (cellType == CellType.FORMULA)  		cellType = cell.CachedFormulaResultType;  	if (cellType == CellType.STRING) {  		IRichTextString rt = cell.RichStringCellValue;  		String[] lines = rt.String.Split ("\n".ToCharArray ());  		for (int i = 0; i < lines.Length; i++) {  			String txt = lines [i] + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			font = IFont2Font (font1);  			if (rt.NumFormattingRuns > 0) {  				// TODO: support rich text fragments  			}  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = Math.Abs (sf.Height * Math.Sin (angle));  				double x2 = Math.Abs (sf.Width * Math.Cos (angle));  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  	else {  		String sval = null;  		if (cellType == CellType.NUMERIC) {  			// Try to Get it formatted to look the same as excel  			try {  				sval = formatter.FormatCellValue (cell' dummyEvaluator);  			}  			catch (Exception) {  				sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  			}  		}  		else if (cellType == CellType.BOOLEAN) {  			sval = cell.BooleanCellValue.ToString ().ToUpper ();  		}  		if (sval != null) {  			String txt = sval + defaultChar;  			//str = new AttributedString(txt);  			//copyAttributes(font' str' 0' txt.Length);  			//layout = new TextLayout(str.Iterator' fontRenderContext);  			if (style.Rotation != 0) {  				/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  				//AffineTransform trans = new AffineTransform();  				//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  				//trans.Concatenate(  				//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  				//);  				//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				SizeF sf = g.MeasureString (txt' font);  				double x1 = sf.Height * Math.Sin (angle);  				double x2 = sf.Width * Math.Cos (angle);  				double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  			else {  				//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  				double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  				width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			}  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (cellType == CellType.STRING) {  	IRichTextString rt = cell.RichStringCellValue;  	String[] lines = rt.String.Split ("\n".ToCharArray ());  	for (int i = 0; i < lines.Length; i++) {  		String txt = lines [i] + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		font = IFont2Font (font1);  		if (rt.NumFormattingRuns > 0) {  			// TODO: support rich text fragments  		}  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = Math.Abs (sf.Height * Math.Sin (angle));  			double x2 = Math.Abs (sf.Width * Math.Cos (angle));  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  else {  	String sval = null;  	if (cellType == CellType.NUMERIC) {  		// Try to Get it formatted to look the same as excel  		try {  			sval = formatter.FormatCellValue (cell' dummyEvaluator);  		}  		catch (Exception) {  			sval = cell.NumericCellValue.ToString ("F"' CultureInfo.InvariantCulture);  		}  	}  	else if (cellType == CellType.BOOLEAN) {  		sval = cell.BooleanCellValue.ToString ().ToUpper ();  	}  	if (sval != null) {  		String txt = sval + defaultChar;  		//str = new AttributedString(txt);  		//copyAttributes(font' str' 0' txt.Length);  		//layout = new TextLayout(str.Iterator' fontRenderContext);  		if (style.Rotation != 0) {  			/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  			//AffineTransform trans = new AffineTransform();  			//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  			//trans.Concatenate(  			//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  			//);  			//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			SizeF sf = g.MeasureString (txt' font);  			double x1 = sf.Height * Math.Sin (angle);  			double x2 = sf.Width * Math.Cos (angle);  			double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  		else {  			//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  			double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  			width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		}  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {  	String txt = lines [i] + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	font = IFont2Font (font1);  	if (rt.NumFormattingRuns > 0) {  		// TODO: support rich text fragments  	}  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = Math.Abs (sf.Height * Math.Sin (angle));  		double x2 = Math.Abs (sf.Width * Math.Cos (angle));  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {  	String txt = lines [i] + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	font = IFont2Font (font1);  	if (rt.NumFormattingRuns > 0) {  		// TODO: support rich text fragments  	}  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = Math.Abs (sf.Height * Math.Sin (angle));  		double x2 = Math.Abs (sf.Width * Math.Cos (angle));  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {  	String txt = lines [i] + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	font = IFont2Font (font1);  	if (rt.NumFormattingRuns > 0) {  		// TODO: support rich text fragments  	}  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = Math.Abs (sf.Height * Math.Sin (angle));  		double x2 = Math.Abs (sf.Width * Math.Cos (angle));  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: for (int i = 0; i < lines.Length; i++) {  	String txt = lines [i] + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	font = IFont2Font (font1);  	if (rt.NumFormattingRuns > 0) {  		// TODO: support rich text fragments  	}  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = Math.Abs (sf.Height * Math.Sin (angle));  		double x2 = Math.Abs (sf.Width * Math.Cos (angle));  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = Math.Abs (sf.Height * Math.Sin (angle));  	double x2 = Math.Abs (sf.Width * Math.Cos (angle));  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = Math.Abs (sf.Height * Math.Sin (angle));  	double x2 = Math.Abs (sf.Width * Math.Cos (angle));  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = Math.Abs (sf.Height * Math.Sin (angle));  	double x2 = Math.Abs (sf.Width * Math.Cos (angle));  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = Math.Abs (sf.Height * Math.Sin (angle));  	double x2 = Math.Abs (sf.Width * Math.Cos (angle));  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (sval != null) {  	String txt = sval + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = sf.Height * Math.Sin (angle);  		double x2 = sf.Width * Math.Cos (angle);  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (sval != null) {  	String txt = sval + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = sf.Height * Math.Sin (angle);  		double x2 = sf.Width * Math.Cos (angle);  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (sval != null) {  	String txt = sval + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = sf.Height * Math.Sin (angle);  		double x2 = sf.Width * Math.Cos (angle);  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (sval != null) {  	String txt = sval + defaultChar;  	//str = new AttributedString(txt);  	//copyAttributes(font' str' 0' txt.Length);  	//layout = new TextLayout(str.Iterator' fontRenderContext);  	if (style.Rotation != 0) {  		/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  		//AffineTransform trans = new AffineTransform();  		//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  		//trans.Concatenate(  		//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  		//);  		//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		SizeF sf = g.MeasureString (txt' font);  		double x1 = sf.Height * Math.Sin (angle);  		double x2 = sf.Width * Math.Cos (angle);  		double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  	else {  		//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  		double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  		width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  	}  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = sf.Height * Math.Sin (angle);  	double x2 = sf.Width * Math.Cos (angle);  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = sf.Height * Math.Sin (angle);  	double x2 = sf.Width * Math.Cos (angle);  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = sf.Height * Math.Sin (angle);  	double x2 = sf.Width * Math.Cos (angle);  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: if (style.Rotation != 0) {  	/*                                  * Transform the text using a scale so that it's height is increased by a multiple of the leading'                                  * and then rotate the text before computing the bounds. The scale results in some whitespace around                                  * the unrotated top and bottom of the text that normally wouldn't be present if unscaled' but                                  * is Added by the standard Excel autosize.                                  */double angle = style.Rotation * 2.0 * Math.PI / 360.0;  	//AffineTransform trans = new AffineTransform();  	//trans.Concatenate(AffineTransform.GetRotateInstance(style.Rotation*2.0*Math.PI/360.0));  	//trans.Concatenate(  	//AffineTransform.GetScaleInstance(1' fontHeightMultiple)  	//);  	//width = Math.Max(width' ((layout.GetOutline(trans).Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	SizeF sf = g.MeasureString (txt' font);  	double x1 = sf.Height * Math.Sin (angle);  	double x2 = sf.Width * Math.Cos (angle);  	double w = Math.Round (x1 + x2' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  else {  	//width = Math.Max(width' ((layout.Bounds.Width / colspan) / defaultCharWidth) + cell.CellStyle.Indention);  	double w = Math.Round (g.MeasureString (txt' font).Width' 0' MidpointRounding.ToEven);  	width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  }  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: width = Math.Max (width' (w / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  
Magic Number,NPOI.SS.Util,SheetUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\SheetUtil.cs,GetColumnWidth,The following statement contains a magic number: width = Math.Max (width' (w * 1.0 / colspan / defaultCharWidth) * 2 + cell.CellStyle.Indention);  
Magic Number,NPOI.SS.Util,WorkbookUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\Util\WorkbookUtil.cs,ValidateSheetName,The following statement contains a magic number: if (len < 1 || len > 31) {  	throw new ArgumentException ("sheetName '" + sheetName + "' is invalid - character count MUST be greater than or equal to 1 and less than or equal to 31");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int x = 0; x < len;) {  	aChar = theString [x++];  	if (aChar == '\\') {  		aChar = theString [x++];  		if (aChar == 'u') {  			// Read the xxxx  			int value = 0;  			for (int i = 0; i < 4; i++) {  				aChar = theString [x++];  				switch (aChar) {  				case '0':  				case '1':  				case '2':  				case '3':  				case '4':  				case '5':  				case '6':  				case '7':  				case '8':  				case '9':  					value = (value << 4) + aChar - '0';  					break;  				case 'a':  				case 'b':  				case 'c':  				case 'd':  				case 'e':  				case 'f':  					value = (value << 4) + 10 + aChar - 'a';  					break;  				case 'A':  				case 'B':  				case 'C':  				case 'D':  				case 'E':  				case 'F':  					value = (value << 4) + 10 + aChar - 'A';  					break;  				default:  					throw new ArgumentException ("Malformed \\uxxxx encoding.");  				}  			}  			outBuffer.Append ((char)value);  		}  		else {  			if (aChar == 't')  				aChar = '\t';  			else if (aChar == 'r')  				aChar = '\r';  			else if (aChar == 'n')  				aChar = '\n';  			else if (aChar == 'f')  				aChar = '\f';  			outBuffer.Append (aChar);  		}  	}  	else  		outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == '\\') {  	aChar = theString [x++];  	if (aChar == 'u') {  		// Read the xxxx  		int value = 0;  		for (int i = 0; i < 4; i++) {  			aChar = theString [x++];  			switch (aChar) {  			case '0':  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  			case '8':  			case '9':  				value = (value << 4) + aChar - '0';  				break;  			case 'a':  			case 'b':  			case 'c':  			case 'd':  			case 'e':  			case 'f':  				value = (value << 4) + 10 + aChar - 'a';  				break;  			case 'A':  			case 'B':  			case 'C':  			case 'D':  			case 'E':  			case 'F':  				value = (value << 4) + 10 + aChar - 'A';  				break;  			default:  				throw new ArgumentException ("Malformed \\uxxxx encoding.");  			}  		}  		outBuffer.Append ((char)value);  	}  	else {  		if (aChar == 't')  			aChar = '\t';  		else if (aChar == 'r')  			aChar = '\r';  		else if (aChar == 'n')  			aChar = '\n';  		else if (aChar == 'f')  			aChar = '\f';  		outBuffer.Append (aChar);  	}  }  else  	outBuffer.Append (aChar);  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: if (aChar == 'u') {  	// Read the xxxx  	int value = 0;  	for (int i = 0; i < 4; i++) {  		aChar = theString [x++];  		switch (aChar) {  		case '0':  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  		case '8':  		case '9':  			value = (value << 4) + aChar - '0';  			break;  		case 'a':  		case 'b':  		case 'c':  		case 'd':  		case 'e':  		case 'f':  			value = (value << 4) + 10 + aChar - 'a';  			break;  		case 'A':  		case 'B':  		case 'C':  		case 'D':  		case 'E':  		case 'F':  			value = (value << 4) + 10 + aChar - 'A';  			break;  		default:  			throw new ArgumentException ("Malformed \\uxxxx encoding.");  		}  	}  	outBuffer.Append ((char)value);  }  else {  	if (aChar == 't')  		aChar = '\t';  	else if (aChar == 'r')  		aChar = '\r';  	else if (aChar == 'n')  		aChar = '\n';  	else if (aChar == 'f')  		aChar = '\f';  	outBuffer.Append (aChar);  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	aChar = theString [x++];  	switch (aChar) {  	case '0':  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		value = (value << 4) + aChar - '0';  		break;  	case 'a':  	case 'b':  	case 'c':  	case 'd':  	case 'e':  	case 'f':  		value = (value << 4) + 10 + aChar - 'a';  		break;  	case 'A':  	case 'B':  	case 'C':  	case 'D':  	case 'E':  	case 'F':  		value = (value << 4) + 10 + aChar - 'A';  		break;  	default:  		throw new ArgumentException ("Malformed \\uxxxx encoding.");  	}  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: switch (aChar) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	value = (value << 4) + aChar - '0';  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	value = (value << 4) + 10 + aChar - 'a';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	value = (value << 4) + 10 + aChar - 'A';  	break;  default:  	throw new ArgumentException ("Malformed \\uxxxx encoding.");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: switch (aChar) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	value = (value << 4) + aChar - '0';  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	value = (value << 4) + 10 + aChar - 'a';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	value = (value << 4) + 10 + aChar - 'A';  	break;  default:  	throw new ArgumentException ("Malformed \\uxxxx encoding.");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: switch (aChar) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	value = (value << 4) + aChar - '0';  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	value = (value << 4) + 10 + aChar - 'a';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	value = (value << 4) + 10 + aChar - 'A';  	break;  default:  	throw new ArgumentException ("Malformed \\uxxxx encoding.");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: switch (aChar) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	value = (value << 4) + aChar - '0';  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	value = (value << 4) + 10 + aChar - 'a';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	value = (value << 4) + 10 + aChar - 'A';  	break;  default:  	throw new ArgumentException ("Malformed \\uxxxx encoding.");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: switch (aChar) {  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	value = (value << 4) + aChar - '0';  	break;  case 'a':  case 'b':  case 'c':  case 'd':  case 'e':  case 'f':  	value = (value << 4) + 10 + aChar - 'a';  	break;  case 'A':  case 'B':  case 'C':  case 'D':  case 'E':  case 'F':  	value = (value << 4) + 10 + aChar - 'A';  	break;  default:  	throw new ArgumentException ("Malformed \\uxxxx encoding.");  }  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: value = (value << 4) + aChar - '0';  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: value = (value << 4) + 10 + aChar - 'a';  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: value = (value << 4) + 10 + aChar - 'a';  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: value = (value << 4) + 10 + aChar - 'A';  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,LoadConvert,The following statement contains a magic number: value = (value << 4) + 10 + aChar - 'A';  
Magic Number,NPOI.Util.Collections,Properties,C:\repos\xoposhiy_npoi\trunk\main\Util\Collections\Properties.cs,ContinueLine,The following statement contains a magic number: return (slashCount % 2 == 1);  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,factorFor,The following statement contains a magic number: switch (type) {  case 'h':  	return HOUR__FACTOR;  case 'm':  	return MIN__FACTOR;  case 's':  	return SEC__FACTOR;  case '0':  	return SEC__FACTOR / Math.Pow (10' len);  default:  	throw new ArgumentException ("Uknown elapsed time spec: " + type);  }  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,factorFor,The following statement contains a magic number: return SEC__FACTOR / Math.Pow (10' len);  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: switch (type) {  case 'h':  	return 24;  case 'm':  	return 60;  case 's':  	return 60;  case '0':  	return Math.Pow (10' len);  default:  	throw new ArgumentException ("Uknown elapsed time spec: " + type);  }  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: switch (type) {  case 'h':  	return 24;  case 'm':  	return 60;  case 's':  	return 60;  case '0':  	return Math.Pow (10' len);  default:  	throw new ArgumentException ("Uknown elapsed time spec: " + type);  }  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: switch (type) {  case 'h':  	return 24;  case 'm':  	return 60;  case 's':  	return 60;  case '0':  	return Math.Pow (10' len);  default:  	throw new ArgumentException ("Uknown elapsed time spec: " + type);  }  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: switch (type) {  case 'h':  	return 24;  case 'm':  	return 60;  case 's':  	return 60;  case '0':  	return Math.Pow (10' len);  default:  	throw new ArgumentException ("Uknown elapsed time spec: " + type);  }  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: return 24;  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: return 60;  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: return 60;  
Magic Number,NPOI.SS.Format,CellElapsedFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellElapsedFormatter.cs,modFor,The following statement contains a magic number: return Math.Pow (10' len);  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: switch (parts.Count) {  case 1:  	posNumFmt = zeroNumFmt = negNumFmt = parts [(0)];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 2:  	posNumFmt = zeroNumFmt = parts [0];  	negNumFmt = parts [1];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 3:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = DEFAULT_TEXT_FORMAT;  	break;  case 4:  default:  	posNumFmt = parts [0];  	zeroNumFmt = parts [1];  	negNumFmt = parts [2];  	textFmt = parts [3];  	break;  }  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: negNumFmt = parts [2];  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: negNumFmt = parts [2];  
Magic Number,NPOI.SS.Format,CellFormat,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormat.cs,CellFormat,The following statement contains a magic number: textFmt = parts [3];  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,CellFormatPart,The following statement contains a magic number: foreach (object v in colors.Values) {  	HSSFColor hc = (HSSFColor)v;  	Type type = hc.GetType ();  	String name = type.Name;  	if (name.Equals (name.ToUpper ())) {  		short[] rgb = hc.GetTriplet ();  		Color c = Color.FromArgb (rgb [0]' rgb [1]' rgb [2]);  		if (!NAMED_COLORS.ContainsKey (name)) {  			NAMED_COLORS.Add (name' c);  		}  		if (name.IndexOf ('_') > 0) {  			if (!NAMED_COLORS.ContainsKey (name.Replace ('_'' ' '))) {  				NAMED_COLORS.Add (name.Replace ('_'' ' ')' c);  			}  		}  		if (name.IndexOf ("_PERCENT") > 0) {  			if (!NAMED_COLORS.ContainsKey (name.Replace ("_PERCENT"' "%").Replace ('_'' ' '))) {  				NAMED_COLORS.Add (name.Replace ("_PERCENT"' "%").Replace ('_'' ' ')' c);  			}  		}  	}  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,CellFormatPart,The following statement contains a magic number: if (name.Equals (name.ToUpper ())) {  	short[] rgb = hc.GetTriplet ();  	Color c = Color.FromArgb (rgb [0]' rgb [1]' rgb [2]);  	if (!NAMED_COLORS.ContainsKey (name)) {  		NAMED_COLORS.Add (name' c);  	}  	if (name.IndexOf ('_') > 0) {  		if (!NAMED_COLORS.ContainsKey (name.Replace ('_'' ' '))) {  			NAMED_COLORS.Add (name.Replace ('_'' ' ')' c);  		}  	}  	if (name.IndexOf ("_PERCENT") > 0) {  		if (!NAMED_COLORS.ContainsKey (name.Replace ("_PERCENT"' "%").Replace ('_'' ' '))) {  			NAMED_COLORS.Add (name.Replace ("_PERCENT"' "%").Replace ('_'' ' ')' c);  		}  	}  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: foreach (Match m in mc) {  	String part = Group (m' 0);  	if (part.Length > 0) {  		String repl = partHandler.HandlePart (m' part' type' fmt);  		if (repl == null) {  			switch (part [0]) {  			case '\"':  				repl = QuoteSpecial (part.Substring (1' part.Length - 2)' type);  				break;  			case '\\':  				repl = QuoteSpecial (part.Substring (1)' type);  				break;  			case '_':  				repl = " ";  				break;  			case '*':  				//!! We don't do this for real' we just Put in 3 of them  				repl = ExpandChar (part);  				break;  			default:  				repl = part;  				break;  			}  		}  		//m.AppendReplacement(fmt' Match.QuoteReplacement(repl));  		fmt.Append (part.Replace (m.Captures [0].Value' repl));  		if (m.NextMatch ().Index - (m.Index + part.Length) > 0) {  			fmt.Append (fdesc.Substring (m.Index + part.Length' m.NextMatch ().Index - (m.Index + part.Length)));  		}  		lastMatch = m;  	}  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: if (part.Length > 0) {  	String repl = partHandler.HandlePart (m' part' type' fmt);  	if (repl == null) {  		switch (part [0]) {  		case '\"':  			repl = QuoteSpecial (part.Substring (1' part.Length - 2)' type);  			break;  		case '\\':  			repl = QuoteSpecial (part.Substring (1)' type);  			break;  		case '_':  			repl = " ";  			break;  		case '*':  			//!! We don't do this for real' we just Put in 3 of them  			repl = ExpandChar (part);  			break;  		default:  			repl = part;  			break;  		}  	}  	//m.AppendReplacement(fmt' Match.QuoteReplacement(repl));  	fmt.Append (part.Replace (m.Captures [0].Value' repl));  	if (m.NextMatch ().Index - (m.Index + part.Length) > 0) {  		fmt.Append (fdesc.Substring (m.Index + part.Length' m.NextMatch ().Index - (m.Index + part.Length)));  	}  	lastMatch = m;  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: if (repl == null) {  	switch (part [0]) {  	case '\"':  		repl = QuoteSpecial (part.Substring (1' part.Length - 2)' type);  		break;  	case '\\':  		repl = QuoteSpecial (part.Substring (1)' type);  		break;  	case '_':  		repl = " ";  		break;  	case '*':  		//!! We don't do this for real' we just Put in 3 of them  		repl = ExpandChar (part);  		break;  	default:  		repl = part;  		break;  	}  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: switch (part [0]) {  case '\"':  	repl = QuoteSpecial (part.Substring (1' part.Length - 2)' type);  	break;  case '\\':  	repl = QuoteSpecial (part.Substring (1)' type);  	break;  case '_':  	repl = " ";  	break;  case '*':  	//!! We don't do this for real' we just Put in 3 of them  	repl = ExpandChar (part);  	break;  default:  	repl = part;  	break;  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: repl = QuoteSpecial (part.Substring (1' part.Length - 2)' type);  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: if (type.IsSpecial ('\'')) {  	// Now the next pass for quoted characters: Remove '' chars' making "'a''b'" into "'ab'"  	int pos = 0;  	while ((pos = fmt.ToString ().IndexOf ("''"' pos)) >= 0) {  		//fmt.Delete(pos' pos + 2);  		fmt.Remove (pos' 2);  	}  	// Now the pass for quoted chars: Replace any \u0000 with ''  	pos = 0;  	while ((pos = fmt.ToString ().IndexOf ("\u0000"' pos)) >= 0) {  		//fmt.Replace(pos' pos + 1' "''");  		fmt.Remove (pos' 1);  		fmt.Insert (pos' "''");  	}  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: while ((pos = fmt.ToString ().IndexOf ("''"' pos)) >= 0) {  	//fmt.Delete(pos' pos + 2);  	fmt.Remove (pos' 2);  }  
Magic Number,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,ParseFormat,The following statement contains a magic number: fmt.Remove (pos' 2);  
Magic Number,NPOI.SS.Format,CellGeneralFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellGeneralFormatter.cs,FormatValue,The following statement contains a magic number: if (value.GetType ().IsPrimitive) {  	double val = ((double)value);  	if (val == 0) {  		toAppendTo.Append ('0');  		return;  	}  	String fmt;  	double exp = Math.Log10 (Math.Abs (val));  	bool stripZeros = true;  	if (exp > 10 || exp < -9)  		fmt = "E5";  	else if ((long)val != val)  		fmt = "F9";  	else {  		fmt = "F0";  		stripZeros = false;  	}  	toAppendTo.Append (val.ToString (fmt));  	//Formatter formatter = new Formatter(toAppendTo);  	//formatter.Format(LOCALE' fmt' value);  	if (stripZeros) {  		// strip off trailing zeros  		int RemoveFrom;  		if (fmt.StartsWith ("E"))  			RemoveFrom = toAppendTo.ToString ().LastIndexOf ("E") - 1;  		else  			RemoveFrom = toAppendTo.Length - 1;  		while (toAppendTo [RemoveFrom] == '0') {  			toAppendTo.Remove (RemoveFrom--' 1);  		}  		if (toAppendTo [RemoveFrom] == '.') {  			toAppendTo.Remove (RemoveFrom--' 1);  		}  		// remove zeros after E   by antony.liu  		string text = toAppendTo.ToString ();  		RemoveFrom = toAppendTo.ToString ().LastIndexOf ("E");  		if (RemoveFrom > 0) {  			RemoveFrom++;  			if (text [RemoveFrom] == '+' || text [RemoveFrom] == '-')  				RemoveFrom++;  			int count = 0;  			while (RemoveFrom + count < text.Length) {  				if (text [RemoveFrom + count] == '0')  					count++;  				else  					break;  			}  			toAppendTo.Remove (RemoveFrom' count);  		}  	}  }  else {  	toAppendTo.Append (value.ToString ());  }  
Magic Number,NPOI.SS.Format,CellGeneralFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellGeneralFormatter.cs,FormatValue,The following statement contains a magic number: if (value.GetType ().IsPrimitive) {  	double val = ((double)value);  	if (val == 0) {  		toAppendTo.Append ('0');  		return;  	}  	String fmt;  	double exp = Math.Log10 (Math.Abs (val));  	bool stripZeros = true;  	if (exp > 10 || exp < -9)  		fmt = "E5";  	else if ((long)val != val)  		fmt = "F9";  	else {  		fmt = "F0";  		stripZeros = false;  	}  	toAppendTo.Append (val.ToString (fmt));  	//Formatter formatter = new Formatter(toAppendTo);  	//formatter.Format(LOCALE' fmt' value);  	if (stripZeros) {  		// strip off trailing zeros  		int RemoveFrom;  		if (fmt.StartsWith ("E"))  			RemoveFrom = toAppendTo.ToString ().LastIndexOf ("E") - 1;  		else  			RemoveFrom = toAppendTo.Length - 1;  		while (toAppendTo [RemoveFrom] == '0') {  			toAppendTo.Remove (RemoveFrom--' 1);  		}  		if (toAppendTo [RemoveFrom] == '.') {  			toAppendTo.Remove (RemoveFrom--' 1);  		}  		// remove zeros after E   by antony.liu  		string text = toAppendTo.ToString ();  		RemoveFrom = toAppendTo.ToString ().LastIndexOf ("E");  		if (RemoveFrom > 0) {  			RemoveFrom++;  			if (text [RemoveFrom] == '+' || text [RemoveFrom] == '-')  				RemoveFrom++;  			int count = 0;  			while (RemoveFrom + count < text.Length) {  				if (text [RemoveFrom + count] == '0')  					count++;  				else  					break;  			}  			toAppendTo.Remove (RemoveFrom' count);  		}  	}  }  else {  	toAppendTo.Append (value.ToString ());  }  
Magic Number,NPOI.SS.Format,CellGeneralFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellGeneralFormatter.cs,FormatValue,The following statement contains a magic number: if (exp > 10 || exp < -9)  	fmt = "E5";  else if ((long)val != val)  	fmt = "F9";  else {  	fmt = "F0";  	stripZeros = false;  }  
Magic Number,NPOI.SS.Format,CellGeneralFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellGeneralFormatter.cs,FormatValue,The following statement contains a magic number: if (exp > 10 || exp < -9)  	fmt = "E5";  else if ((long)val != val)  	fmt = "F9";  else {  	fmt = "F0";  	stripZeros = false;  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: if (exponent == null)  	exponentSpecials = EmptySpecialList;  else {  	int exponentPos = specials.IndexOf (exponent);  	exponentSpecials = specialsFor (exponentPos' 2);  	exponentDigitSpecials = specialsFor (exponentPos + 2);  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: if (exponent == null)  	exponentSpecials = EmptySpecialList;  else {  	int exponentPos = specials.IndexOf (exponent);  	exponentSpecials = specialsFor (exponentPos' 2);  	exponentDigitSpecials = specialsFor (exponentPos + 2);  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: exponentSpecials = specialsFor (exponentPos' 2);  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: exponentDigitSpecials = specialsFor (exponentPos + 2);  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: if (exponent == null) {  	StringBuilder fmtBuf = new StringBuilder ();  	int integerPartWidth = calculateintPartWidth ();  	//int totalWidth = integerPartWidth + fractionPartWidth;  	fmtBuf.Append ('0'' integerPartWidth).Append ('.').Append ('0'' precision);  	//fmtBuf.Append("f");  	printfFmt = fmtBuf.ToString ();  	//this number format is legal in C#;  	//printfFmt = fmt;  }  else {  	StringBuilder fmtBuf = new StringBuilder ();  	bool first = true;  	List<Special> specialList = integerSpecials;  	if (integerSpecials.Count == 1) {  		// If we don't do this' we Get ".6e5" instead of "6e4"  		fmtBuf.Append ("0");  		first = false;  	}  	else  		foreach (Special s in specialList) {  			if (IsDigitFmt (s)) {  				fmtBuf.Append (first ? '#' : '0');  				first = false;  			}  		}  	if (fractionalSpecials.Count > 0) {  		fmtBuf.Append ('.');  		foreach (Special s in fractionalSpecials) {  			if (IsDigitFmt (s)) {  				if (!first)  					fmtBuf.Append ('0');  				first = false;  			}  		}  	}  	fmtBuf.Append ('E');  	placeZeros (fmtBuf' exponentSpecials.GetRange (2' exponentSpecials.Count - 2));  	decimalFmt = new DecimalFormat (fmtBuf.ToString ());  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: if (exponent == null) {  	StringBuilder fmtBuf = new StringBuilder ();  	int integerPartWidth = calculateintPartWidth ();  	//int totalWidth = integerPartWidth + fractionPartWidth;  	fmtBuf.Append ('0'' integerPartWidth).Append ('.').Append ('0'' precision);  	//fmtBuf.Append("f");  	printfFmt = fmtBuf.ToString ();  	//this number format is legal in C#;  	//printfFmt = fmt;  }  else {  	StringBuilder fmtBuf = new StringBuilder ();  	bool first = true;  	List<Special> specialList = integerSpecials;  	if (integerSpecials.Count == 1) {  		// If we don't do this' we Get ".6e5" instead of "6e4"  		fmtBuf.Append ("0");  		first = false;  	}  	else  		foreach (Special s in specialList) {  			if (IsDigitFmt (s)) {  				fmtBuf.Append (first ? '#' : '0');  				first = false;  			}  		}  	if (fractionalSpecials.Count > 0) {  		fmtBuf.Append ('.');  		foreach (Special s in fractionalSpecials) {  			if (IsDigitFmt (s)) {  				if (!first)  					fmtBuf.Append ('0');  				first = false;  			}  		}  	}  	fmtBuf.Append ('E');  	placeZeros (fmtBuf' exponentSpecials.GetRange (2' exponentSpecials.Count - 2));  	decimalFmt = new DecimalFormat (fmtBuf.ToString ());  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: placeZeros (fmtBuf' exponentSpecials.GetRange (2' exponentSpecials.Count - 2));  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,CellNumberFormatter,The following statement contains a magic number: placeZeros (fmtBuf' exponentSpecials.GetRange (2' exponentSpecials.Count - 2));  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,maxValue,The following statement contains a magic number: return (int)Math.Round (Math.Pow (10' s.Count) - 1);  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: for (int i = list.Count - 1; i >= 0; i--) {  	Special s = list [i];  	if (s.ch != ''') {  		stillScaling = false;  	}  	else {  		if (stillScaling) {  			scale /= 1000;  		}  		else {  			integerCommas = true;  		}  	}  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: if (s.ch != ''') {  	stillScaling = false;  }  else {  	if (stillScaling) {  		scale /= 1000;  	}  	else {  		integerCommas = true;  	}  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: if (stillScaling) {  	scale /= 1000;  }  else {  	integerCommas = true;  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: scale /= 1000;  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: if (decimalPoint != null) {  	pos = fractionalEnd ();  	list = specials.GetRange (0' pos);  	//.ListIterator(fractionalEnd());  	//while (it.HasPrevious())  	for (int i = list.Count - 1; i >= 0; i--) {  		Special s = list [i];  		if (s.ch != ''') {  			break;  		}  		else {  			scale /= 1000;  		}  	}  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: for (int i = list.Count - 1; i >= 0; i--) {  	Special s = list [i];  	if (s.ch != ''') {  		break;  	}  	else {  		scale /= 1000;  	}  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: if (s.ch != ''') {  	break;  }  else {  	scale /= 1000;  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,interpretCommas,The following statement contains a magic number: scale /= 1000;  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteScientific,The following statement contains a magic number: if (integerNum >= 6 && value > 1) {  	pattern = pattern.Substring (1);  	result.Append (value.ToString (pattern));  }  else {  	result.Append (value.ToString ("E"));  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,WriteScientific,The following statement contains a magic number: if (exponentNum.Length > 2 && exponentNum [0] == '0')  	exponentNum.Remove (0' 1);  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: for (int i = numSpecials.Count - 1; i >= 0; i--) {  	char resultCh;  	if (pos >= 0)  		resultCh = result [pos];  	else {  		// If result is shorter than field' pretend there are leading zeros  		resultCh = '0';  	}  	Special s = numSpecials [i];  	followWithComma = ShowCommas && digit > 0 && digit % 3 == 0;  	bool zeroStrip = false;  	if (resultCh != '0' || s.ch == '0' || s.ch == '?' || pos >= strip) {  		zeroStrip = (s.ch == '?' && pos < strip);  		output [s.pos] = (zeroStrip ? ' ' : resultCh);  		lastOutputintDigit = s;  	}  	if (followWithComma) {  		mods.Add (insertMod (s' zeroStrip ? " " : "'"' StringMod.AFTER)' null);  		followWithComma = false;  	}  	digit++;  	--pos;  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: followWithComma = ShowCommas && digit > 0 && digit % 3 == 0;  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: if (pos >= 0) {  	// We ran out of places to Put digits before we ran out of digits; Put this aside so we can add it later  	++pos;  	// pos was decremented at the end of the loop above when the iterator was at its end  	extraLeadingDigits = new StringBuilder (result.ToString ().Substring (0' pos));  	if (ShowCommas) {  		while (pos > 0) {  			if (digit > 0 && digit % 3 == 0)  				extraLeadingDigits.Insert (pos' ''');  			digit++;  			--pos;  		}  	}  	mods.Add (insertMod (lastOutputintDigit' extraLeadingDigits.ToString ()' StringMod.BEFORE)' null);  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: if (ShowCommas) {  	while (pos > 0) {  		if (digit > 0 && digit % 3 == 0)  			extraLeadingDigits.Insert (pos' ''');  		digit++;  		--pos;  	}  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: while (pos > 0) {  	if (digit > 0 && digit % 3 == 0)  		extraLeadingDigits.Insert (pos' ''');  	digit++;  	--pos;  }  
Magic Number,NPOI.SS.Format,CellNumberFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellNumberFormatter.cs,Writeint,The following statement contains a magic number: if (digit > 0 && digit % 3 == 0)  	extraLeadingDigits.Insert (pos' ''');  
Missing Default,NPOI.HSSF.Record.Aggregates,WorksheetProtectionBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\WorksheetProtectionBlock.cs,IsComponentRecord,The following switch statement is missing a default case: switch (sid) {  case ProtectRecord.sid:  case ObjectProtectRecord.sid:  case ScenarioProtectRecord.sid:  case PasswordRecord.sid:  	return true;  }  
Missing Default,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,IsComponentRecord,The following switch statement is missing a default case: switch (sid) {  case HorizontalPageBreakRecord.sid:  case VerticalPageBreakRecord.sid:  case HeaderRecord.sid:  case FooterRecord.sid:  case HCenterRecord.sid:  case VCenterRecord.sid:  case LeftMarginRecord.sid:  case RightMarginRecord.sid:  case TopMarginRecord.sid:  case BottomMarginRecord.sid:  case UnknownRecord.PLS_004D:  case PrintSetupRecord.sid:  case UnknownRecord.BITMAP_00E9:  case UnknownRecord.PRINTSIZE_0033:  case HeaderFooterRecord.sid:  	// extra header/footer settings supported by Excel 2007  	return true;  }  
Missing Default,NPOI.HSSF.Record.Aggregates,PageSettingsBlock,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\PageSettingsBlock.cs,GetMargin,The following switch statement is missing a default case: switch (margin) {  case MarginType.LeftMargin:  	return .75;  case MarginType.RightMargin:  	return .75;  case MarginType.TopMargin:  	return 1.0;  case MarginType.BottomMargin:  	return 1.0;  }  
Missing Default,NPOI.HSSF.Record.Aggregates,RowRecordsAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Aggregates\RowRecordsAggregate.cs,RowRecordsAggregate,The following switch statement is missing a default case: switch (rec.Sid) {  case RowRecord.sid:  	InsertRow ((RowRecord)rec);  	continue;  case DBCellRecord.sid:  	// end of 'Row Block'.  Should only occur after cell records  	// ignore DBCELL records because POI generates them upon re-serialization  	continue;  }  
Missing Default,NPOI.HSSF.Record,BoolErrRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\BoolErrRecord.cs,SetValue,The following switch statement is missing a default case: switch (value) {  case ErrorConstants.ERROR_NULL:  case ErrorConstants.ERROR_DIV_0:  case ErrorConstants.ERROR_VALUE:  case ErrorConstants.ERROR_REF:  case ErrorConstants.ERROR_NAME:  case ErrorConstants.ERROR_NUM:  case ErrorConstants.ERROR_NA:  	_value = value;  	_isError = true;  	return;  }  
Missing Default,NPOI.HSSF.Record,EscherAggregate,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\EscherAggregate.cs,ConvertRecordsToUserModel,The following switch statement is missing a default case: switch (type) {  case ST_TEXTBOX:  	// TextBox  	HSSFTextbox box = new HSSFTextbox (null' new HSSFClientAnchor ());  	patriarch.Children.Add (box);  	ConvertRecordsToUserModel (shapeContainer' box);  	break;  case ST_PICTUREFRAME:  	// Duplicated from  	// org.apache.poi.hslf.model.Picture.getPictureIndex()  	EscherOptRecord opt = (EscherOptRecord)GetEscherChild (shapeContainer' EscherOptRecord.RECORD_ID);  	EscherSimpleProperty prop = (EscherSimpleProperty)opt.Lookup (EscherProperties.BLIP__BLIPTODISPLAY);  	if (prop != null) {  		int pictureIndex = prop.PropertyValue;  		EscherClientAnchorRecord anchorRecord = (EscherClientAnchorRecord)GetEscherChild (shapeContainer' EscherClientAnchorRecord.RECORD_ID);  		HSSFClientAnchor anchor = new HSSFClientAnchor ();  		anchor.Col1 = anchorRecord.Col1;  		anchor.Col2 = anchorRecord.Col2;  		anchor.Dx1 = anchorRecord.Dx1;  		anchor.Dx2 = anchorRecord.Dx2;  		anchor.Dy1 = anchorRecord.Dy1;  		anchor.Dy2 = anchorRecord.Dy2;  		anchor.Row1 = anchorRecord.Row1;  		anchor.Row2 = anchorRecord.Row2;  		HSSFPicture picture = new HSSFPicture (null' anchor);  		picture.PictureIndex = pictureIndex;  		patriarch.AddShape (picture);  	}  	break;  }  
Missing Default,NPOI.HSSF.Record,SpecialCachedValue,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\FormulaRecord.cs,GetValueType,The following switch statement is missing a default case: switch (typeCode) {  case STRING:  	return NPOI.SS.UserModel.CellType.STRING;  case BOOLEAN:  	return NPOI.SS.UserModel.CellType.BOOLEAN;  case ERROR_CODE:  	return NPOI.SS.UserModel.CellType.ERROR;  case EMPTY:  	return NPOI.SS.UserModel.CellType.STRING;  // is this correct?  }  
Missing Default,NPOI.HSSF.Record,InterfaceEndRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\InterfaceEndRecord.cs,Create,The following switch statement is missing a default case: switch (in1.Remaining) {  case 0:  	return Instance;  case 2:  	return new InterfaceHdrRecord (in1);  }  
Missing Default,NPOI.HSSF.Record,NameRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\NameRecord.cs,TranslateBuiltInName,The following switch statement is missing a default case: switch (name) {  case NameRecord.BUILTIN_AUTO_ACTIVATE:  	return "Auto_Activate";  case NameRecord.BUILTIN_AUTO_CLOSE:  	return "Auto_Close";  case NameRecord.BUILTIN_AUTO_DEACTIVATE:  	return "Auto_Deactivate";  case NameRecord.BUILTIN_AUTO_OPEN:  	return "Auto_Open";  case NameRecord.BUILTIN_CONSOLIDATE_AREA:  	return "Consolidate_Area";  case NameRecord.BUILTIN_CRITERIA:  	return "Criteria";  case NameRecord.BUILTIN_DATABASE:  	return "Database";  case NameRecord.BUILTIN_DATA_FORM:  	return "Data_Form";  case NameRecord.BUILTIN_PRINT_AREA:  	return "Print_Area";  case NameRecord.BUILTIN_PRINT_TITLE:  	return "Print_Titles";  case NameRecord.BUILTIN_RECORDER:  	return "Recorder";  case NameRecord.BUILTIN_SHEET_TITLE:  	return "Sheet_Title";  case NameRecord.BUILTIN_FILTER_DB:  	return "_FilterDatabase";  case NameRecord.BUILTIN_EXTRACT:  	return "Extract";  }  
Missing Default,NPOI.HSSF.Record,EmbeddedObjectRefSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\EmbeddedObjectRefSubRecord.cs,ReadRefPtg,The following switch statement is missing a default case: switch (ptgSid) {  case AreaPtg.sid:  	return new AreaPtg (in1);  case Area3DPtg.sid:  	return new Area3DPtg (in1);  case RefPtg.sid:  	return new RefPtg (in1);  case Ref3DPtg.sid:  	return new Ref3DPtg (in1);  }  
Missing Default,NPOI.HSSF.Record,LbsDataSubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\LbsDataSubRecord.cs,ReadRefPtg,The following switch statement is missing a default case: switch (ptgSid) {  case AreaPtg.sid:  	return new AreaPtg (in1);  case Area3DPtg.sid:  	return new Area3DPtg (in1);  case RefPtg.sid:  	return new RefPtg (in1);  case Ref3DPtg.sid:  	return new Ref3DPtg (in1);  }  
Missing Default,NPOI.HSSF.Record,SubRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\SubRecord\SubRecord.cs,CreateSubRecord,The following switch statement is missing a default case: switch (sid) {  case CommonObjectDataSubRecord.sid:  	return new CommonObjectDataSubRecord (in1' secondUShort);  case EmbeddedObjectRefSubRecord.sid:  	return new EmbeddedObjectRefSubRecord (in1' secondUShort);  case GroupMarkerSubRecord.sid:  	return new GroupMarkerSubRecord (in1' secondUShort);  case EndSubRecord.sid:  	return new EndSubRecord (in1' secondUShort);  case NoteStructureSubRecord.sid:  	return new NoteStructureSubRecord (in1' secondUShort);  case LbsDataSubRecord.sid:  	return new LbsDataSubRecord (in1' secondUShort' (int)cmoOt);  case FtCblsSubRecord.sid:  	return new FtCblsSubRecord (in1' secondUShort);  }  
Missing Default,NPOI.HSSF.Record,UnknownRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnknownRecord.cs,GetBiffName,The following switch statement is missing a default case: switch (sid) {  case PRINTSIZE_0033:  	return "PRINTSIZE";  case PLS_004D:  	return "PLS";  case 0x0050:  	return "DCON";  // Data Consolidation Information  case 0x007F:  	return "IMDATA";  case SHEETPR_0081:  	return "SHEETPR";  case SORT_0090:  	return "SORT";  // Sorting Options  case 0x0094:  	return "LHRECORD";  // .WK? File Conversion Information  case STANDARDWIDTH_0099:  	return "STANDARDWIDTH";  //Standard Column Width  case 0x009D:  	return "AUTOFILTERINFO";  // Drop-Down Arrow Count  case SCL_00A0:  	return "SCL";  // Window Zoom Magnification  case 0x00AE:  	return "SCENMAN";  // Scenario Output Data  case 0x00B2:  	return "SXVI";  // (pivot table) View Item  case 0x00B4:  	return "SXIVD";  // (pivot table) Row/Column Field IDs  case 0x00B5:  	return "SXLI";  // (pivot table) Line Item Array  case 0x00D3:  	return "OBPROJ";  case 0x00DC:  	return "PARAMQRY";  case 0x00DE:  	return "OLESIZE";  case BITMAP_00E9:  	return "BITMAP";  case PHONETICPR_00EF:  	return "PHONETICPR";  case 0x00F1:  	return "SXEX";  // PivotTable View Extended Information  case LABELRANGES_015F:  	return "LABELRANGES";  case 0x01BA:  	return "CODENAME";  case 0x01A9:  	return "USERBVIEW";  case 0x01AD:  	return "QSI";  case 0x01C0:  	return "EXCEL9FILE";  case 0x0802:  	return "QSISXTAG";  // Pivot Table and Query Table Extensions  case 0x0803:  	return "DBQUERYEXT";  case 0x0805:  	return "TXTQUERY";  case 0x0810:  	return "SXVIEWEX9";  // Pivot Table Extensions  case 0x0812:  	return "CONTINUEFRT";  case QUICKTIP_0800:  	return "QUICKTIP";  //case SHEETEXT_0862: return "SHEETEXT";  case 0x0863:  	return "BOOKEXT";  case 0x0864:  	return "SXADDL";  // Pivot Table Additional Info  case SHEETPROTECTION_0867:  	return "SHEETPROTECTION";  //case RANGEPROTECTION_0868: return "RANGEPROTECTION";  case 0x086B:  	return "DATALABEXTCONTENTS";  case 0x086C:  	return "CELLWATCH";  case 0x0874:  	return "DROPDOWNOBJIDS";  case 0x0876:  	return "DCONN";  case 0x087B:  	return "CFEX";  case 0x087C:  	return "XFCRC";  case 0x087D:  	return "XFEXT";  case 0x087F:  	return "CONTINUEFRT12";  case 0x088B:  	return "PLV";  case 0x088C:  	return "COMPAT12";  case 0x088D:  	return "DXF";  case 0x0892:  	return "STYLEEXT";  case 0x0896:  	return "THEME";  case 0x0897:  	return "GUIDTYPELIB";  case 0x089A:  	return "MTRSETTINGS";  case 0x089B:  	return "COMPRESSPICTURES";  case HEADER_FOOTER_089C:  	return "HEADERFOOTER";  case 0x08A1:  	return "SHAPEPROPSSTREAM";  case 0x08A3:  	return "FORCEFULLCALCULATION";  case 0x08A4:  	return "SHAPEPROPSSTREAM";  case 0x08A5:  	return "TEXTPROPSSTREAM";  case 0x08A6:  	return "RICHTEXTSTREAM";  case 0x08C8:  	return "PLV{Mac Excel}";  }  
Missing Default,NPOI.HSSF.Record,UnknownRecord,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\UnknownRecord.cs,IsObservedButUnknown,The following switch statement is missing a default case: switch (sid) {  case 0x0033:  // contains 2 bytes of data: 0x0001 or 0x0003  case 0x0034:  // Seems to be written by MSAccess  // contains text "[Microsoft JET Created Table]0021010"  // appears after last cell value record and before WINDOW2  case 0x01BD:  case 0x01C2:  // Written by Excel 2007  // rawData is multiple of 12 bytes long  // appears after last cell value record and before WINDOW2 or drawing records  case 0x089D:  case 0x089E:  case 0x08A7:  case 0x1001:  case 0x1006:  case 0x1007:  case 0x1009:  case 0x100A:  case 0x100B:  case 0x100C:  case 0x1014:  case 0x1017:  case 0x1018:  case 0x1019:  case 0x101A:  case 0x101B:  case 0x101D:  case 0x101E:  case 0x101F:  case 0x1020:  case 0x1021:  case 0x1022:  case 0x1024:  case 0x1025:  case 0x1026:  case 0x1027:  case 0x1032:  case 0x1033:  case 0x1034:  case 0x1035:  case 0x103A:  case 0x1041:  case 0x1043:  case 0x1044:  case 0x1045:  case 0x1046:  case 0x104A:  case 0x104B:  case 0x104E:  case 0x104F:  case 0x1051:  case 0x105C:  case 0x105D:  case 0x105F:  case 0x1060:  case 0x1062:  case 0x1063:  case 0x1064:  case 0x1065:  case 0x1066:  	return true;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,HSSFCell,The following switch statement is missing a default case: switch (cellType) {  case CellType.STRING:  	stringValue = new HSSFRichTextString (book.Workbook' (LabelSSTRecord)cval);  	break;  case CellType.BLANK:  	break;  case CellType.FORMULA:  	stringValue = new HSSFRichTextString (((FormulaRecordAggregate)cval).StringValue);  	break;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,DetermineType,The following switch statement is missing a default case: switch (sid) {  case NumberRecord.sid:  	return CellType.NUMERIC;  case BlankRecord.sid:  	return CellType.BLANK;  case LabelSSTRecord.sid:  	return CellType.STRING;  case FormulaRecordAggregate.sid:  	return CellType.FORMULA;  case BoolErrRecord.sid:  	BoolErrRecord boolErrRecord = (BoolErrRecord)record;  	return (boolErrRecord.IsBoolean) ? CellType.BOOLEAN : CellType.ERROR;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,SetCellType,The following switch statement is missing a default case: switch (cellType) {  case CellType.FORMULA:  	FormulaRecordAggregate frec = null;  	if (cellType != this.cellType) {  		frec = sheet.Sheet.RowsAggregate.CreateFormula (row' col);  	}  	else {  		frec = (FormulaRecordAggregate)record;  	}  	frec.Column = col;  	if (setValue) {  		frec.FormulaRecord.Value = NumericCellValue;  	}  	frec.XFIndex = styleIndex;  	frec.Row = row;  	record = frec;  	break;  case CellType.NUMERIC:  	NumberRecord nrec = null;  	if (cellType != this.cellType) {  		nrec = new NumberRecord ();  	}  	else {  		nrec = (NumberRecord)record;  	}  	nrec.Column = col;  	if (setValue) {  		nrec.Value = NumericCellValue;  	}  	nrec.XFIndex = styleIndex;  	nrec.Row = row;  	record = nrec;  	break;  case CellType.STRING:  	LabelSSTRecord lrec = null;  	if (cellType != this.cellType) {  		lrec = new LabelSSTRecord ();  	}  	else {  		lrec = (LabelSSTRecord)record;  	}  	lrec.Column = col;  	lrec.Row = row;  	lrec.XFIndex = styleIndex;  	if (setValue) {  		String str = ConvertCellValueToString ();  		int sstIndex = book.Workbook.AddSSTString (new UnicodeString (str));  		lrec.SSTIndex = (sstIndex);  		UnicodeString us = book.Workbook.GetSSTString (sstIndex);  		stringValue = new HSSFRichTextString ();  		stringValue.UnicodeString = us;  	}  	record = lrec;  	break;  case CellType.BLANK:  	BlankRecord brec = null;  	if (cellType != this.cellType) {  		brec = new BlankRecord ();  	}  	else {  		brec = (BlankRecord)record;  	}  	brec.Column = col;  	// During construction the cellStyle may be null for a Blank cell.  	brec.XFIndex = styleIndex;  	brec.Row = row;  	record = brec;  	break;  case CellType.BOOLEAN:  	BoolErrRecord boolRec = null;  	if (cellType != this.cellType) {  		boolRec = new BoolErrRecord ();  	}  	else {  		boolRec = (BoolErrRecord)record;  	}  	boolRec.Column = col;  	if (setValue) {  		boolRec.SetValue (ConvertCellValueToBoolean ());  	}  	boolRec.XFIndex = styleIndex;  	boolRec.Row = row;  	record = boolRec;  	break;  case CellType.ERROR:  	BoolErrRecord errRec = null;  	if (cellType != this.cellType) {  		errRec = new BoolErrRecord ();  	}  	else {  		errRec = (BoolErrRecord)record;  	}  	errRec.Column = col;  	if (setValue) {  		errRec.SetValue ((byte)HSSFErrorConstants.ERROR_VALUE);  	}  	errRec.XFIndex = styleIndex;  	errRec.Row = row;  	record = errRec;  	break;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,ConvertCellValueToString,The following switch statement is missing a default case: switch (fr.CachedResultType) {  case CellType.BOOLEAN:  	return fr.CachedBooleanValue ? "TRUE" : "FALSE";  case CellType.STRING:  	return fra.StringValue;  case CellType.NUMERIC:  	return NumberToTextConverter.ToText (fr.Value);  case CellType.ERROR:  	return HSSFErrorConstants.GetText (fr.CachedErrorValue);  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,GetCellTypeName,The following switch statement is missing a default case: switch (cellTypeCode) {  case CellType.BLANK:  	return "blank";  case CellType.STRING:  	return "text";  case CellType.BOOLEAN:  	return "boolean";  case CellType.ERROR:  	return "error";  case CellType.NUMERIC:  	return "numeric";  case CellType.FORMULA:  	return "formula";  }  
Missing Default,NPOI.HSSF.UserModel,HSSFCell,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFCell.cs,ConvertCellValueToBoolean,The following switch statement is missing a default case: switch (cellType) {  case CellType.BOOLEAN:  	return ((BoolErrRecord)record).BooleanValue;  case CellType.STRING:  	int sstIndex = ((LabelSSTRecord)record).SSTIndex;  	String text = book.Workbook.GetSSTString (sstIndex).String;  	return Convert.ToBoolean (text' CultureInfo.CurrentCulture);  case CellType.NUMERIC:  	return ((NumberRecord)record).Value != 0;  // All other cases Convert to false  // These choices are not well justified.  case CellType.FORMULA:  	// use cached formula result if it's the right type:   	FormulaRecord fr = ((FormulaRecordAggregate)record).FormulaRecord;  	CheckFormulaCachedValueType (CellType.BOOLEAN' fr);  	return fr.CachedBooleanValue;  // Other cases convert to false   // These choices are not well justified.   case CellType.ERROR:  case CellType.BLANK:  	return false;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFFormulaEvaluator,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFFormulaEvaluator.cs,SetCellType,The following switch statement is missing a default case: switch (cellType) {  case CellType.BOOLEAN:  case CellType.ERROR:  case CellType.NUMERIC:  case CellType.STRING:  	cell.SetCellType (cellType);  	return;  case CellType.BLANK:  	// never happens - blanks eventually get translated to zero  	break;  case CellType.FORMULA:  	// this will never happen' we have already evaluated the formula  	break;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFFormulaEvaluator,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFFormulaEvaluator.cs,Evaluate,The following switch statement is missing a default case: switch (cell.CellType) {  case CellType.BOOLEAN:  	return CellValue.ValueOf (cell.BooleanCellValue);  case CellType.ERROR:  	return CellValue.GetError (cell.ErrorCellValue);  case CellType.FORMULA:  	return EvaluateFormulaCellValue (cell);  case CellType.NUMERIC:  	return new CellValue (cell.NumericCellValue);  case CellType.STRING:  	return new CellValue (cell.RichStringCellValue.String);  case CellType.BLANK:  	return null;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFHyperlink,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFHyperlink.cs,HSSFHyperlink,The following switch statement is missing a default case: switch (type) {  case HyperlinkType.URL:  case HyperlinkType.EMAIL:  	record.CreateUrlLink ();  	break;  case HyperlinkType.FILE:  	record.CreateFileLink ();  	break;  case HyperlinkType.DOCUMENT:  	record.CreateDocumentLink ();  	break;  }  
Missing Default,NPOI.HSSF.UserModel,HSSFWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\UserModel\HSSFWorkbook.cs,AddPicture,The following switch statement is missing a default case: switch (format) {  case NPOI.SS.UserModel.PictureType.EMF:  	blipRecord.Options = HSSFPictureData.MSOBI_EMF;  	break;  case NPOI.SS.UserModel.PictureType.WMF:  	blipRecord.Options = HSSFPictureData.MSOBI_WMF;  	break;  case NPOI.SS.UserModel.PictureType.PICT:  	blipRecord.Options = HSSFPictureData.MSOBI_PICT;  	break;  case NPOI.SS.UserModel.PictureType.PNG:  	blipRecord.Options = HSSFPictureData.MSOBI_PNG;  	break;  case NPOI.SS.UserModel.PictureType.JPEG:  	blipRecord.Options = HSSFPictureData.MSOBI_JPEG;  	break;  case NPOI.SS.UserModel.PictureType.DIB:  	blipRecord.Options = HSSFPictureData.MSOBI_DIB;  	break;  }  
Missing Default,NPOI.HSSF.Model,CommentShape,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\CommentShape.cs,AddStandardOptions,The following switch statement is missing a default case: switch (prop.Id) {  case EscherProperties.TEXT__TEXTLEFT:  case EscherProperties.TEXT__TEXTRIGHT:  case EscherProperties.TEXT__TEXTTOP:  case EscherProperties.TEXT__TEXTBOTTOM:  case EscherProperties.GROUPSHAPE__PRINT:  case EscherProperties.FILL__FILLBACKCOLOR:  case EscherProperties.LINESTYLE__COLOR:  	opt.EscherProperties.Remove (prop);  	i--;  	break;  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsProtectionSubsequentRecord,The following switch statement is missing a default case: switch (record.Sid) {  case DefaultColWidthRecord.sid:  case UnknownRecord.SORT_0090:  	return true;  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsPageBreakPriorRecord,The following switch statement is missing a default case: switch (record.Sid) {  case BOFRecord.sid:  case IndexRecord.sid:  // calc settings block  case UncalcedRecord.sid:  case CalcCountRecord.sid:  case CalcModeRecord.sid:  case PrecisionRecord.sid:  case RefModeRecord.sid:  case DeltaRecord.sid:  case IterationRecord.sid:  case DateWindow1904Record.sid:  case SaveRecalcRecord.sid:  // end calc settings  case PrintHeadersRecord.sid:  case PrintGridlinesRecord.sid:  case GridsetRecord.sid:  case DefaultRowHeightRecord.sid:  case UnknownRecord.SHEETPR_0081:  	return true;  // next is the 'Worksheet Protection Block'  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindInsertPosForNewCondFormatTable,The following switch statement is missing a default case: switch (rec.Sid) {  case WindowTwoRecord.sid:  case SCLRecord.sid:  case PaneRecord.sid:  case SelectionRecord.sid:  case UnknownRecord.STANDARDWIDTH_0099:  // MergedCellsTable usually here   case UnknownRecord.LABELRANGES_015F:  case UnknownRecord.PHONETICPR_00EF:  	// ConditionalFormattingTable goes here  	return i + 1;  // HyperlinkTable (not aggregated by POI yet)  // DataValidityTable  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,FindInsertPosForNewMergedRecordTable,The following switch statement is missing a default case: switch (rec.Sid) {  // 'View Settings' (4 records)   case WindowTwoRecord.sid:  case SCLRecord.sid:  case PaneRecord.sid:  case SelectionRecord.sid:  case UnknownRecord.STANDARDWIDTH_0099:  	return i + 1;  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsDVTPriorRecord,The following switch statement is missing a default case: switch (sid) {  case WindowTwoRecord.sid:  case UnknownRecord.SCL_00A0:  case PaneRecord.sid:  case SelectionRecord.sid:  case UnknownRecord.STANDARDWIDTH_0099:  // MergedCellsTable  case UnknownRecord.LABELRANGES_015F:  case UnknownRecord.PHONETICPR_00EF:  // ConditionalFormattingTable  case HyperlinkRecord.sid:  case UnknownRecord.QUICKTIP_0800:  	return true;  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsDVTSubsequentRecord,The following switch statement is missing a default case: switch (sid) {  //case UnknownRecord.SHEETEXT_0862:  case SheetExtRecord.sid:  case UnknownRecord.SHEETPROTECTION_0867:  //case UnknownRecord.RANGEPROTECTION_0868:  case FeatRecord.sid:  case EOFRecord.sid:  	return true;  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsGutsPriorRecord,The following switch statement is missing a default case: switch (record.Sid) {  case BOFRecord.sid:  case IndexRecord.sid:  // calc settings block  case UncalcedRecord.sid:  case CalcCountRecord.sid:  case CalcModeRecord.sid:  case PrecisionRecord.sid:  case RefModeRecord.sid:  case DeltaRecord.sid:  case IterationRecord.sid:  case DateWindow1904Record.sid:  case SaveRecalcRecord.sid:  // end calc settings  case PrintHeadersRecord.sid:  case PrintGridlinesRecord.sid:  case GridsetRecord.sid:  	return true;  // DefaultRowHeightRecord.sid is next  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsEndOfRowBlock,The following switch statement is missing a default case: switch (sid) {  case ViewDefinitionRecord.sid:  // should have been prefixed with DrawingRecord (0x00EC)' but bug 46280 seems to allow this  case DrawingRecord.sid:  case DrawingSelectionRecord.sid:  case ObjRecord.sid:  case TextObjectRecord.sid:  case GutsRecord.sid:  // see Bugzilla 50426  case WindowOneRecord.sid:  // should really be part of workbook stream' but some apps seem to put this before WINDOW2  case WindowTwoRecord.sid:  	return true;  case DVALRecord.sid:  	return true;  case EOFRecord.sid:  	// WINDOW2 should always be present' so shouldn't have got this far  	throw new InvalidOperationException ("Found EOFRecord before WindowTwoRecord was encountered");  }  
Missing Default,NPOI.HSSF.Model,RecordOrderer,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\RecordOrderer.cs,IsRowBlockRecord,The following switch statement is missing a default case: switch (sid) {  case RowRecord.sid:  case BlankRecord.sid:  case BoolErrRecord.sid:  case FormulaRecord.sid:  case LabelRecord.sid:  case LabelSSTRecord.sid:  case NumberRecord.sid:  case RKRecord.sid:  case ArrayRecord.sid:  case SharedFormulaRecord.sid:  case TableRecord.sid:  	return true;  }  
Missing Default,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following switch statement is missing a default case: switch (rec.Sid) {  case BoundSheetRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found boundsheet record at " + k);  	retval.boundsheets.Add ((BoundSheetRecord)rec);  	retval.records.Bspos = k;  	break;  case SSTRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found sst record at " + k);  	retval.sst = (SSTRecord)rec;  	break;  case FontRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found font record at " + k);  	retval.records.Fontpos = k;  	retval.numfonts++;  	break;  case ExtendedFormatRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found XF record at " + k);  	retval.records.Xfpos = k;  	retval.numxfs++;  	break;  case TabIdRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found tabid record at " + k);  	retval.records.Tabpos = k;  	break;  case ProtectRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found protect record at " + k);  	retval.records.Protpos = k;  	break;  case BackupRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found backup record at " + k);  	retval.records.Backuppos = k;  	break;  case ExternSheetRecord.sid:  	throw new Exception ("Extern sheet is part of LinkTable");  case NameRecord.sid:  case SupBookRecord.sid:  	// LinkTable can start with either of these  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found SupBook record at " + k);  	retval.linkTable = new LinkTable (recs' k' retval.records' retval.commentRecords);  	k += retval.linkTable.RecordCount - 1;  	continue;  case FormatRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found format record at " + k);  	retval.formats.Add ((FormatRecord)rec);  	retval.maxformatid = retval.maxformatid >= ((FormatRecord)rec).IndexCode ? retval.maxformatid : ((FormatRecord)rec).IndexCode;  	break;  case DateWindow1904Record.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found datewindow1904 record at " + k);  	retval.uses1904datewindowing = ((DateWindow1904Record)rec).Windowing == 1;  	break;  case PaletteRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found palette record at " + k);  	retval.records.Palettepos = k;  	break;  case WindowOneRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found WindowOneRecord at " + k);  	retval.windowOne = (WindowOneRecord)rec;  	break;  case WriteAccessRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found WriteAccess at " + k);  	retval.writeAccess = (WriteAccessRecord)rec;  	break;  case WriteProtectRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found WriteProtect at " + k);  	retval.writeProtect = (WriteProtectRecord)rec;  	break;  case FileSharingRecord.sid:  	//if (log.Check(POILogger.DEBUG))  	//    log.Log(DEBUG' "found FileSharing at " + k);  	retval.fileShare = (FileSharingRecord)rec;  	break;  case NameCommentRecord.sid:  	NameCommentRecord ncr = (NameCommentRecord)rec;  	retval.commentRecords [ncr.NameText] = ncr;  	break;  }  
Missing Default,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateWorkbook,The following switch statement is missing a default case: switch (rec.Sid) {  case HyperlinkRecord.sid:  	retval.hyperlinks.Add ((HyperlinkRecord)rec);  	break;  }  
Missing Default,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateExtendedFormat,The following switch statement is missing a default case: switch (id) {  case 0:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 1:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 2:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 3:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 4:  	retval.FontIndex = (short)2;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 5:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 6:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 7:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 8:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 9:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 10:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 11:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 12:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 13:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 14:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff400);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // cell records  case 15:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x0;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // style  case 16:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2b;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 17:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x29;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 18:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2c;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 19:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x2a;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 20:  	retval.FontIndex = (short)1;  	retval.FormatIndex = (short)0x9;  	retval.CellOptions = unchecked((short)0xfffffff5);  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = unchecked((short)0xfffff800);  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  // Unused from this point down  case 21:  	retval.FontIndex = (short)5;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x800;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 22:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x0;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 23:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x31;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 24:  	retval.FontIndex = (short)0;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  case 25:  	retval.FontIndex = (short)6;  	retval.FormatIndex = (short)0x8;  	retval.CellOptions = (short)0x1;  	retval.AlignmentOptions = (short)0x20;  	retval.IndentionOptions = (short)0x5c00;  	retval.BorderOptions = (short)0;  	retval.PaletteOptions = (short)0;  	retval.AdtlPaletteOptions = (short)0;  	retval.FillPaletteOptions = (short)0x20c0;  	break;  }  
Missing Default,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateStyle,The following switch statement is missing a default case: switch (id) {  case 0:  	retval.XFIndex = (unchecked((short)0xffff8010));  	retval.SetBuiltinStyle (3);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 1:  	retval.XFIndex = (unchecked((short)0xffff8011));  	retval.SetBuiltinStyle (6);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 2:  	retval.XFIndex = (unchecked((short)0xffff8012));  	retval.SetBuiltinStyle (4);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 3:  	retval.XFIndex = (unchecked((short)0xffff8013));  	retval.SetBuiltinStyle (7);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 4:  	retval.XFIndex = (unchecked((short)0xffff8000));  	retval.SetBuiltinStyle (0);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  case 5:  	retval.XFIndex = (unchecked((short)0xffff8014));  	retval.SetBuiltinStyle (5);  	retval.OutlineStyleLevel = (unchecked((byte)0xffffffff));  	break;  }  
Missing Default,NPOI.HSSF.Model,InternalWorkbook,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Model\InternalWorkbook.cs,CreateFormat,The following switch statement is missing a default case: switch (id) {  case 0:  	return new FormatRecord (5' BuiltinFormats.GetBuiltinFormat (5));  case 1:  	return new FormatRecord (6' BuiltinFormats.GetBuiltinFormat (6));  case 2:  	return new FormatRecord (7' BuiltinFormats.GetBuiltinFormat (7));  case 3:  	return new FormatRecord (8' BuiltinFormats.GetBuiltinFormat (8));  case 4:  	return new FormatRecord (0x2a' BuiltinFormats.GetBuiltinFormat (0x2a));  case 5:  	return new FormatRecord (0x29' BuiltinFormats.GetBuiltinFormat (0x29));  case 6:  	return new FormatRecord (0x2c' BuiltinFormats.GetBuiltinFormat (0x2c));  case 7:  	return new FormatRecord (0x2b' BuiltinFormats.GetBuiltinFormat (0x2b));  }  
Missing Default,NPOI.HSSF.Record.CF,CellRangeUtil,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\CF\CellRangeUtil.cs,MergeRanges,The following switch statement is missing a default case: switch (x) {  case CellRangeUtil.NO_INTERSECTION:  	if (HasExactSharedBorder (range1' range2)) {  		return new CellRangeAddress[] {  			CreateEnclosingCellRange (range1' range2)'  		};  	}  	// else - No intersection and no shared border: do nothing   	return null;  case CellRangeUtil.OVERLAP:  	return ResolveRangeOverlap (range1' range2);  case CellRangeUtil.INSIDE:  	// Remove range2' since it is completely inside of range1  	return new CellRangeAddress[] {  		range1'  	};  case CellRangeUtil.ENCLOSES:  	// range2 encloses range1' so replace it with the enclosing one  	return new CellRangeAddress[] {  		range2'  	};  }  
Missing Default,NPOI.POIFS.Crypt,Decryptor,C:\repos\xoposhiy_npoi\trunk\main\POIFS\Crypt\Decryptor.cs,GetBlockSize,The following switch statement is missing a default case: switch (algorithm) {  case EncryptionHeader.ALGORITHM_AES_128:  	return 16;  case EncryptionHeader.ALGORITHM_AES_192:  	return 24;  case EncryptionHeader.ALGORITHM_AES_256:  	return 32;  }  
Missing Default,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,Calculate,The following switch statement is missing a default case: switch (basis) {  case 0:  	return Basis0 (startDateVal' endDateVal);  case 1:  	return Basis1 (startDateVal' endDateVal);  case 2:  	return Basis2 (startDateVal' endDateVal);  case 3:  	return Basis3 (startDateVal' endDateVal);  case 4:  	return Basis4 (startDateVal' endDateVal);  }  
Missing Default,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,GetLastDayOfMonth,The following switch statement is missing a default case: switch (date.month) {  case 1:  case 3:  case 5:  case 7:  case 8:  case 10:  case 12:  	return LONG_MONTH_LEN;  case 4:  case 6:  case 9:  case 11:  	return SHORT_MONTH_LEN;  }  
Missing Default,NPOI.SS.Formula.Atp,YearFracCalculator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Atp\YearFracCalculator.cs,ShouldCountFeb29,The following switch statement is missing a default case: switch (start.month) {  case SimpleDate.JANUARY:  case SimpleDate.FEBRUARY:  	return true;  }  
Missing Default,NPOI.SS.UserModel,CellValue,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\CellValue.cs,FormatAsString,The following switch statement is missing a default case: switch (_cellType) {  case CellType.NUMERIC:  	return _numberValue.ToString (CultureInfo.InvariantCulture);  case CellType.STRING:  	return '"' + _textValue + '"';  case CellType.BOOLEAN:  	return _boolValue ? "TRUE" : "FALSE";  case CellType.ERROR:  	return ErrorEval.GetText (_errorCode);  }  
Missing Default,NPOI.SS.UserModel,DataFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataFormatter.cs,FormatCellValue,The following switch statement is missing a default case: switch (cellType) {  case CellType.FORMULA:  	// should only occur if evaluator is null  	return cell.CellFormula;  case CellType.NUMERIC:  	if (DateUtil.IsCellDateFormatted (cell)) {  		return GetFormattedDateString (cell);  	}  	return GetFormattedNumberString (cell);  case CellType.STRING:  	return cell.RichStringCellValue.String;  case CellType.BOOLEAN:  	return cell.BooleanCellValue.ToString ().ToUpper ();  case CellType.BLANK:  	return "";  }  
Missing Default,NPOI.SS.UserModel,OperatorType,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DataValidationConstraint.cs,ValidateSecondArg,The following switch statement is missing a default case: switch (comparisonOperator) {  case BETWEEN:  	if (paramValue == null) {  		throw new ArgumentException ("expr2 must be supplied for 'between' comparisons");  	}  	break;  case NOT_BETWEEN:  	if (paramValue == null) {  		throw new ArgumentException ("expr2 must be supplied for 'between' comparisons");  	}  	break;  // all other operators don't need second arg  }  
Missing Default,NPOI.SS.UserModel,DateUtil,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\DateUtil.cs,IsADateFormat,The following switch statement is missing a default case: switch (nc) {  case '-':  case ''':  case '.':  case ' ':  case '\\':  	// skip current '\' and continue to the next char  	continue;  }  
Missing Default,NPOI.SS.UserModel,ErrorConstants,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ErrorConstants.cs,GetText,The following switch statement is missing a default case: switch (errorCode) {  case ERROR_NULL:  	return "#NULL!";  case ERROR_DIV_0:  	return "#DIV/0!";  case ERROR_VALUE:  	return "#VALUE!";  case ERROR_REF:  	return "#REF!";  case ERROR_NAME:  	return "#NAME?";  case ERROR_NUM:  	return "#NUM!";  case ERROR_NA:  	return "#N/A";  }  
Missing Default,NPOI.SS.UserModel,ErrorConstants,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\ErrorConstants.cs,IsValidCode,The following switch statement is missing a default case: switch (errorCode) {  case ERROR_NULL:  case ERROR_DIV_0:  case ERROR_VALUE:  case ERROR_REF:  case ERROR_NAME:  case ERROR_NUM:  case ERROR_NA:  	return true;  }  
Missing Default,NPOI.SS.UserModel,FontFamily,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontFamily.cs,ValueOf,The following switch statement is missing a default case: switch (family) {  case 0:  	return NOT_APPLICABLE;  case 1:  	return ROMAN;  case 2:  	return SWISS;  case 3:  	return MODERN;  case 4:  	return SCRIPT;  case 5:  	return DECORATIVE;  }  
Missing Default,NPOI.SS.UserModel,FontScheme,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FontScheme.cs,ValueOf,The following switch statement is missing a default case: switch (value) {  case 1:  	return NONE;  case 2:  	return MAJOR;  case 3:  	return MINOR;  }  
Missing Default,NPOI.SS.UserModel,FormulaError,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FormulaError.cs,ForInt,The following switch statement is missing a default case: switch (type) {  case 0x00:  	return FormulaError.NULL;  case 0x07:  	return FormulaError.DIV0;  case 0x0F:  	return FormulaError.VALUE;  case 0x17:  	return FormulaError.REF;  case 0x1D:  	return FormulaError.NAME;  case 0x24:  	return FormulaError.NUM;  case 0x2A:  	return FormulaError.NA;  }  
Missing Default,NPOI.SS.UserModel,FormulaError,C:\repos\xoposhiy_npoi\trunk\main\SS\UserModel\FormulaError.cs,ForString,The following switch statement is missing a default case: switch (code) {  case "#NULL!":  	return FormulaError.NULL;  case "#DIV/0!":  	return FormulaError.DIV0;  case "#VALUE!":  	return FormulaError.VALUE;  case "#REF!":  	return FormulaError.REF;  case "#NAME?":  	return FormulaError.NAME;  case "#NUM!":  	return FormulaError.NUM;  case "#N/A":  	return FormulaError.NA;  }  
Missing Default,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,ReadAConstantValue,The following switch statement is missing a default case: switch (grbit) {  case TYPE_EMPTY:  	in1.ReadLong ();  	// 8 byte 'not used' field  	return EMPTY_REPRESENTATION;  case TYPE_NUMBER:  	return in1.ReadDouble ();  case TYPE_STRING:  	return StringUtil.ReadUnicodeString (in1);  case TYPE_BOOLEAN:  	return ReadBoolean (in1);  case TYPE_ERROR_CODE:  	int errCode = in1.ReadUShort ();  	// next 6 bytes are Unused  	in1.ReadUShort ();  	in1.ReadInt ();  	return ErrorConstant.ValueOf (errCode);  }  
Missing Default,NPOI.SS.Formula.Constant,ConstantValueParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Constant\ConstantValueParser.cs,ReadBoolean,The following switch statement is missing a default case: switch (val) {  case FALSE_ENCODING:  	return false;  case TRUE_ENCODING:  	return true;  }  
Missing Default,NPOI.HSSF.Record.Crypto,Biff8RC4,C:\repos\xoposhiy_npoi\trunk\main\HSSF\Record\Crypto\Biff8RC4.cs,IsNeverEncryptedRecord,The following switch statement is missing a default case: switch (sid) {  case BOFRecord.sid:  // sheet BOFs for sure  // TODO - find out about chart BOFs  case InterfaceHdrRecord.sid:  // don't know why this record doesn't seem to get encrypted  case FilePassRecord.sid:  	// this only really counts when writing because FILEPASS is read early  	// UsrExcl(0x0194)  	// FileLock  	// RRDInfo(0x0196)  	// RRDHead(0x0138)  	return true;  }  
Missing Default,NPOI.SS.Formula.Eval.Forked,ForkedEvaluationCell,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\Forked\ForkedEvaluationCell.cs,CopyValue,The following switch statement is missing a default case: switch (_cellType) {  case CellType.BLANK:  	destCell.SetCellType (CellType.BLANK);  	return;  case CellType.NUMERIC:  	destCell.SetCellValue (_numberValue);  	return;  case CellType.BOOLEAN:  	destCell.SetCellValue (_boolValue);  	return;  case CellType.STRING:  	destCell.SetCellValue (_stringValue);  	return;  case CellType.ERROR:  	destCell.SetCellErrorValue ((byte)_errorValue);  	return;  }  
Missing Default,NPOI.SS.Formula.Eval.Forked,ForkedEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\Forked\ForkedEvaluator.cs,Evaluate,The following switch statement is missing a default case: switch (cell.CellType) {  case CellType.BOOLEAN:  	return BoolEval.ValueOf (cell.BooleanCellValue);  case CellType.ERROR:  	return ErrorEval.ValueOf (cell.ErrorCellValue);  case CellType.FORMULA:  	return _evaluator.Evaluate (cell);  case CellType.NUMERIC:  	return new NumberEval (cell.NumericCellValue);  case CellType.STRING:  	return new StringEval (cell.StringCellValue);  case CellType.BLANK:  	return null;  }  
Missing Default,NPOI.SS.Formula.PTG,ErrPtg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\ErrPtg.cs,ValueOf,The following switch statement is missing a default case: switch (code) {  case HSSFErrorConstants.ERROR_DIV_0:  	return DIV_ZERO;  case HSSFErrorConstants.ERROR_NA:  	return N_A;  case HSSFErrorConstants.ERROR_NAME:  	return NAME_INVALID;  case HSSFErrorConstants.ERROR_NULL:  	return NULL_INTERSECTION;  case HSSFErrorConstants.ERROR_NUM:  	return NUM_ERROR;  case HSSFErrorConstants.ERROR_REF:  	return REF_INVALID;  case HSSFErrorConstants.ERROR_VALUE:  	return VALUE_INVALID;  }  
Missing Default,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,CreateClassifiedPtg,The following switch statement is missing a default case: switch (baseId) {  case ArrayPtg.sid:  	return new ArrayPtg.Initial (in1);  // 0x20' 0x40' 0x60  case FuncPtg.sid:  	return FuncPtg.Create (in1);  // 0x21' 0x41' 0x61  case FuncVarPtg.sid:  	return FuncVarPtg.Create (in1);  // 0x22' 0x42' 0x62  case NamePtg.sid:  	return new NamePtg (in1);  // 0x23' 0x43' 0x63  case RefPtg.sid:  	return new RefPtg (in1);  // 0x24' 0x44' 0x64  case AreaPtg.sid:  	return new AreaPtg (in1);  // 0x25' 0x45' 0x65  case MemAreaPtg.sid:  	return new MemAreaPtg (in1);  // 0x26' 0x46' 0x66  case MemErrPtg.sid:  	return new MemErrPtg (in1);  // 0x27' 0x47' 0x67  case MemFuncPtg.sid:  	return new MemFuncPtg (in1);  // 0x29' 0x49' 0x69  case RefErrorPtg.sid:  	return new RefErrorPtg (in1);  // 0x2a' 0x4a' 0x6a  case AreaErrPtg.sid:  	return new AreaErrPtg (in1);  // 0x2b' 0x4b' 0x6b  case RefNPtg.sid:  	return new RefNPtg (in1);  // 0x2c' 0x4c' 0x6c  case AreaNPtg.sid:  	return new AreaNPtg (in1);  // 0x2d' 0x4d' 0x6d  case NameXPtg.sid:  	return new NameXPtg (in1);  // 0x39' 0x49' 0x79  case Ref3DPtg.sid:  	return new Ref3DPtg (in1);  // 0x3a' 0x5a' 0x7a  case Area3DPtg.sid:  	return new Area3DPtg (in1);  // 0x3b' 0x5b' 0x7b  case DeletedRef3DPtg.sid:  	return new DeletedRef3DPtg (in1);  // 0x3c' 0x5c' 0x7c  case DeletedArea3DPtg.sid:  	return new DeletedArea3DPtg (in1);  // 0x3d' 0x5d' 0x7d  }  
Missing Default,NPOI.SS.Formula.PTG,Ptg,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\PTG\Ptg.cs,CreateBasePtg,The following switch statement is missing a default case: switch (id) {  case 0x00:  	return new UnknownPtg ();  // TODO - not a real Ptg  case ExpPtg.sid:  	return new ExpPtg (in1);  // 0x01  case TblPtg.sid:  	return new TblPtg (in1);  // 0x02  case AddPtg.sid:  	return AddPtg.instance;  // 0x03  case SubtractPtg.sid:  	return SubtractPtg.instance;  // 0x04  case MultiplyPtg.sid:  	return MultiplyPtg.instance;  // 0x05  case DividePtg.sid:  	return DividePtg.instance;  // 0x06  case PowerPtg.sid:  	return PowerPtg.instance;  // 0x07  case ConcatPtg.sid:  	return ConcatPtg.instance;  // 0x08  case LessThanPtg.sid:  	return LessThanPtg.instance;  // 0x09  case LessEqualPtg.sid:  	return LessEqualPtg.instance;  // 0x0a  case EqualPtg.sid:  	return EqualPtg.instance;  // 0x0b  case GreaterEqualPtg.sid:  	return GreaterEqualPtg.instance;  // 0x0c  case GreaterThanPtg.sid:  	return GreaterThanPtg.instance;  // 0x0d  case NotEqualPtg.sid:  	return NotEqualPtg.instance;  // 0x0e  case IntersectionPtg.sid:  	return IntersectionPtg.instance;  // 0x0f  case UnionPtg.sid:  	return UnionPtg.instance;  // 0x10  case RangePtg.sid:  	return RangePtg.instance;  // 0x11  case UnaryPlusPtg.sid:  	return UnaryPlusPtg.instance;  // 0x12  case UnaryMinusPtg.sid:  	return UnaryMinusPtg.instance;  // 0x13  case PercentPtg.sid:  	return PercentPtg.instance;  // 0x14  case ParenthesisPtg.sid:  	return ParenthesisPtg.instance;  // 0x15  case MissingArgPtg.sid:  	return MissingArgPtg.instance;  // 0x16  case StringPtg.sid:  	return new StringPtg (in1);  // 0x17  case AttrPtg.sid:  	return new AttrPtg (in1);  // 0x19  case ErrPtg.sid:  	return new ErrPtg (in1);  // 0x1c  case BoolPtg.sid:  	return new BoolPtg (in1);  // 0x1d  case IntPtg.sid:  	return new IntPtg (in1);  // 0x1e  case NumberPtg.sid:  	return new NumberPtg (in1);  // 0x1f  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,IsValidDefinedNameChar,The following switch statement is missing a default case: switch (ch) {  case '.':  case '_':  case '?':  case '\\':  	// of all things  	return true;  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,IsUnquotedSheetNameChar,The following switch statement is missing a default case: switch (ch) {  case '.':  // dot is OK  case '_':  	// underscore is OK  	return true;  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseSimpleFactor,The following switch statement is missing a default case: switch (look) {  case '#':  	return new ParseNode (ErrPtg.ValueOf (ParseErrorLiteral ()));  case '-':  	Match ('-');  	return ParseUnary (false);  case '+':  	Match ('+');  	return ParseUnary (true);  case '(':  	Match ('(');  	ParseNode inside = ComparisonExpression ();  	Match (')');  	return new ParseNode (ParenthesisPtg.instance' inside);  case '"':  	return new ParseNode (new StringPtg (ParseStringLiteral ()));  case '{':  	Match ('{');  	ParseNode arrayNode = ParseArray ();  	Match ('}');  	return arrayNode;  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseArrayItem,The following switch statement is missing a default case: switch (look) {  case '"':  	return ParseStringLiteral ();  case '#':  	return ErrorConstant.ValueOf (ParseErrorLiteral ());  case 'F':  case 'f':  case 'T':  case 't':  	return ParseBooleanLiteral ();  case '-':  	Match ('-');  	SkipWhite ();  	return ConvertArrayNumber (ParseNumber ()' false);  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ParseErrorLiteral,The following switch statement is missing a default case: switch (part1 [0]) {  case 'V':  	if (part1.Equals ("VALUE")) {  		Match ('!');  		return HSSFErrorConstants.ERROR_VALUE;  	}  	throw expected ("#VALUE!");  case 'R':  	if (part1.Equals ("REF")) {  		Match ('!');  		return HSSFErrorConstants.ERROR_REF;  	}  	throw expected ("#REF!");  case 'D':  	if (part1.Equals ("DIV")) {  		Match ('/');  		Match ('0');  		Match ('!');  		return HSSFErrorConstants.ERROR_DIV_0;  	}  	throw expected ("#DIV/0!");  case 'N':  	if (part1.Equals ("NAME")) {  		Match ('?');  		// only one that ends in '?'  		return HSSFErrorConstants.ERROR_NAME;  	}  	if (part1.Equals ("NUM")) {  		Match ('!');  		return HSSFErrorConstants.ERROR_NUM;  	}  	if (part1.Equals ("NULL")) {  		Match ('!');  		return HSSFErrorConstants.ERROR_NULL;  	}  	if (part1.Equals ("N")) {  		Match ('/');  		if (look != 'A' && look != 'a') {  			throw expected ("#N/A");  		}  		Match (look);  		// Note - no '!' or '?' suffix  		return HSSFErrorConstants.ERROR_NA;  	}  	throw expected ("#NAME?' #NUM!' #NULL! or #N/A");  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,ComparisonExpression,The following switch statement is missing a default case: switch (look) {  case '=':  case '>':  case '<':  	Ptg comparisonToken = GetComparisonToken ();  	ParseNode other = ConcatExpression ();  	result = new ParseNode (comparisonToken' result' other);  	continue;  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,GetComparisonToken,The following switch statement is missing a default case: switch (look) {  case '=':  	Match ('=');  	return LessEqualPtg.instance;  case '>':  	Match ('>');  	return NotEqualPtg.instance;  }  
Missing Default,NPOI.SS.Formula,FormulaParser,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\FormulaParser.cs,UnionExpression,The following switch statement is missing a default case: switch (look) {  case ''':  	GetChar ();  	hasUnions = true;  	ParseNode other = ComparisonExpression ();  	result = new ParseNode (UnionPtg.instance' result' other);  	continue;  }  
Missing Default,NPOI.SS.Formula,OperandClassTransformer,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperandClassTransformer.cs,TransformClass,The following switch statement is missing a default case: switch (desiredOperandClass) {  case Ptg.CLASS_VALUE:  	if (!callerForceArrayFlag) {  		return Ptg.CLASS_VALUE;  	}  	return Ptg.CLASS_ARRAY;  //break;  // else fall through  case Ptg.CLASS_ARRAY:  	return Ptg.CLASS_ARRAY;  case Ptg.CLASS_REF:  	if (!callerForceArrayFlag) {  		return currentOperandClass;  	}  	return Ptg.CLASS_REF;  }  
Missing Default,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetDynamicReference,The following switch statement is missing a default case: switch (part1refType) {  case NameType.BAD_CELL_OR_NAMED_RANGE:  	return ErrorEval.REF_INVALID;  case NameType.NAMED_RANGE:  	IEvaluationName nm = ((IFormulaParsingWorkbook)_workbook).GetName (refStrPart1' _sheetIndex);  	if (!nm.IsRange) {  		throw new Exception ("Specified name '" + refStrPart1 + "' is not a range as expected.");  	}  	return _bookEvaluator.EvaluateNameFormula (nm.NameDefinition' this);  }  
Missing Default,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetDynamicReference,The following switch statement is missing a default case: switch (part1refType) {  case NameType.COLUMN:  case NameType.ROW:  	return ErrorEval.REF_INVALID;  case NameType.CELL:  	CellReference cr = new CellReference (refStrPart1);  	return new LazyRefEval (cr.Row' cr.Col' sre);  }  
Missing Default,NPOI.SS.Formula,OperationEvaluationContext,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluationContext.cs,GetDynamicReference,The following switch statement is missing a default case: switch (part2refType) {  case NameType.BAD_CELL_OR_NAMED_RANGE:  	return ErrorEval.REF_INVALID;  case NameType.NAMED_RANGE:  	throw new Exception ("Cannot Evaluate '" + refStrPart1 + "'. Indirect Evaluation of defined names not supported yet");  }  
Missing Default,NPOI.SS.Formula,OperationEvaluatorFactory,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\OperationEvaluatorFactory.cs,Evaluate,The following switch statement is missing a default case: switch (functionIndex) {  case NPOI.SS.Formula.Function.FunctionMetadataRegistry.FUNCTION_INDEX_INDIRECT:  	return Indirect.instance.Evaluate (args' ec);  case NPOI.SS.Formula.Function.FunctionMetadataRegistry.FUNCTION_INDEX_EXTERNAL:  	return UserDefinedFunction.instance.Evaluate (args' ec);  }  
Missing Default,NPOI.SS.Formula,SheetNameFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SheetNameFormatter.cs,NameLooksLikeBooleanLiteral,The following switch statement is missing a default case: switch (rawSheetName [0]) {  case 'T':  case 't':  	return "TRUE".Equals (rawSheetName' StringComparison.OrdinalIgnoreCase);  case 'F':  case 'f':  	return "FALSE".Equals (rawSheetName' StringComparison.OrdinalIgnoreCase);  }  
Missing Default,NPOI.SS.Formula,SheetNameFormatter,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\SheetNameFormatter.cs,IsSpecialChar,The following switch statement is missing a default case: switch (ch) {  case '.':  // dot is OK  case '_':  	// Underscore is ok  	return false;  case '\n':  case '\r':  case '\t':  	throw new Exception ("Illegal Char (0x" + StringUtil.ToHexString (ch) + ") found in sheet name");  }  
Missing Default,NPOI.SS.Formula,WorkbookEvaluator,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\WorkbookEvaluator.cs,GetValueFromNonFormulaCell,The following switch statement is missing a default case: switch (cellType) {  case CellType.NUMERIC:  	return new NumberEval (cell.NumericCellValue);  case CellType.STRING:  	return new StringEval (cell.StringCellValue);  case CellType.BOOLEAN:  	return BoolEval.ValueOf (cell.BooleanCellValue);  case CellType.BLANK:  	return BlankEval.instance;  case CellType.ERROR:  	return ErrorEval.ValueOf (cell.ErrorCellValue);  }  
Missing Default,NPOI.SS.Formula.Eval,ErrorEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\ErrorEval.cs,ValueOf,The following switch statement is missing a default case: switch (errorCode) {  case HSSFErrorConstants.ERROR_NULL:  	return NULL_INTERSECTION;  case HSSFErrorConstants.ERROR_DIV_0:  	return DIV_ZERO;  case HSSFErrorConstants.ERROR_VALUE:  	return VALUE_INVALID;  case HSSFErrorConstants.ERROR_REF:  	return REF_INVALID;  case HSSFErrorConstants.ERROR_NAME:  	return NAME_INVALID;  case HSSFErrorConstants.ERROR_NUM:  	return NUM_ERROR;  case HSSFErrorConstants.ERROR_NA:  	return NA;  // non-std errors (conditions modeled as errors by POI)  case CIRCULAR_REF_ERROR_CODE:  	return CIRCULAR_REF_ERROR;  case FUNCTION_NOT_IMPLEMENTED_CODE:  	return FUNCTION_NOT_IMPLEMENTED;  }  
Missing Default,NPOI.SS.Formula.Eval,ErrorEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\ErrorEval.cs,GetText,The following switch statement is missing a default case: switch (errorCode) {  case CIRCULAR_REF_ERROR_CODE:  	return "~CIRCULAR~REF~";  case FUNCTION_NOT_IMPLEMENTED_CODE:  	return "~FUNCTION~NOT~IMPLEMENTED~";  }  
Missing Default,NPOI.SS.Formula.Eval,FunctionEval,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Eval\FunctionEval.cs,GetBasicFunction,The following switch statement is missing a default case: switch (functionIndex) {  case FunctionID.INDIRECT:  case FunctionID.EXTERNAL_FUNC:  	return null;  }  
Missing Default,NPOI.SS.Formula.Functions,CalendarFieldFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\CalendarFieldFunction.cs,GetCalField,The following switch statement is missing a default case: switch (_dateFieldId) {  case YEAR_ID:  	return 1900;  case MONTH_ID:  	return 1;  case DAY_OF_MONTH_ID:  	return 0;  }  
Missing Default,NPOI.SS.Formula.Functions,Column,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Column.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 1:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]);  case 0:  	return new NumberEval (srcColumnIndex + 1);  }  
Missing Default,NPOI.SS.Formula.Functions,Countif,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Countif.cs,ParseBoolean,The following switch statement is missing a default case: switch (strRep [0]) {  case 't':  case 'T':  	if ("TRUE".Equals (strRep' StringComparison.OrdinalIgnoreCase)) {  		return true;  	}  	break;  case 'f':  case 'F':  	if ("FALSE".Equals (strRep' StringComparison.OrdinalIgnoreCase)) {  		return false;  	}  	break;  }  
Missing Default,NPOI.SS.Formula.Functions,FinanceFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\FinanceFunction.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' DEFAULT_ARG3' DEFAULT_ARG4);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' DEFAULT_ARG4);  case 5:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]' args [4]);  }  
Missing Default,NPOI.SS.Formula.Functions,Index,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Index.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Missing Default,NPOI.SS.Formula.Functions,Offset,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Offset.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 5:  	width = EvaluateIntArg (args [4]' srcCellRow' srcCellCol);  	break;  case 4:  	height = EvaluateIntArg (args [3]' srcCellRow' srcCellCol);  	break;  }  
Missing Default,NPOI.SS.Formula.Functions,Row,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Row.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 1:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]);  case 0:  	return new NumberEval (srcRowIndex + 1);  }  
Missing Default,NPOI.SS.Formula.Functions,Subtotal,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Subtotal.cs,FindFunction,The following switch statement is missing a default case: switch (functionCode) {  case 1:  	return AggregateFunction.SubtotalInstance (AggregateFunction.AVERAGE);  case 2:  	return Count.SubtotalInstance ();  case 3:  	return Counta.SubtotalInstance ();  case 4:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MAX);  case 5:  	return AggregateFunction.SubtotalInstance (AggregateFunction.MIN);  case 6:  	return AggregateFunction.SubtotalInstance (AggregateFunction.PRODUCT);  case 7:  	return AggregateFunction.SubtotalInstance (AggregateFunction.STDEV);  case 8:  	throw new NotImplementedException ("STDEVP");  case 9:  	return AggregateFunction.SubtotalInstance (AggregateFunction.SUM);  case 10:  	throw new NotImplementedException ("VAR");  case 11:  	throw new NotImplementedException ("VARP");  }  
Missing Default,NPOI.SS.Formula.Functions,Var1or2ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var1or2ArgFunction.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 1:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]);  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  }  
Missing Default,NPOI.SS.Formula.Functions,Var2or3ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var2or3ArgFunction.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 2:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]);  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  }  
Missing Default,NPOI.SS.Formula.Functions,Var3or4ArgFunction,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Functions\Var3or4ArgFunction.cs,Evaluate,The following switch statement is missing a default case: switch (args.Length) {  case 3:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]);  case 4:  	return Evaluate (srcRowIndex' srcColumnIndex' args [0]' args [1]' args [2]' args [3]);  }  
Missing Default,NPOI.SS.Formula.Function,FunctionMetadataReader,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadataReader.cs,IsDash,The following switch statement is missing a default case: switch (codes [0]) {  case '-':  	return true;  }  
Missing Default,NPOI.SS.Formula.Function,FunctionMetadataReader,C:\repos\xoposhiy_npoi\trunk\main\SS\Formula\Function\FunctionMetadataReader.cs,ParseOperandTypeCode,The following switch statement is missing a default case: switch (code [0]) {  case 'V':  	return Ptg.CLASS_VALUE;  case 'R':  	return Ptg.CLASS_REF;  case 'A':  	return Ptg.CLASS_ARRAY;  }  
Missing Default,NPOI.SS.Format,CellFormatPart,C:\repos\xoposhiy_npoi\trunk\main\SS\Format\CellFormatPart.cs,formatType,The following switch statement is missing a default case: switch (repl [0]) {  case '@':  	return CellFormatType.TEXT;  case 'd':  case 'D':  case 'y':  case 'Y':  	return CellFormatType.DATE;  case 'h':  case 'H':  case 'm':  case 'M':  case 's':  case 'S':  	// These can be part of date' or elapsed  	couldBeDate = true;  	break;  case '0':  	// This can be part of date' elapsed' or number  	seenZero = true;  	break;  case '[':  	return CellFormatType.ELAPSED;  case '#':  case '?':  	return CellFormatType.NUMBER;  }  
