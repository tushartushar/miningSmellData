Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,CryptHelper,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\CryptHelper.cs,GetProviderFromDerEncodedRsaPrivateKey,Cyclomatic complexity of the method is 14
Complex Method,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,CryptHelper,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\CryptHelper.cs,ReadFieldLength,Cyclomatic complexity of the method is 10
Complex Method,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,DefaultDkimSigner,Cyclomatic complexity of the method is 17
Complex Method,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,Cyclomatic complexity of the method is 8
Complex Method,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DkimSigningHandler,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DkimSigningHandler.cs,Execute,Cyclomatic complexity of the method is 12
Long Parameter List,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,DefaultDkimSigner,The method has 5 parameters.
Long Statement,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,CryptHelper,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\CryptHelper.cs,GetProviderFromPemEncodedRsaPrivateKey,The length of the statement  "	if (!encodedKey.StartsWith (PemRsaPrivateKeyHeader' StringComparison.Ordinal) || !encodedKey.EndsWith (PemRsaPrivateKeyFooter' StringComparison.Ordinal)) { " is 155.
Long Statement,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,CryptHelper,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\CryptHelper.cs,GetProviderFromPemEncodedRsaPrivateKey,The length of the statement  "	encodedKey = encodedKey.Substring (PemRsaPrivateKeyHeader.Length' encodedKey.Length - PemRsaPrivateKeyFooter.Length - PemRsaPrivateKeyHeader.Length); " is 149.
Long Statement,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,The length of the statement  "		while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) { " is 143.
Long Statement,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetCanonicalizedHeaders,The length of the statement  "		while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) { " is 143.
Long Statement,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetUnsignedDkimHeader,The length of the statement  "	return string.Format (CultureInfo.InvariantCulture' "DKIM-Signature: v=1; a={0}; s={1}; d={2}; c=simple/simple; q=dns/txt; h={3}; bh={4}; b=;"' this.hashAlgorithmDkimCode' this.selector' this.domain' string.Join (" : "' this.eligibleHeaders.OrderBy (x => x' StringComparer.Ordinal).ToArray ())' bodyHash); " is 305.
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,The following statement contains a magic number: while (line != null) {  	string header;  	string[] headerParts;  	// We've reached the end of the headers (headers are  	// separated from the body by a blank line).  	if (line.Length == 0) {  		break;  	}  	// Read a line. Because a header can be continued onto  	// subsequent lines' we have to keep reading lines until we  	// run into the end-of-headers marker (an empty line) or another  	// line that doesn't begin with a whitespace character.  	header = line + "\r\n";  	line = reader.ReadLine ();  	while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) {  		header += line + "\r\n";  		line = reader.ReadLine ();  	}  	// Extract the name of the header. Then store the full header  	// in the dictionary. We do this because DKIM mandates that we  	// only sign the LAST instance of any header that occurs.  	headerParts = header.Split (new char[] {  		':'  	}' 2);  	if (headerParts.Length == 2) {  		string headerName;  		headerName = headerParts [0];  		if (headerName.Equals ("From"' StringComparison.OrdinalIgnoreCase)) {  			// We don't break here because we want to read the bottom-most  			// instance of the From: header (there should be only one' but  			// if there are multiple' it's the last one that matters).  			canSign = header.ToUpperInvariant ().Contains ("@" + this.domain.ToUpperInvariant ());  		}  	}  }  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,The following statement contains a magic number: while (line != null) {  	string header;  	string[] headerParts;  	// We've reached the end of the headers (headers are  	// separated from the body by a blank line).  	if (line.Length == 0) {  		break;  	}  	// Read a line. Because a header can be continued onto  	// subsequent lines' we have to keep reading lines until we  	// run into the end-of-headers marker (an empty line) or another  	// line that doesn't begin with a whitespace character.  	header = line + "\r\n";  	line = reader.ReadLine ();  	while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) {  		header += line + "\r\n";  		line = reader.ReadLine ();  	}  	// Extract the name of the header. Then store the full header  	// in the dictionary. We do this because DKIM mandates that we  	// only sign the LAST instance of any header that occurs.  	headerParts = header.Split (new char[] {  		':'  	}' 2);  	if (headerParts.Length == 2) {  		string headerName;  		headerName = headerParts [0];  		if (headerName.Equals ("From"' StringComparison.OrdinalIgnoreCase)) {  			// We don't break here because we want to read the bottom-most  			// instance of the From: header (there should be only one' but  			// if there are multiple' it's the last one that matters).  			canSign = header.ToUpperInvariant ().Contains ("@" + this.domain.ToUpperInvariant ());  		}  	}  }  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,The following statement contains a magic number: headerParts = header.Split (new char[] {  	':'  }' 2);  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,CanSign,The following statement contains a magic number: if (headerParts.Length == 2) {  	string headerName;  	headerName = headerParts [0];  	if (headerName.Equals ("From"' StringComparison.OrdinalIgnoreCase)) {  		// We don't break here because we want to read the bottom-most  		// instance of the From: header (there should be only one' but  		// if there are multiple' it's the last one that matters).  		canSign = header.ToUpperInvariant ().Contains ("@" + this.domain.ToUpperInvariant ());  	}  }  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,WriteSignedMimeMessage,The following statement contains a magic number: streamBuffer = new byte[1024];  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetCanonicalizedHeaders,The following statement contains a magic number: while (line != null) {  	string header;  	string[] headerParts;  	// We've reached the end of the headers (headers are  	// separated from the body by a blank line).  	if (line.Length == 0) {  		break;  	}  	// Read a line. Because a header can be continued onto  	// subsequent lines' we have to keep reading lines until we  	// run into the end-of-headers marker (an empty line) or another  	// line that doesn't begin with a whitespace character.  	header = line + "\r\n";  	line = reader.ReadLine ();  	while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) {  		header += line + "\r\n";  		line = reader.ReadLine ();  	}  	// Extract the name of the header. Then store the full header  	// in the dictionary. We do this because DKIM mandates that we  	// only sign the LAST instance of any header that occurs.  	headerParts = header.Split (new char[] {  		':'  	}' 2);  	if (headerParts.Length == 2) {  		string headerName;  		headerName = headerParts [0];  		// We only want to sign the header if we were told to sign it!  		if (this.eligibleHeaders.Contains (headerName' StringComparer.OrdinalIgnoreCase)) {  			headerNameToLineMap [headerName] = header;  		}  	}  }  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetCanonicalizedHeaders,The following statement contains a magic number: while (line != null) {  	string header;  	string[] headerParts;  	// We've reached the end of the headers (headers are  	// separated from the body by a blank line).  	if (line.Length == 0) {  		break;  	}  	// Read a line. Because a header can be continued onto  	// subsequent lines' we have to keep reading lines until we  	// run into the end-of-headers marker (an empty line) or another  	// line that doesn't begin with a whitespace character.  	header = line + "\r\n";  	line = reader.ReadLine ();  	while (!string.IsNullOrEmpty (line) && (line.StartsWith ("\t"' StringComparison.Ordinal) || line.StartsWith (" "' StringComparison.Ordinal))) {  		header += line + "\r\n";  		line = reader.ReadLine ();  	}  	// Extract the name of the header. Then store the full header  	// in the dictionary. We do this because DKIM mandates that we  	// only sign the LAST instance of any header that occurs.  	headerParts = header.Split (new char[] {  		':'  	}' 2);  	if (headerParts.Length == 2) {  		string headerName;  		headerName = headerParts [0];  		// We only want to sign the header if we were told to sign it!  		if (this.eligibleHeaders.Contains (headerName' StringComparer.OrdinalIgnoreCase)) {  			headerNameToLineMap [headerName] = header;  		}  	}  }  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetCanonicalizedHeaders,The following statement contains a magic number: headerParts = header.Split (new char[] {  	':'  }' 2);  
Magic Number,NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler.Impl,DefaultDkimSigner,C:\repos\NeosIT_generic-exchange-transport-agent\NeosIT.Exchange.GenericExchangeTransportAgent.Plugins.DkimSigningHandler\Impl\DefaultDkimSigner.cs,GetCanonicalizedHeaders,The following statement contains a magic number: if (headerParts.Length == 2) {  	string headerName;  	headerName = headerParts [0];  	// We only want to sign the header if we were told to sign it!  	if (this.eligibleHeaders.Contains (headerName' StringComparer.OrdinalIgnoreCase)) {  		headerNameToLineMap [headerName] = header;  	}  }  
