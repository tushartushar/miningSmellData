Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Imms.Implementation,TreeIterator,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,SeekForwardCloseTo,Cyclomatic complexity of the method is 11
Complex Method,Imms.Implementation,TreeIterator,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,Imms.Implementation,TreeIterator,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\OrderedAvlTree\TreeIterator.cs,SeekForwardCloseTo,Cyclomatic complexity of the method is 11
Complex Method,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,WhereIsThisIndex,Cyclomatic complexity of the method is 8
Complex Method,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,WhereIsThisIndex,Cyclomatic complexity of the method is 11
Long Parameter List,Imms.Implementation,Measured<TObject>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Measured.cs,Insert,The method has 5 parameters. Parameters: index' leaf' value' rightmost1' lineage
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 6 parameters. Parameters: hash' bucket' left' right' eq' lin
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Root_Add,The method has 5 parameters. Parameters: k' v' lin' eq' overwrite
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlAdd,The method has 5 parameters. Parameters: hash' key' value' lineage' overwrite
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Split,The method has 5 parameters. Parameters: pivot' leftBranch' central' rightBranch' lin
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 6 parameters. Parameters: key' value' left' right' comparer' lineage
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Root_Add,The method has 5 parameters. Parameters: k' v' comparer' overwrite' lin
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Split,The method has 5 parameters. Parameters: pivot' leftBranch' central' rightBranch' lin
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArray,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArraySet,The method has 5 parameters. Parameters: sorted' startIndex' endIndex' comparer' lineage
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Node,The method has 5 parameters. Parameters: height' length' isFull' lineage' arrSize
Long Parameter List,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' count' i
Long Parameter List,Imms.Implementation,Bucket,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Bucket.cs,Bucket,The method has 5 parameters. Parameters: k' v' next' eq' lin
Long Parameter List,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' start' count
Long Parameter List,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The method has 5 parameters. Parameters: height' length' arr' lineage' arrSize
Long Parameter List,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The method has 5 parameters. Parameters: arr' lineage' maxHeight' start' count
Long Parameter List,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The method has 5 parameters. Parameters: one' two' three' four' lineage
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The method has 5 parameters. Parameters: lineage' item1' item2' item3' item4
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The method has 5 parameters. Parameters: other' leftmost' middle' rightmost' lineage
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,_mutate,The method has 6 parameters. Parameters: measure' size' a' b' c' d
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The method has 5 parameters. Parameters: a' b' c' d' lineage
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The method has 5 parameters. Parameters: index' leaf' leftmost' rightmost' lineage
Long Parameter List,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Split,The method has 5 parameters. Parameters: index' left' center' right' lineage
Long Parameter List,Imms.Implementation,EmptyTree,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Empty.cs,Split,The method has 5 parameters. Parameters: index' left' child' right' lineage
Long Parameter List,Imms.Implementation,Single,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,Split,The method has 5 parameters. Parameters: index' left' center' right' lineage
Long Parameter List,Imms.Implementation,Leaf<TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Leaf.cs,Insert,The method has 5 parameters. Parameters: index' leaf' leftmost' rightmost' lineage
Long Parameter List,Imms,ImmList<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,GroupJoin,The method has 5 parameters. Parameters: inner' outerKeySelector' innerKeySelector' resultSelector' eq
Long Parameter List,Imms,ImmList<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,Join,The method has 5 parameters. Parameters: inner' oKeySelector' iKeySelector' rSelector' eq
Long Parameter List,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,GroupJoin,The method has 5 parameters. Parameters: inner' outerKeySelector' innerKeySelector' resultSelector' eq
Long Parameter List,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,Join,The method has 5 parameters. Parameters: inner' oKeySelector' iKeySelector' rSelector' eq
Long Statement,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Intersect,The length of the statement  "				var duplicates = list.Select(x => new {x' count = list.Count(y => y.First.Equals(x.First))}).OrderByDescending(x => x.count); " is 125.
Long Statement,Imms.Implementation,Bucket,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Bucket.cs,Apply,The length of the statement  "				for (var cur = this; !cur.IsEmpty; cur = cur.Next) newBucket = new HashedAvlTree<TKey' TValue2>.Bucket(cur.Key' selector(cur.Key' cur.Value)' newBucket' Eq' lineage); " is 166.
Long Statement,Imms.Implementation,ImplErrors,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_digit_size,The length of the statement  "			return new ImplementationException(string.Format("This operation cannot be performed on a digit with this size. It was: {0}. More info: {1}"' size' message)); " is 158.
Long Statement,Imms.Implementation,ImplErrors,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_execution_path,The length of the statement  "			return new ImplementationException(string.Format("An execution has reached a block never meant to be executed. More info: {0}"' info)); " is 135.
Long Statement,Imms.Implementation,ImplErrors,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\Common\Errors.cs,Invalid_invocation,The length of the statement  "			return new ImplementationException(string.Format("This operation cannot be executed on this kind of object. It was of the kind: {0}"' objectKind)); " is 147.
Long Statement,Imms.Implementation,ImplErrors,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\Common\Errors.cs,Arg_out_of_range,The length of the statement  "			return new ImplementationException(string.Format("An argument was out of range.\r\nName: {0}\t Value: {1}"' name' value)); " is 122.
Long Statement,Imms.Implementation,FingerTreeIterator<TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The length of the statement  "			AssertEx.AssertTrue(top.Object.ChildCount > 0 || top.Object.IsLeaf || _future.Count == 1); //only possible if tree is empty " is 123.
Long Statement,Imms,ImmMap<TKey;TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\ImmMap\Debugging.cs,RemoveRange,The length of the statement  "			if (set != null && _equality.Equals(set.EqualityComparer)) return _root.Except(set.Root' Lineage.Mutable()).WrapMap(_equality); " is 127.
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: if (factor == -2) {  					var rFactor = right.Factor;  #if ASSERTS  					rFactor.AssertBetween(-1' 1);  #endif  					if (rFactor == 1) {  						var newLeft = WithChildren(this' left' right.Left.Left' lineage);  						var rootFrom = right.Left;  						var newRight = WithChildren(right' right.Left.Right' right.Right' lineage);  						newRoot = WithChildren(rootFrom' newLeft' newRight' lineage);  					} else {  						var newLeft = WithChildren(this' left' right.Left' lineage);  						newRoot = WithChildren(right' newLeft' right.Right' lineage);  					}  				} else if (factor == 2) {  					var lFactor = left.Factor;  #if ASSERTS  					lFactor.AssertBetween(-1' 1);  #endif  					if (lFactor == -1) {  						var newRight = WithChildren(this' left.Right.Right' right' lineage);  						var rootFrom = left.Right;  						var newLeft = WithChildren(left' left.Left' left.Right.Left' lineage);  						newRoot = WithChildren(rootFrom' newLeft' newRight' lineage);  					} else {  						var newRight = WithChildren(this' left.Right' right' lineage);  						newRoot = WithChildren(left' left.Left' newRight' lineage);  					}  				} else newRoot = WithChildren(this' left' right' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: if (factor == -2) {  					var rFactor = right.Factor;  #if ASSERTS  					rFactor.AssertBetween(-1' 1);  #endif  					if (rFactor == 1) {  						var newLeft = WithChildren(this' left' right.Left.Left' lineage);  						var rootFrom = right.Left;  						var newRight = WithChildren(right' right.Left.Right' right.Right' lineage);  						newRoot = WithChildren(rootFrom' newLeft' newRight' lineage);  					} else {  						var newLeft = WithChildren(this' left' right.Left' lineage);  						newRoot = WithChildren(right' newLeft' right.Right' lineage);  					}  				} else if (factor == 2) {  					var lFactor = left.Factor;  #if ASSERTS  					lFactor.AssertBetween(-1' 1);  #endif  					if (lFactor == -1) {  						var newRight = WithChildren(this' left.Right.Right' right' lineage);  						var rootFrom = left.Right;  						var newLeft = WithChildren(left' left.Left' left.Right.Left' lineage);  						newRoot = WithChildren(rootFrom' newLeft' newRight' lineage);  					} else {  						var newRight = WithChildren(this' left.Right' right' lineage);  						newRoot = WithChildren(left' left.Left' newRight' lineage);  					}  				} else newRoot = WithChildren(this' left' right' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: if (newFactor >= 2) {  					var newRight = Concat(leftBranch.Right' pivot' rightBranch' lin);  					balanced = leftBranch.AvlBalance(leftBranch.Left' newRight' lin);  				} else if (newFactor <= -2) {  					var newLeft = Concat(leftBranch' pivot' rightBranch.Left' lin);  					balanced = rightBranch.AvlBalance(newLeft' rightBranch.Right' lin);  				} else balanced = WithChildren(pivot' leftBranch' rightBranch' lin);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: if (newFactor >= 2) {  					var newRight = Concat(leftBranch.Right' pivot' rightBranch' lin);  					balanced = leftBranch.AvlBalance(leftBranch.Left' newRight' lin);  				} else if (newFactor <= -2) {  					var newLeft = Concat(leftBranch' pivot' rightBranch.Left' lin);  					balanced = rightBranch.AvlBalance(newLeft' rightBranch.Right' lin);  				} else balanced = WithChildren(pivot' leftBranch' rightBranch' lin);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: factor.AssertBetween(-2' 2);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: if (factor == -2) {  					var rFactor = right.Factor;  #if ASSERTS  					rFactor.AssertBetween(-1' 1);  #endif    					if (rFactor == 1) {  						var newLeft = WithChildren(left' right.Left.Left' lineage);  						var rootFrom = right.Left;  						var newRight = right.WithChildren(right.Left.Right' right.Right' lineage);  						newRoot = rootFrom.WithChildren(newLeft' newRight' lineage);  					} else {  						var newLeft = WithChildren(left' right.Left' lineage);  						newRoot = right.WithChildren(newLeft' right.Right' lineage);  					}  				} else if (factor == 2) {  					var lFactor = left.Factor;  #if ASSERTS  					lFactor.AssertBetween(-1' 1);  #endif  					if (lFactor == -1) {  						var newRight = WithChildren(left.Right.Right' right' lineage);  						var rootFrom = left.Right;  						var newLeft = left.WithChildren(left.Left' left.Right.Left' lineage);  						newRoot = rootFrom.WithChildren(newLeft' newRight' lineage);  					} else {  						var newRight = WithChildren(left.Right' right' lineage);  						newRoot = left.WithChildren(left.Left' newRight' lineage);  					}  				} else newRoot = WithChildren(left' right' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,AvlBalance,The following statement contains a magic number: if (factor == -2) {  					var rFactor = right.Factor;  #if ASSERTS  					rFactor.AssertBetween(-1' 1);  #endif    					if (rFactor == 1) {  						var newLeft = WithChildren(left' right.Left.Left' lineage);  						var rootFrom = right.Left;  						var newRight = right.WithChildren(right.Left.Right' right.Right' lineage);  						newRoot = rootFrom.WithChildren(newLeft' newRight' lineage);  					} else {  						var newLeft = WithChildren(left' right.Left' lineage);  						newRoot = right.WithChildren(newLeft' right.Right' lineage);  					}  				} else if (factor == 2) {  					var lFactor = left.Factor;  #if ASSERTS  					lFactor.AssertBetween(-1' 1);  #endif  					if (lFactor == -1) {  						var newRight = WithChildren(left.Right.Right' right' lineage);  						var rootFrom = left.Right;  						var newLeft = left.WithChildren(left.Left' left.Right.Left' lineage);  						newRoot = rootFrom.WithChildren(newLeft' newRight' lineage);  					} else {  						var newRight = WithChildren(left.Right' right' lineage);  						newRoot = left.WithChildren(left.Left' newRight' lineage);  					}  				} else newRoot = WithChildren(left' right' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: if (newFactor >= 2) {  					var newRight = Concat(leftBranch.Right' pivot' rightBranch' lineage);  					balanced = leftBranch.AvlBalance(leftBranch.Left' newRight' lineage);  				} else if (newFactor <= -2) {  					var newLeft = Concat(leftBranch' pivot' rightBranch.Left' lineage);  					balanced = rightBranch.AvlBalance(newLeft' rightBranch.Right' lineage);  				} else balanced = pivot.WithChildren(leftBranch' rightBranch' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,Concat,The following statement contains a magic number: if (newFactor >= 2) {  					var newRight = Concat(leftBranch.Right' pivot' rightBranch' lineage);  					balanced = leftBranch.AvlBalance(leftBranch.Left' newRight' lineage);  				} else if (newFactor <= -2) {  					var newLeft = Concat(leftBranch' pivot' rightBranch.Left' lineage);  					balanced = rightBranch.AvlBalance(newLeft' rightBranch.Right' lineage);  				} else balanced = pivot.WithChildren(leftBranch' rightBranch' lineage);
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedList,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArray,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Node,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\HashedAvlTree\Node.cs,FromSortedArraySet,The following statement contains a magic number: var pivotIndex = startIndex + (endIndex - startIndex) / 2;
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,UpdateStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[index] = v;  					return Arr;  				} else return Arr.Update(index' v' ArrSize);
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,UpdateStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[index] = v;  					return Arr;  				} else return Arr.Update(index' v' ArrSize);
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddToStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[ArrSize] = v;  					return Arr;  				} else {  					var arr = Arr.Resize(ArrSize + 1);  					arr[ArrSize] = v;  					return arr;  				}
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddToStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[ArrSize] = v;  					return Arr;  				} else {  					var arr = Arr.Resize(ArrSize + 1);  					arr[ArrSize] = v;  					return arr;  				}
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,_mutate,The following statement contains a magic number: IsFull = arrSize == 32;
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,Add,The following statement contains a magic number: if (ArrSize < 32) {  					var myCopy = AddToStore(item' lineage);  					ret = MutateOrCreate(ArrSize + 1' myCopy' lineage);  				} else {  					var newLeaf = new Leaf(item' lineage);  					ret = new Parent(this' newLeaf' lineage);  				}
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var len = ArrSize + count > 32 ? 32 - ArrSize : count;
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: var len = ArrSize + count > 32 ? 32 - ArrSize : count;
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: if (Height < maxHeight && count > 0) {  					var parentArr = ArrayExt.OfItems(32' ret' Empty);  					var myParent = new Parent(1' ret.Length' parentArr' lineage' 2);  					ret = myParent.AddRange(arr' lineage' maxHeight' ref start' ref count);  				}
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,AddRange,The following statement contains a magic number: if (Height < maxHeight && count > 0) {  					var parentArr = ArrayExt.OfItems(32' ret' Empty);  					var myParent = new Parent(1' ret.Length' parentArr' lineage' 2);  					ret = myParent.AddRange(arr' lineage' maxHeight' ref start' ref count);  				}
Magic Number,Imms.Implementation,Leaf,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorLeaf.cs,RemoveLast,The following statement contains a magic number: var beforeLast = Length > 1 ? Optional.Some(this[Length - 2]) : Optional.None;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _offs = height * 5;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _myBlock = ((1 << 5) - 1) << _offs;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _offs = Height * 5;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Parent,The following statement contains a magic number: _myBlock = ((1 << 5) - 1) << _offs;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,_mutate,The following statement contains a magic number: IsFull = arrSize == 32 && arr[arrSize-1].Height == Height - 1 && arr[arrSize - 1].IsFull;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,UpdateStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[index] = v;  					return Arr;  				} else return Arr.Update(index' v' ArrSize);
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,UpdateStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[index] = v;  					return Arr;  				} else return Arr.Update(index' v' ArrSize);
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddToStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[ArrSize] = v;  					return Arr;  				} else {  					var arr = Arr.Resize(ArrSize + 1);  					arr[ArrSize] = v;  					return arr;  				}
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddToStore,The following statement contains a magic number: if (Lineage.AllowMutation(lineage)) {  					if (Arr.Length < 32) Arr = Arr.Resize(32);  					Arr[ArrSize] = v;  					return Arr;  				} else {  					var arr = Arr.Resize(ArrSize + 1);  					arr[ArrSize] = v;  					return arr;  				}
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Add,The following statement contains a magic number: if (!lastNode.IsFull || lastNode.Height < Height - 1) {  					var newNode = lastNode.Add(item' lineage);  					var myCopy = UpdateStore(lastIndex' newNode' lineage);  					ret = MutateOrCreate(Length + 1' ArrSize' myCopy' lineage);  				} else if (ArrSize != 32) {  					var newNode = new Leaf(item' lineage);  					var newArr = AddToStore(newNode' lineage);  					ret = MutateOrCreate(Length + 1' ArrSize + 1' newArr' lineage);  				} else {  					var newArr = new Node[] { this' new Leaf(item' lineage) };  					ret = new Parent(Height + 1' Length + 1' newArr' lineage' 2);  				}
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,Add,The following statement contains a magic number: if (!lastNode.IsFull || lastNode.Height < Height - 1) {  					var newNode = lastNode.Add(item' lineage);  					var myCopy = UpdateStore(lastIndex' newNode' lineage);  					ret = MutateOrCreate(Length + 1' ArrSize' myCopy' lineage);  				} else if (ArrSize != 32) {  					var newNode = new Leaf(item' lineage);  					var newArr = AddToStore(newNode' lineage);  					ret = MutateOrCreate(Length + 1' ArrSize + 1' newArr' lineage);  				} else {  					var newArr = new Node[] { this' new Leaf(item' lineage) };  					ret = new Parent(Height + 1' Length + 1' newArr' lineage' 2);  				}
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The following statement contains a magic number: var newArr = Arr.Resize(32);
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,AddRange,The following statement contains a magic number: for (i = ArrSize - 1; i < 32 && count > 0; i++) {  					newArr[i] = newArr[i] ?? Empty;  					newArr[i] = newArr[i].AddRange(arr' lineage' Height - 1' ref start' ref count);  				}
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,RemoveLast,The following statement contains a magic number: var expectedLast = Length > 1 ? Optional.Some(this[Length - 2]) : Optional.None;
Magic Number,Imms.Implementation,Parent,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\TrieVector\VectorParent.cs,RemoveLast,The following statement contains a magic number: if (ArrSize == 2 && Arr[1].Length == 1) ret = Arr[0];  				else if (Arr[ArrSize - 1].Length == 1) ret = MutateOrCreate(Length - 1' ArrSize - 1' Arr.Resize(ArrSize - 1)' lineage);  				else {  					var newLast = Arr[ArrSize - 1].RemoveLast(lineage);  					var newArr = UpdateStore(ArrSize - 1' newLast' lineage);  					ret = MutateOrCreate(Length - 1' ArrSize' newArr' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: var myChildSize = FastMath.PowN(3' Nesting - 1);
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Construct,The following statement contains a magic number: if (divRem == 0 && (number = count / myChildSize) <= 8) {  					switch (number) {  						case 0:  							return Empty;  						case 1:  						case 2:  						case 3:  						case 4:  							var center = digit.ConstructMult(arr' ref index' number' lin);  							ret = new Single(center' lin);  							break;  						case 5:  							var left1 = digit.Construct3(arr' ref index' lin);  							var right1 = digit.ConstructMult(arr' ref index' 2' lin);  							ret = new Compound(left1' FTree<Digit>.Empty' right1' lin);  							break;  						case 6:  							var left2 = digit.Construct3(arr' ref index' lin);  							var right2 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left2' FTree<Digit>.Empty' right2' lin);  							break;  						case 7:  							var left3 = digit.ConstructMult(arr' ref index' 4' lin);  							var right3 = digit.Construct3(arr' ref index' lin);  							ret = new Compound(left3' FTree<Digit>.Empty' right3' lin);  							break;  						case 8:  							var left4 = digit.ConstructMult(arr' ref index' 4' lin);  							var right4 = digit.ConstructMult(arr' ref index' 4' lin);  							ret = new Compound(left4' FTree<Digit>.Empty' right4' lin);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("An if statement just checked if number <= 8.");  					}    				} else {  					var nextChildSize = myChildSize * 3;  					var nextDivRem = count % nextChildSize;  #if ASSERTS  					//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize  					//and since nextChildSize = myChildSize * 3' then nextDivRem % myChildSize must be within [0'2].  					//we maintain this invariant by the next if-else block' which makes sure that the 'count' for the next invocation  					//really is divisible by nextChildSize. At the topmost level' myChildSize is 1' and nextChildSize is 3.   					  					(nextDivRem % myChildSize).AssertBetween(0' 2);  #endif  					if (nextDivRem == 0) {  						//If nextDivRem is already divisible by nextChildSize' we should preserve this by removing 2*nextChildSize from it.  						//Since 2*nextChildSize = 0 (mod nextChildSize)' the divisibility is preserved.  						var left = digit.Construct3(arr' ref index' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - (nextChildSize << 1)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else if (nextDivRem == myChildSize) {  						//In this case' nextDivRem % myChildSize == 1.   						//In order to make sure 'count' is divisible by nextChildSize' we need to remove 1 myChildSize from it.  						//while also filling the current finger tree level. So we remove 7*myChildSize' which is   						//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + myChildSize)' lin);  						var right = digit.Construct3(arr' ref index' lin);  						ret = new Compound(left' deep' right' lin);  					} else {  						//like the other cases.  						var left = digit.ConstructMult(arr' ref index' 4' lin);  						var deep = FTree<Digit>.Construct(arr' ref index' count - ((nextChildSize << 1) + (myChildSize << 1))' lin);  						var right = digit.ConstructMult(arr' ref index' 4' lin);  						ret = new Compound(left' deep' right' lin);  					}  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: var status = first._kind << 3 | last._kind;
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following statement contains a magic number: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: memberPermutation |= right != null ? 1 << 2 : 0;
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,CreateCheckNull,The following statement contains a magic number: switch (memberPermutation) {  						case 0 << 0| 0 << 1 | 0 << 2:  							return Empty;  						case 1 << 0 | 0 << 1 | 0 << 2:  							return new Single(left' lineage);  						case 1 << 0 | 1 << 1 | 0 << 2:  							var r2 = deep.Right;  							var deep1 = deep.RemoveLast(lineage);    							return MutateOrCreate(left' deep1' r2' lineage);  						case 1 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 1 << 2:  							return MutateOrCreate(deep.Left' deep.RemoveFirst(lineage)' right' lineage);  						case 1 << 0 | 0 << 1 | 1 << 2:  							return MutateOrCreate(left' deep' right' lineage);  						case 0 << 0 | 1 << 1 | 0 << 2:  							left = deep.Left;  							deep = deep.RemoveFirst(lineage);  							if (deep.Measure != 0) {  								right = deep.Right;  								deep = deep.RemoveLast(lineage);  								return MutateOrCreate(left' deep' right' lineage);  							}  							return new Single(left' lineage);  						case 0 << 0 | 0 << 1 | 1 << 2:  							return new Single(right' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Explicitly checked all possible tree permutations.");  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,AddFirst,The following statement contains a magic number: if (LeftDigit.Size < 4) ret = MutateOrCreate(LeftDigit.AddFirst(item' lineage)' DeepTree' RightDigit' lineage);  					else {  						var leftmost = new Digit(item' LeftDigit.First' lineage);  						var rightmost = LeftDigit.RemoveFirst(lineage);  						var newDeep = DeepTree.AddFirst(rightmost' lineage);  						ret = MutateOrCreate(leftmost' newDeep' RightDigit' lineage);  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,AddLast,The following statement contains a magic number: if (RightDigit.Size < 4) ret = MutateOrCreate(LeftDigit' DeepTree' RightDigit.AddLast(item' lineage)' lineage);  					else {  						var rightmost = new Digit(RightDigit.Fourth' item' lineage);  						var leftmost = RightDigit.RemoveLast(lineage);  						var newDeep = DeepTree.AddLast(leftmost' lineage);  						ret = MutateOrCreate(LeftDigit' newDeep' rightmost' lineage);  					}
Magic Number,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return LeftDigit;  						case 1:  							return DeepTree;  						case 2:  							return RightDigit;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 2;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 3;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Digit,The following statement contains a magic number: Size = 4;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,ConstructMult,The following statement contains a magic number: switch (mult) {  						case 1:  							return new Digit(c.Construct3(arr' ref index' lin)' lin);  						case 2:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						case 3:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' lin);  						case 4:  							return new Digit(c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)'  								c.Construct3(arr' ref index' lin)' c.Construct3(arr' ref index' lin)' lin);  						default:  							throw ImplErrors.Bad_digit_size(mult);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Print,The following statement contains a magic number: switch (Size) {  						case 1:  							rest = new[] { First.Print() };  							break;  						case 2:  							rest = new[] { First.Print()' Second.Print() };  							break;  						case 3:  							rest = new[] { First.Print()' Second.Print()' Third.Print() };  							break;  						case 4:  							rest = new[] { First.Print()' Second.Print()' Third.Print()' Fourth.Print() };  							break;  						default:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return First;  						case 1:  							return Second;  						case 2:  							return Third;  						case 3:  							return Fourth;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,GetChild,The following statement contains a magic number: switch (index) {  						case 0:  							return First;  						case 1:  							return Second;  						case 2:  							return Third;  						case 3:  							return Fourth;  						default:  							throw ImplErrors.Arg_out_of_range("index"' index);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item2 != null ? 2 : 0;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item3 != null ? 4 : 0;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: itemsPresent |= item4 != null ? 8 : 0;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,CreateCheckNull,The following statement contains a magic number: switch (itemsPresent) {  						case 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:  							res = null;  							break;  						case 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item2' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item3' lineage);  							break;  						case 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item2' item3' lineage);  							break;  						case 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item2' item3' lineage);  							break;  						case 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item3' item4' lineage);  							break;  						case 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item3' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:  							res = MutateOrCreate(item1' item3' lineage);  							break;  						case 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item3' item4' lineage);  							break;  						case 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item2' item4' lineage);  							break;  						case 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item4' lineage);  							break;  						case 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:  							res = MutateOrCreate(item1' item2' item4' lineage);  							break;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all digit permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: var match = (Size << 3) | other.Size;
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Fuse,The following statement contains a magic number: switch (match) {  						case 1 << 3 | 1:  							leftmost = MutateOrCreate(First' other.First' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 2:  							leftmost = MutateOrCreate(First' other.First' other.Second' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 3:  							leftmost = MutateOrCreate(First' other.First' other.Second' other.Third' lineage);  							rightmost = null;  							middle = null;  							return;  						case 1 << 3 | 4:  							leftmost = new Digit(First' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 2 << 3 | 1:  							leftmost = MutateOrCreate(First' Second' other.First' lineage);  							middle = null;  							rightmost = null;  							return;  						case 2 << 3 | 2:  						case 2 << 3 | 3:  						case 3 << 3 | 2:  						case 3 << 3 | 3:  							leftmost = this;  							middle = other;  							rightmost = null;  							return;  						case 2 << 3 | 4:  							leftmost = new Digit(First' Second' other.First' lineage);  							middle = MutateOrCreate(other.Second' other.Third' other.Fourth' lineage);  							rightmost = null;  							return;  						case 3 << 3 | 4:  							leftmost = this;  							middle = new Digit(other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						case 3 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 1:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' other.First' lineage);  							rightmost = null;  							return;  						case 4 << 3 | 2:  						case 4 << 3 | 3:  							leftmost = new Digit(First' Second' lineage);  							middle = MutateOrCreate(Third' Fourth' lineage);  							rightmost = other;  							return;  						case 4 << 3 | 4:  							leftmost = new Digit(First' Second' Third' lineage);  							middle = new Digit(Fourth' other.First' other.Second' lineage);  							rightmost = other.MutateOrCreate(other.Third' other.Fourth' lineage);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all possible size permutations already.");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,_mutate,The following statement contains a magic number: if (notNull.Length != 2) {  						//a hack allows one of the inner elements to be fragments...  						notNull.All(x => !x.IsFragment).AssertTrue();  					}  					else {  						notNull[1].IsFragment.AssertFalse(); //this only applies to the 1st element!  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage) ? _mutate(a.Measure + b.Measure' 2' a' b) : new Digit(a' b' lineage);
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage)  						? _mutate(a.Measure + b.Measure + c.Measure' 3' a' b' c) : new Digit(a' b' c' lineage);
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,MutateOrCreate,The following statement contains a magic number: return Lineage.AllowMutation(lineage)  						? _mutate(a.Measure + b.Measure + c.Measure + d.Measure' 4' a' b' c' d) : new Digit(a' b' c' d' lineage);
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Insert,The following statement contains a magic number: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_1:  							First.Insert(index' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {    								leftmost = new Digit(myLeftmost' myRightmost' Second' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' myLeftmost' myRightmost' Second' Third)  								: CreateCheckNull(lineage' myLeftmost' Second' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_2:  						case IN_MIDDLE_OF_2:  							Second.Insert(index - First.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' myLeftmost' myRightmost' lineage);  								rightmost = MutateOrCreate(Third' Fourth' lineage);  								return;  							}  							leftmost = myRightmost != null  								? CreateCheckNull(lineage' First' myLeftmost' myRightmost' Third)  								: CreateCheckNull(lineage' First' myLeftmost' Third' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_3:  						case IN_MIDDLE_OF_3:  							Third.Insert(index - First.Measure - Second.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' myLeftmost' lineage);  								rightmost = MutateOrCreate(myRightmost' Fourth' lineage);  								return;  							}  							leftmost =  								myRightmost != null  									? CreateCheckNull(lineage' First' Second' myLeftmost' myRightmost)  									: CreateCheckNull(lineage' First' Second' myLeftmost' Fourth);  							rightmost = null;  							return;  						case IN_START_OF_4:  						case IN_MIDDLE_OF_4:  							Fourth.Insert(index - Measure + Fourth.Measure' leaf' out myLeftmost' out myRightmost' lineage);  							if (Size == 4 && myRightmost != null) {  								leftmost = new Digit(First' Second' Third' lineage);  								rightmost = MutateOrCreate(myLeftmost' myRightmost' lineage);  								return;  							}  							leftmost = MutateOrCreate(First' Second' Third' myLeftmost' lineage);  							rightmost = null;  							return;						  						default:  							throw ImplErrors.Invalid_execution_path("");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Iter,The following statement contains a magic number: switch (Size) {  						case 1:  							First.Iter(action);  							return;  						case 2:  							First.Iter(action);  							Second.Iter(action);  							return;  						case 3:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							return;  						case 4:  							First.Iter(action);  							Second.Iter(action);  							Third.Iter(action);  							Fourth.Iter(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,IterBack,The following statement contains a magic number: switch (Size) {  						case 1:  							First.IterBack(action);  							return;  						case 2:  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 3:  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						case 4:  							Fourth.IterBack(action);  							Third.IterBack(action);  							Second.IterBack(action);  							First.IterBack(action);  							return;  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes already");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following statement contains a magic number: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,Reverse,The following statement contains a magic number: switch (Size) {  						case 1:  							return MutateOrCreate(First.Reverse(lineage)' lineage);  						case 2:  							return MutateOrCreate(Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 3:  							return MutateOrCreate(Third.Reverse(lineage)' Second.Reverse(lineage)' First.Reverse(lineage)' lineage);  						case 4:  							return MutateOrCreate(Fourth.Reverse(lineage)' Third.Reverse(lineage)' Second.Reverse(lineage)'  								First.Reverse(lineage)' lineage);  						default:  							throw ImplErrors.Invalid_execution_path("Checked all sizes");  					}
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: if (nextObj.ChildCount == 0) {    				//this can only happen if we're in Compound(Digit' Empty' Digit).  				obj.ChildCount.AssertEqual(3);  				top.Mark.AssertEqual(0);    				top.SetMark(2);  				nextObj = obj.GetChild(2);  			} else top.SetMark(top.Mark + 1);
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: if (nextObj.ChildCount == 0) {    				//this can only happen if we're in Compound(Digit' Empty' Digit).  				obj.ChildCount.AssertEqual(3);  				top.Mark.AssertEqual(0);    				top.SetMark(2);  				nextObj = obj.GetChild(2);  			} else top.SetMark(top.Mark + 1);
Magic Number,Imms.Implementation,FingerTreeIterator<TValue>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\FingerTreeIterator.cs,MoveNext,The following statement contains a magic number: if (nextObj.ChildCount == 0) {    				//this can only happen if we're in Compound(Digit' Empty' Digit).  				obj.ChildCount.AssertEqual(3);  				top.Mark.AssertEqual(0);    				top.SetMark(2);  				nextObj = obj.GetChild(2);  			} else top.SetMark(top.Mark + 1);
Magic Number,Imms.Implementation,Single,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,AddFirst,The following statement contains a magic number: if (CenterDigit.Size < 4) ret = MutateOrCreate(CenterDigit.AddFirst(item' lineage)' lineage);  					else {  						var leftmost = new Digit(item' CenterDigit.First' lineage);  						var rightmost = CenterDigit.RemoveFirst(lineage);  						ret = new Compound(leftmost' FTree<Digit>.Empty' rightmost' lineage);  					}
Magic Number,Imms.Implementation,Single,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Single.cs,AddLast,The following statement contains a magic number: if (CenterDigit.Size < 4) ret = new Single(CenterDigit.AddLast(item' lineage)' lineage);  					else {  						var rightmost = new Digit(CenterDigit.Fourth' item' lineage);  						var leftmost = CenterDigit.RemoveLast(lineage);    						ret = new Compound(leftmost' FTree<Digit>.Empty' rightmost' lineage);  					}
Magic Number,Imms,Builder,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\ImmSortedMap\ImmBindings.cs,AddRange,The following statement contains a magic number: _inner = _inner.AddRange(arr' _lineage' 6' ref s' ref len);
Magic Number,Imms,ImmList<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\List\Boilerplate.cs,RemoveLast,The following statement contains a magic number: if (ret.Root.Measure > 0) {  				ret.Last.AssertEqual(this[-2]);  			}
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,InsertRange,The following statement contains a magic number: start = start.AddRange(arrInsert' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,InsertRange,The following statement contains a magic number: start = start.AddRange(arrAfter' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,RemoveAt,The following statement contains a magic number: var ret = take.AddRange(arr' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,Insert,The following statement contains a magic number: var ret = take.AddRange(arr' lineage' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,AddLastRange,The following statement contains a magic number: ImmVector<T> ret = Root.AddRange(arr' Lineage.Mutable()' 6' ref s' ref len);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,CopyFrom,The following statement contains a magic number: var ret = Root.AddRange(arr' lineage' 6' ref startIndex' ref count);
Magic Number,Imms,ImmVector<T>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Wrappers\Immutable\Vector\Boilerplate.cs,RemoveLast,The following statement contains a magic number: if (Length > 1) ret.Last.AssertEqual(this[-2]);
Missing Default,Imms.Implementation,FTree<TChild>,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Concat,The following switch statement is missing a default case: switch (status) {  					//+ Implementation  					//This should be farily legible. It is a solution I like to call a 'case table'  					//Note that TreeType is *not* an enum but a static class with constants.  					//This is because enums do not support the bitwise << operator.    					/* If either of the trees is empty*/  					case TreeType.Empty << 3 | TreeType.Single:  					case TreeType.Empty << 3 | TreeType.Compound:  						return last;  					case TreeType.Single << 3 | TreeType.Empty:  					case TreeType.Compound << 3 | TreeType.Empty:  						return first;  					case TreeType.Empty << 3 | TreeType.Empty:  						return first;  					/* If both are single... we just create a new Compound with their digits.*/  					case TreeType.Single << 3 | TreeType.Single:  						var single1 = (Single) first;  						var single2 = (Single) last;  						return new Compound(single1.CenterDigit' FTree<Digit>.Empty'  							single2.CenterDigit' lineage);  					case TreeType.Single << 3 | TreeType.Compound:  						var asSingle = (Single) first;  						var asCompound = (Compound) last;  						Digit left' mid' right;  						asSingle.CenterDigit.Fuse(asCompound.LeftDigit' out left' out mid' out right' lineage);  						newDeep = asCompound.DeepTree;  						if (right != null) {  							newDeep = newDeep.AddFirst(right' lineage);  						}  						if (mid != null) {  							newDeep = newDeep.AddFirst(mid' lineage);  						}  						return new Compound(left' newDeep' asCompound.RightDigit' lineage);  					/* If one is single' we push the digit of the Compound into its Deep.*/  					case TreeType.Compound << 3 | TreeType.Single:  						var rightSingle = (Single) last;  						var leftCompound = (Compound) first;  						Digit rLeft' rMid' rRight;  						leftCompound.RightDigit.Fuse(rightSingle.CenterDigit' out rLeft' out rMid' out rRight' lineage);  						Digit rDigit;  						newDeep = leftCompound.DeepTree;  						if (rMid != null) {  							newDeep = newDeep.AddLast(rLeft' lineage);  							if (rRight != null) {  								newDeep = newDeep.AddLast(rMid' lineage);  								rDigit = rRight;  							} else {  								rDigit = rMid;  							}  						} else {  							rDigit = rLeft;  						}  						return new Compound(leftCompound.LeftDigit' newDeep' rDigit' lineage);    					/* This is the most complex case.  				 * First note that when we have two Compounds' we essentially have two inner digits and two outer digits:  				 *		A..B ++ C..D => A..D  				 *	The digits B C must somehow be pushed into the FTree' but the digits A D are going to be its left and right digits.  				 *	What we do with the digits B C is call the function ReformDigitsForConcat on the inner digits  				 *	Because the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees  				 *	We need to reform the digits' whatever their current shape' into 2-3 digits.  				 *	Look up the function to see how it's done.  				 */  					case TreeType.Compound << 3 | TreeType.Compound:  						Digit leftmost;  						Digit middle;  						Digit rightmost;  						var compound1 = (Compound) first;  						var compound2 = (Compound) last;  						var innerLeft = compound1.RightDigit;  						var innerRight = compound2.LeftDigit;  						innerLeft.Fuse(innerRight' out leftmost' out middle' out rightmost' lineage);  						FTree<Digit> deep;  						if (compound1.Measure > compound2.Measure)  							//We want to push the small tree into the large one.   						{  							deep = compound1.DeepTree;  							if (leftmost != null) deep = deep.AddLast(leftmost' lineage);  							if (middle != null) deep = deep.AddLast(middle' lineage);  							if (rightmost != null) deep = deep.AddLast(rightmost' lineage);  							deep = FTree<Digit>.Concat(deep' compound2.DeepTree' lineage);  						} else {  							deep = compound2.DeepTree;  							if (rightmost != null) deep = deep.AddFirst(rightmost' lineage);  							if (middle != null) deep = deep.AddFirst(middle' lineage);  							if (leftmost != null) deep = deep.AddFirst(leftmost' lineage);  							deep = FTree<Digit>.Concat(compound1.DeepTree' deep' lineage);  						}  						return new Compound(compound1.LeftDigit' deep' compound2.RightDigit' lineage);  				}
Missing Default,Imms.Implementation,Compound,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Compound.cs,Insert,The following switch statement is missing a default case: switch (whereIsThisIndex) {  						case IN_START:  						case IN_MIDDLE_OF_LEFT:  							Digit leftL' leftR;  							LeftDigit.Insert(index' leaf' out leftL' out leftR' lineage);  							newDeep = leftR != null ? DeepTree.AddFirst(leftR' lineage) : DeepTree;  							res = MutateOrCreate(leftL' newDeep' RightDigit' lineage);  							break;  						case IN_START_OF_DEEP:  						case IN_MIDDLE_OF_DEEP:  							if (DeepTree.Measure == 0) goto case IN_START_OF_RIGHT;  							newDeep = DeepTree.Insert(index - LeftDigit.Measure' leaf' lineage);  							res = MutateOrCreate(LeftDigit' newDeep' RightDigit' lineage);  							break;  						case IN_START_OF_RIGHT:  						case IN_MIDDLE_OF_RIGHT:  							Digit rightR;  							Digit rightL;  							RightDigit.Insert(index - LeftDigit.Measure - DeepTree.Measure' leaf' out rightL' out rightR' lineage);  							newDeep = rightR != null ? DeepTree.AddLast(rightL' lineage) : DeepTree;  							rightR = rightR ?? rightL;  							res = MutateOrCreate(LeftDigit' newDeep' rightR' lineage);  							break;  					}
Missing Default,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddFirst,The following switch statement is missing a default case: switch (Size) {  						case 1:  							return MutateOrCreate(item' First' lineage);  						case 2:  							return MutateOrCreate(item' First' Second' lineage);  						case 3:  							return MutateOrCreate(item' First' Second' Third' lineage);  						case 4:  							throw ImplErrors.Digit_too_large(Size);  					}
Missing Default,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,AddLast,The following switch statement is missing a default case: switch (Size) {  						case 1:  							return MutateOrCreate(First' item' lineage);  						case 2:  							return MutateOrCreate(First' Second' item' lineage);  						case 3:  							return MutateOrCreate(First' Second' Third' item' lineage);  						case 4:  							throw ImplErrors.Bad_digit_size(Size);  					}
Missing Default,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveFirst,The following switch statement is missing a default case: switch (Size) {  						case 1:  							throw ImplErrors.Digit_too_small(Size);  						case 2:  							return MutateOrCreate(Second' lineage);  						case 3:  							return MutateOrCreate(Second' Third' lineage);  						case 4:  							return MutateOrCreate(Second' Third' Fourth' lineage);  					}
Missing Default,Imms.Implementation,Digit,C:\repos\GregRos_Solid\Imms\Imms.Collections\Implementation\FingerTree\Digit.cs,RemoveLast,The following switch statement is missing a default case: switch (Size) {  						case 1:  							throw ImplErrors.Bad_digit_size(Size);  						case 2:  							return MutateOrCreate(First' lineage);  						case 3:  							return MutateOrCreate(First' Second' lineage);  						case 4:  							return MutateOrCreate(First' Second' Third' lineage);  					}
